module LambdaUnion where

-- TODO: make use of the fact that terms are always fully applied
-- TODO: non-deterministic full β-reduction
-- TODO: capture-avoiding substitution
-- TODO: types (kinds)
-- TODO: generate arbitrary (well-typed) terms
-- TODO: test confluence, type preservation, uniqueness of normal forms, etc.

import Data.Set

-- | Names

type Name = Int

-- | Expressions

data Sort = C | Sort :=> Sort
    deriving (Eq, Show)

-- TODO: parameterize over a type of constants (single-sorted)
-- TODO: (future work) can we do multi-sorted algebras elegantly with type families?
-- TODO: (future work) generalize over the underlying first-order algebra
data Tm
    = Var Name
    | Abs Name Sort Tm
    | App Tm Tm
    | Union Tm Tm
    | Empty

instance Show Tm where
    show (Var   x    ) = "x" ++ show x
    show (Abs   x s e) = "(λx" ++ show x ++ ":" ++ show s ++ "." ++ show e ++ ")"
    show (App   e1 e2) = "(" ++ show e1 ++ " " ++ show e2 ++ ")"
    show (Union e1 e2) = "(" ++ show e1 ++ "∪" ++ show e2 ++ ")"
    show (Empty      ) = "∅"

-- * Syntactic equality up to alpha-renaming

synEqAlpha :: Tm -> Tm -> Bool
synEqAlpha (Var x) (Var x')
    = x == x'
synEqAlpha (Abs x s e) (Abs x' s' e')
    | s == s'   = synEqAlpha e (subst x' (Var x) e')
    -- We can expect that the terms to be compared are of the same sort,
    -- so throw an exception instead of returning False.
    | otherwise = error "synEqAlpha: sort mismatch"
synEqAlpha (App e1 e2) (App e1' e2')
    = synEqAlpha e1 e1' && synEqAlpha e2 e2'
synEqAlpha (Union e1 e2) (Union e1' e2')
    = synEqAlpha e1 e1' && synEqAlpha e2 e2'
synEqAlpha Empty Empty
    = True
synEqAlpha _ _
    = False
    
-- * Free variables

fv :: Tm -> Set Name
fv (Var   x    ) = singleton x
fv (Abs   x k e) = delete x (fv e)
fv (App   e1 e2) = union (fv e1) (fv e2)
fv (Union e1 e2) = union (fv e1) (fv e2)

-- * Substitution
    
subst :: Name -> Tm -> Tm -> Tm
subst x e (Var y)
    | x == y    = e
    | otherwise = Var y
subst x e (Abs y k e')
    | x == y          = Abs y k e'
    -- FIXME: does this catch all captures?
    | y `member` fv e = error "variable captured"
    | otherwise       = Abs y k (subst x e e')
subst x e (App e1 e2)
    = App (subst x e e1) (subst x e e2)
subst x e (Union e1 e2)
    = Union (subst x e e1) (subst x e e2)

-- * Reduction (1-step, top-level)

-- FIXME: need to add a "hack" for App Empty's generated by the solver

reduce :: Tm -> Maybe Tm
reduce (App (Abs x k e1)  e2)   = Just $ subst x e2 e1
reduce (App (Union e1 e2) e3)   = Just $ Union (App e1 e3) (App e2 e3)
reduce (Union (Union e1 e2) e3) = Just $ Union e1 (Union e2 e3)
-- order unions (through applications; what to do about abstractions?)
-- combine arguments
reduce _                        = Nothing

-- * Normalization (full β-reduction)

-- FIXME: also need to η-expand?

normalize :: Tm -> Tm
normalize (Var x)
    = Var x
normalize (Abs x k e)
    = Abs x k (normalize e)
normalize (App e1 e2)
    = let e1' = normalize e1
          e2' = normalize e2
       in case reduce (App e1' e2') of
            Just e' -> normalize e'
            Nothing -> App e1' e2'
normalize (Union e1 e2)
    = let e1' = normalize e1
          e2' = normalize e2
       in case reduce (Union e1' e2') of
            Just e' -> normalize e'
            Nothing -> Union e1' e2'
