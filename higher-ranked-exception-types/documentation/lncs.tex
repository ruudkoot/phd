\documentclass{llncs}

%FIXME - ICFP: Haskell -> functional programming language
%FIXME - ICFP: neutered overview
%FIXME - ICFP: neutered section/lambda-union
%FIXME - ICFP: moved figures around
%FIXME - ICFP: neutered acknowledgements
%FIXME - ICFP: neutered bibliography


% Math Times
%\usepackage[T1]{fontenc}
%\usepackage{times}
%\usepackage[mtbold,mtplusscr,mtpluscal,slantedgreek,T1]{mathtime}
%\usepackage{bm}

% MTPro2
%\usepackage[lite,subscriptcorrection,slantedGreek,nofontinfo]{mtpro2}
%\usepackage[lite,subscriptcorrection,slantedGreek,nofontinfo]{mtpro2}
% slantedGreek..?

\usepackage{amsmath}
\usepackage{amssymb}
%\usepackage{amsthm}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage[usenames,dvipsnames,svgnames,table]{xcolor}
\usepackage[numbers]{natbib}
\usepackage{xspace}
\usepackage{hyperref}

\newcommand{\ThesisPaper}[2]{#2}

\allowdisplaybreaks[1]

%\def\labelitemi{--}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%
%
%
% First, let's redefine the forall, and the dot.
%
%
% This is made in such a way that after a forall, the next
% dot will be printed as a period, otherwise the formatting
% of `comp_` is used. By redefining `comp_`, as suitable
% composition operator can be chosen. Similarly, period_
% is used for the period.
%
\ReadOnlyOnce{forall.fmt}%
\makeatletter

% The HaskellResetHook is a list to which things can
% be added that reset the Haskell state to the beginning.
% This is to recover from states where the hacked intelligence
% is not sufficient.

\let\HaskellResetHook\empty
\newcommand*{\AtHaskellReset}[1]{%
  \g@addto@macro\HaskellResetHook{#1}}
\newcommand*{\HaskellReset}{\HaskellResetHook}

\global\let\hsforallread\empty

\newcommand\hsforall{\global\let\hsdot=\hsperiodonce}
\newcommand*\hsperiodonce[2]{#2\global\let\hsdot=\hscompose}
\newcommand*\hscompose[2]{#1}

\AtHaskellReset{\global\let\hsdot=\hscompose}

% In the beginning, we should reset Haskell once.
\HaskellReset

\makeatother
\EndFmtInput

\newcommand{\TODO}{\textcolor{red}{\textsc{To do.}}}
\newcommand{\TODOX}[1]{\textcolor{red}{\textsc{To do}: #1}}
\newcommand{\LORUMIPSUM}{\textcolor{red}{Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.}}
\newcommand{\fv}[1]{\mathrm{fv}(#1)}
%\newtheorem{conjecture}{Conjecture}
%\newtheorem{corollary}{Corollary}
%\newtheorem{lemma}{Lemma}
%\newtheorem{theorem}{Theorem}

%\theoremstyle{definition}
%\newtheorem{definition}{Definition}
%\newtheorem{example}{Example}
\newtheorem{counterexample}{Counterexample}

\newcommand{\IH}[1]{\stackrel{\text{i.h.}}{#1}}
% Alignments
\newcommand{\HOR}{\quad}
\newcommand{\VER}{\\[1.5ex]}

% Inference rules
\newcommand{\Rule}[3]{\frac{#2}{#3}\mbox{\ [\textsc{#1}]}}
\newcommand{\RulX}[3]{\frac{#2}{#3}}
\newcommand{\CiteRule}[1]{\mbox{\textsc{#1}}}

\newcommand{\CaseRule}[1]{Case \textsc{#1}: }
\newcommand{\Case}[1]{Case ``#1'': }
\newcommand{\Subcase}[1]{Subcase ``#1'': }

% Environments
\newcommand{\EmptyEnv}{\emptyset}

% Substitutions
\newcommand{\Subst}[3]{#3[#1/#2]}
\newcommand{\SubstTwo}[5]{#5[#1;#3/#2;#4]}
\newcommand{\SubstS}[3]{#3[\overline{#1}/\overline{#2}]}
%%%% GENERIC FORMATTING FOR LHS2TEX CODE


















\newcommand\labell[1]{\label{\currentprefix:#1}}
\newcommand\refl[1]{\ref{\currentprefix:#1}}
\newcommand\eqrefl[1]{\eqref{\currentprefix:#1}}

\newcommand{\SystemFw}{System~$\mathrm{F}_\omega$\xspace}
\newcommand{\ACIone}{\textsc{aci}\oldstylenums{1}\xspace}
\newcommand{\LambdaUnion}{\lambda^\cup}

\newcommand{\ClassLuCon}{\mathbf{Con}}
\newcommand{\ClassLuEnv}{\mathbf{Env}}
\newcommand{\ClassLuTm}{\mathbf{Tm}}
\newcommand{\ClassLuTy}{\mathbf{Ty}}
\newcommand{\ClassLuKind}{\mathbf{Kind}}            %% Lu?
\newcommand{\ClassLuVar}{\mathbf{Var}}

\newcommand{\LuAbs}[3]{\lambda #1 : #2. #3}
\newcommand{\LuTyAbs}[3]{\Lambda #1 : #2. #3}       %% Lu?
\newcommand{\LuApp}[2]{#1\ #2}
\newcommand{\LuTyApp}[2]{#1\ \left<#2\right>}       %% Lu?
\newcommand{\LuArr}[2]{{#1 \to #2}}
\newcommand{\LuARR}[2]{{#1 \Rightarrow #2}}         %% Lu?
\newcommand{\LuBase}{\text{\rotatebox[origin=c]{180}{$\star$}}}
\newcommand{\LuCON}{c}
\newcommand{\LuCon}[1][\LuCON]{\{#1\}}
\newcommand{\LuEmpty}{\emptyset}
\newcommand{\LuEnv}{\Gamma}
\newcommand{\LuOrder}[2]{#1 \prec #2}
\newcommand{\LuTm}{t}
\newcommand{\LuTy}{\tau}
\newcommand{\LuTyVar}{\alpha}                       %% Lu?
\newcommand{\LuForall}[3]{\forall #1 :: #2. #3}     %% Lu?
\newcommand{\LuKind}{\kappa}                        %% Lu?
\newcommand{\LuUnion}[2]{#1 \cup #2}
\newcommand{\LuVal}{v}
\newcommand{\LuVar}{x}
\newcommand{\LuVarY}{y}

\newcommand{\LuCtx}[1]{C\!\left[#1\right]}

\newcommand{\LuAPPLIED}[1][]{\LuVar\ \LuTm_1#1 \cdots \LuTm_n#1}

\newcommand{\JudgeLuTy}[3][\LuEnv]{#1 \vdash #2 : #3}
\newcommand{\JudgeLuSub}[3][\LuEnv]{#1 \vdash #2 \lesssim #3}
\newcommand{\JudgeLuEqv}[3][\LuEnv]{#1 \vdash #2 \cong #3}

\newcommand{\REDUCE}{\longrightarrow}
\newcommand{\Reduce}[2]{{#1 \REDUCE #2}}
\newcommand{\ReduceMulti}[2]{{#1 \REDUCE^{*} #2}}

\newcommand{\LuDen}[2][\rho]{\llbracket #2 \rrbracket_{#1}}
\newcommand{\LuDenote}[2]{\llbracket #1 \rrbracket_{\rho\left[\LuVar\mapsto #2\right]}}
\newcommand{\ClassEnv}{\mathbf{Env}}
\newcommand{\ClassTyEnv}{\mathbf{TyEnv}}
\newcommand{\ClassKiEnv}{\mathbf{KiEnv}}
\newcommand{\ClassVal}{\mathbf{Val}}
\newcommand{\ClassExnVal}{\mathbf{ExnVal}}
\newcommand{\ClassTm}{\mathbf{Tm}}
\newcommand{\ClassExnTm}{\mathbf{ExnTm}}
\newcommand{\ClassTy}{\mathbf{Ty}}
\newcommand{\ClassExnTy}{\mathbf{ExnTy}}
\newcommand{\ClassExn}{\mathbf{Exn}}
\newcommand{\ClassKind}{\mathbf{ExnKi}}
\newcommand{\ClassSubst}{\mathbf{Subst}}

\newcommand{\Throws}[2]{#1\langle #2\rangle}    %%%%%%%%%%%%% WHICH TO USE?
\newcommand{\ExnTy}{\widehat\tau}
%\newcommand{\ExnTyBool}{\widehat{\mathrm{bool}}}
\newcommand{\ExnTyBool}{\mathrm{b\widehat{oo}l}}    % FIXME: deprecate
\newcommand{\ExnTyList}[2]{\left[\Throws{#1}{#2}\right]\!}
\newcommand{\ExnTyArr}[4]{\Throws{#1}{#2} \to \Throws{#3}{#4}}
\newcommand{\ExnTyArrS}[4]{\Throws{#1}{#2} \xrightarrow{#4} #3}
\newcommand{\ExnTyArrT}[5]{\Throws{#1}{#2} \xrightarrow{#5} \Throws{#3}{#4}}
\newcommand{\ExnTyForall}[3]{\forall #1 :: #2. #3}
\newcommand{\ExnTyForallS}[3]{\forall \overline{#1 :: #2}. #3}
\newcommand{\ExnForall}[1]{\forall {#1}.}           % FIXME: deprecate

\newcommand{\Exn}{\xi}
\newcommand{\ExnAlt}{\zeta}
\newcommand{\ExnVar}{e}
\newcommand{\ExnPat}{\ExnVar^\prime\ \overline{\ExnVar_i}}
\newcommand{\ExnPatVar}{\pi}
\newcommand{\ExnCon}[1]{\{#1\}}
\newcommand{\ExnLblE}{\mathbf{E}}
\newcommand{\ExnConE}{\ExnCon{\ExnLblE}}
\newcommand{\ExnAbs}[3]{\lambda #1 : #2 . #3}
\newcommand{\ExnApp}[2]{#1\ #2}
\newcommand{\ExnUnion}[2]{#1 \cup #2}
\newcommand{\ExnEmpty}{\emptyset}

\newcommand{\ExnBool}{\mathbf{b\widehat{oo}l}}      % FIXME: \ExnTyBool
\newcommand{\ExnInt}{\mathbf{i\widehat{n}t}}        % FIXME: \ExnTyInt

\newcommand{\Kind}{\kappa}                          % FIXME: \KindVar
\newcommand{\KindEXN}{\textsc{exn}}
\newcommand{\KindDIM}{\textsc{dim}}
\newcommand{\KindArr}{\Rightarrow}

\newcommand{\KindENV}{\Delta}
\newcommand{\KindEnv}[1]{{\overline{\ExnVar_{#1} :: \Kind_{#1}}}}

% Judgements
\newcommand{\JudgeComplete}[5]{{#1 \vdash #2 : #3\ \&\ #4 \triangleright #5}}

\newcommand{\ClassVar}{\mathbf{Var}}
\newcommand{\ClassCon}{\mathbf{Con}}
\newcommand{\ClassExnVar}{\mathbf{ExnVar}}

\newcommand{\Val}{v}
\newcommand{\ExnVal}{\widehat{v}}

\newcommand{\Tm}{t}
\newcommand{\TmVar}{x}
\newcommand{\TmVal}{v}
\newcommand{\TmExnVar}{e}
\newcommand{\TmCon}[1]{c_{#1}}
\newcommand{\TmTrue}{\mathbf{true}}
\newcommand{\TmFalse}{\mathbf{false}}
\newcommand{\TmAbs}[3]{\lambda #1 : #2. #3}
\newcommand{\TmAbsExn}[4]{\lambda #1 : #2\ \&\ #3. #4}
\newcommand{\TmAnnAbs}[3]{\Lambda #1 :: #2. #3}
\newcommand{\TmAnnAbsS}[3]{\Lambda \overline{#1 :: #2}. #3}
\newcommand{\TmApp}[2]{#1\ #2}
\newcommand{\TmAnnApp}[2]{#1\ \langle #2 \rangle}
\newcommand{\TmOp}[2]{#1 \oplus #2}
\newcommand{\TmIf}[3]{\mathbf{if}\ #1\ \mathbf{then}\ #2\ \mathbf{else}\ #3}
\newcommand{\TmCrash}[2]{\lightning_{#1}^{#2}}
\newcommand{\TmSeq}[2]{#1\ \mathbf{seq}\ #2}
\newcommand{\TmFix}[1]{\mathbf{fix}\ #1}
\newcommand{\TmFIX}[3]{\mathbf{fix}\ #1 : #2. #3}
\newcommand{\TmFixExn}[4]{\mathbf{fix}\ #1 : #2\ \&\ #3. #4}
\newcommand{\TmNil}[1]{\left[\right]_{#1}}
\newcommand{\TmCons}[2]{#1 :: #2}
\newcommand{\TmCase}[5]{\mathbf{case}\ #1\ \mathbf{of}\ \{\left[\right]\mapsto #2; #3 :: #4 \mapsto #5\}}

\newcommand{\ExnLbl}{\ell}

\newcommand{\ClassType}{\mathbf{Ty}}
\newcommand{\Ty}{\tau}
\newcommand{\TyBool}{\mathbf{bool}}
\newcommand{\TyInt}{\mathbf{int}}
\newcommand{\TyReal}[1]{\mathbf{real}\langle #1 \rangle}
\newcommand{\TyList}[1]{\left[#1\right]}
\newcommand{\TyArr}[2]{#1 \to #2}

\newcommand{\TyJoin}[2]{#1 \sqcup #2}

\newcommand{\TyEnv}{\Gamma}
\newcommand{\BindTy}[3]{#1 : #2\ \&\ #3}
\newcommand{\KiEnv}{\Delta}
\newcommand{\BindKi}[2]{#1 : #2}

\newcommand{\BottomTy}[1]{\bot_{#1}}

% Judgements
\newcommand{\JudgeTy}[3]{{#1 \vdash #2 : #3}}
\newcommand{\JudgeExnTy}[5]{{#1; #2 \vdash #3 : #4\ \&\ #5}}
\newcommand{\JudgeExn}[3]{{#1 \vdash #2 : #3}}
\newcommand{\JudgeKind}[3]{{#1 \vdash #2 :: #3}}
\newcommand{\JudgeSubTy}[3]{{#1 \vdash #2 \leq #3}}
\newcommand{\JudgeSubExn}[3]{{#1 \vdash #2 \leq #3}}
\newcommand{\JudgeElab}[6]{{#1; #2 \vdash #3 \hookrightarrow #4 : #5\ \&\ #6}}
\newcommand{\JudgeElabM}[6]{{#1; #2 \vdash #3 \hookrightarrow}\\{\quad\quad\quad\quad #4 : #5\ \&\ #6}}
\newcommand{\JudgeTyElab}[3]{{#1 \vdash #2 \downarrow #3}}
\newcommand{\JudgeExnTyWff}[3]{{#2 \vdash #3\ \text{wff}}}
\newcommand{\Interp}[1]{\llbracket #1 \rrbracket}

% Judgements
\newcommand{\JudgeEval}[2]{{#1 \longrightarrow #2}}
\newcommand{\JudgeEvalT}[2]{\begin{multlined}#1 \\ \longrightarrow #2\end{multlined}}
%%%% LHS2TEX COMMANDS FOR TYPESETTING THE ALGORITHMS




%%ormat ExnForall (e) (k) (t)           = "(\ExnForall{e_{" e "} :: " k "} " t ")"





\newcommand{\Complete}{\mathcal{C}}
\newcommand{\Reconstruct}{\mathcal{R}}
\newcommand{\Solve}{\mathcal{S}}
\newcommand{\Match}{\mathcal{M}}
\newcommand{\Instantiate}{\mathcal{I}}
\newcommand{\JOIN}{\mathcal{J}}




\newcommand{\ListNil}{\left[\right]}
\newcommand{\ListCons}[2]{#1 :: #2}
\newcommand{\ListCase}[5]{\mathbf{case}\ #1\ \mathbf{of}\ \left\{ \ListNil \mapsto #2; \ListCons{#3}{#4} \mapsto #5 \right\}}


\begin{document}

%BEGIN sigplanconf-template.tex

%\special{papersize=8.5in,11in}
%\setlength{\pdfpageheight}{\paperheight}
%\setlength{\pdfpagewidth}{\paperwidth}

%\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
%\copyrightyear{20yy} 
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
%\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                 % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Higher-ranked Exception Types}
\author{Ruud Koot\\\texttt{inbox@ruudkoot.nl}}
\institute{Utrecht University}
%\titlenote{Prototype and \textsc{icfp} reviews: \url{https://www.staff.science.uu.nl/~0422819/hret/supplementary-material.tar.gz}}
% https://www.staff.science.uu.nl/~0422819/hret/supplementary-material.tar.gz
%\subtitle{Subtitle Text, if any}

%\authorinfo{Ruud Koot}
%           {Utrecht University}
%           {inbox@@ruudkoot.nl}
%\authorinfo{Ruud Koot}
%           {Utrecht University\titlenote{This material is based upon work supported by the Netherlands Organisation for Scientific Research (\textsc{nwo}) under the project \emph{Higher-ranked Polyvariance Explored} (612.001.120).}}
%           {inbox@@ruudkoot.nl}
%\authorinfo{Ruud Koot}
%           {Utrecht University}
%           {inbox@@ruudkoot.nl}
%\authorinfo{Jurriaan Hage}
%           {Utrecht University}
%           {j.hage@@uu.nl}
%\authorinfo{Ruud Koot \and Juriaan Hage}
%           {Utrecht University\titlenote{This material is based upon work supported by the Netherlands Organisation for Scientific Research (\textsc{nwo}) under the project \emph{Higher-ranked Polyvariance Explored} (612.001.120).}}
%           {inbox@@ruudkoot.nl \and j.hage@@uu.nl}

%\authorinfo{John Doe}
%           {ACME University\titlenote{This material may or may not be based upon work supported by some shady organization under a cryptic project title. We categorically deny everything.}}
%           {john.doe@@acm.org}


\maketitle

\begin{abstract}
We present a type-and-effect system that derives an exception-annotated type signature for a given term of a simply typed non-strict functional language with general recursion and a list data type. This signature declares the set of exceptional values that may be present among the values of the term, or produced by terms of function type. Higher-ranked effect polymorphism and effect operators reminiscent of \SystemFw help to achieve precision and clarity.
%
By restricting the use of higher-ranked polymorphism and operators to the effects, we conjecture the inference problem to remain decidable (in contrast to the type inference problem for \SystemFw). We give a type inference algorithm that builds on the techniques developed by \cite{HoldermansHage}.
%
The types in \SystemFw form a simply typed \mbox{$\lambda$-calculus}. Similarly, the effects in our system form a simply typed algebraic $\lambda$-calculus embellished with the \ACIone-structure of sets ($\LambdaUnion$). We briefly study this language in its own right.
\end{abstract}

%\category{D.1.1}{Programming Techniques}{Applicative (Functional) Programming}
%\category{F.3.3}{Logics and Meanings of Programs}{Studies of Program Constructs---Type structure}
%\category{D.3.3}{Programming Languages}{Language Constructs and Features---Polymorphism}
%\category{F.3.2}{Logics and Meanings of Programs}{Semantics of Programming Languages---Program analysis}

% general terms are not compulsory anymore, 
% you may leave them out
%\terms
%Languages, Design, Theory

%\keywords
%exceptions, higher-ranked polymorphism, polymorphic recursion, type-and-effect systems, type-based program analysis, type inference, type operators, unification theory

%END sigplanconf-template.tex

\section{\ThesisPaper{Motivation}{Introduction}}

%FIXME - ICFP: Haskell -> functional programming language
%FIXME - ICFP: neutered overview

An often-heard selling point of non-strict functional languages is that they provide strong and expressive type systems that make side-effects explicit. This supposedly makes software more reliable by lessening the mental burden placed on programmers. Many programmers with a background in object-oriented languages are thus quite surprised, when making the transition to a functional language, that they lose a feature their type system formerly did provide: the tracking of uncaught exceptions.

There is an excuse for why this feature is missing from the type systems of contemporary non-strict functional languages: in a strict first-order language it is sufficient to annotate each function with a single set of uncaught exceptions the function may raise; in a non-strict higher-order language the situation becomes significantly more complicated. Let us first consider the two aspects `higher-order' and `non-strict' in isolation:

\begin{description}

    \item [Higher-order functions] The set of exceptions that may be raised by a higher-order function is not given by a fixed set of exceptions, but depends on the set of exceptions that may be raised by the function that is passed as its functional argument. Higher-order functions are thus \emph{exception polymorphic}.

    \item [Non-strict evaluation] In non-strictly evaluated languages, exceptions are not a form of control flow, but a kind of value. Typically the set of values of each type is extended with an \emph{exceptional value} $\lightning$ (more commonly denoted $\bot$, but we shall not do so to avoid ambiguity), or family of exceptional values~$\lightning^\ell$. This means we do not only need to give all functions an exception-annotated function type, but give every other expression an exception-annotated type as well.

\end{description}

Now let us consider these two aspects in combination. Take as an example the \ensuremath{\Varid{map}} function:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}c<{\hspost}@{}}%
\column{6E}{@{}l@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{36}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{map}{}\<[6]%
\>[6]{}:{}\<[6E]%
\>[10]{}\forall \alpha\beta\hsforall \hsdot{\circ }{.}(\alpha\to \beta)\to [\mskip1.5mu \alpha\mskip1.5mu]\to [\mskip1.5mu \beta\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{map}{}\<[6]%
\>[6]{}\mathrel{=}{}\<[6E]%
\>[10]{}\lambda\Varid{f}.\lambda\Varid{xs}.\;\mathbf{case}\;\Varid{xs}\;\mathbf{of}{}\<[E]%
\\
\>[10]{}\hsindent{18}{}\<[28]%
\>[28]{}[\mskip1.5mu \mskip1.5mu]{}\<[36]%
\>[36]{}\mapsto [\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[10]{}\hsindent{18}{}\<[28]%
\>[28]{}(\Varid{y}::\Varid{ys}){}\<[36]%
\>[36]{}\mapsto \Varid{f}\;\Varid{y}::\Varid{map}\;\Varid{f}\;\Varid{ys}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We denote the exception-annotated type of a term by $\widehat\tau\ \&\ \Exn$ or~$\widehat\tau\langle\Exn\rangle$. For function types we occasionally write $\widehat\tau_1\langle\Exn_1\rangle \xrightarrow{\Exn} \widehat\tau_2\langle\Exn_2\rangle$ instead of $\left(\widehat\tau_1\langle\Exn_1\rangle \rightarrow \widehat\tau_2\langle\Exn_2\rangle\right)\!\langle\Exn\rangle$. If $\Exn$ is the empty exception set, then we sometimes omit this annotation completely.

The fully exception-polymorphic and exception-annotated type, or \emph{exception type}, of \ensuremath{\Varid{map}} is\ThesisPaper{\TODO{cramped formatting}}{}
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{6}{@{}>{\hspre}c<{\hspost}@{}}%
\column{6E}{@{}l@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{57}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{map}{}\<[6]%
\>[6]{}:{}\<[6E]%
\>[10]{}\forall \alpha\hsforall \;\beta\;\Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{3}}\hsdot{\circ }{.}(\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \Varid{e}_{\mathrm{3}}}\beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{1}} \rangle){}\<[E]%
\\
\>[10]{}\hsindent{47}{}\<[57]%
\>[57]{}\xrightarrow{\emptyset}(\forall \Varid{e}_{\mathrm{4}}\hsforall \;\Varid{e}_{\mathrm{5}}\hsdot{\circ }{.}[\mskip1.5mu \alpha\langle \Varid{e}_{\mathrm{4}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle\xrightarrow{\emptyset}[\mskip1.5mu \beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{4}}\cup \Varid{e}_{\mathrm{3}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The exception type of the first argument \ensuremath{\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \Varid{e}_{\mathrm{3}}}\beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{1}} \rangle} states that it can be instantiated with a function that accepts any exceptional value as its argument (as the exception set \ensuremath{\Varid{e}_{\mathrm{1}}} is universally quantified) and returns a possibly exceptional value. In case the return value is exceptional, then it is one from the exception set \ensuremath{\Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{1}}}. Here \ensuremath{\Varid{e}_{\mathrm{2}}} is an \emph{exception set operator}---a function that takes a number of exception sets and exception set operators, and transforms them into another exception set, for example by adding a number of new elements to them, or discarding them and returning the empty set. Furthermore, the function (closure) itself may be an exceptional value from the exception set \ensuremath{\Varid{e}_{\mathrm{3}}}.

The exception type of the second argument \ensuremath{[\mskip1.5mu \alpha\langle \Varid{e}_{\mathrm{4}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle} states that it should be a list. Any of the exceptional elements in the list must be exceptional values from the exception set \ensuremath{\Varid{e}_{\mathrm{4}}}. Any exceptional values among the constructors that form the spine of the list must be exceptional values from the exception set \ensuremath{\Varid{e}_{\mathrm{5}}}.

The result of \ensuremath{\Varid{map}} is a list with the exception type \ensuremath{[\mskip1.5mu \beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{4}}\cup \Varid{e}_{\mathrm{3}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle}. Any exceptional constructors in the spine of this list must be exceptional values from the exception set \ensuremath{\Varid{e}_{\mathrm{5}}}, the same exception set as where exceptional values in the spine of the list argument \ensuremath{\Varid{xs}} come from. By looking at the definition of \ensuremath{\Varid{map}} we can see why this is the case: \ensuremath{\Varid{map}} only produces non-exceptional constructors, but the pattern-match on the list argument \ensuremath{\Varid{xs}} propagates any exceptional values encountered there. The elements of the list are produced by the function application \ensuremath{\Varid{f}\;\Varid{y}}. Recall that \ensuremath{\Varid{f}} has the exception type \ensuremath{\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \Varid{e}_{\mathrm{3}}}\beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{1}} \rangle}. Now, one of two things can happen:
    \begin{enumerate}

        \item If \ensuremath{\Varid{f}} is an exceptional function value, then it must be one from the exception set \ensuremath{\Varid{e}_{\mathrm{3}}}. Applying the exceptional value to an argument causes the exceptional value to be propagated.
        
        \item Otherwise, \ensuremath{\Varid{f}} is a non-exceptional value. The argument \ensuremath{\Varid{y}} has exception type \ensuremath{\alpha\langle \Varid{e}_{\mathrm{4}} \rangle}---it is an element from the list argument \ensuremath{\Varid{xs}}---and so can only be applied to \ensuremath{\Varid{f}} if we instantiate \ensuremath{\Varid{e}_{\mathrm{1}}} to \ensuremath{\Varid{e}_{\mathrm{4}}} first. If \ensuremath{\Varid{f}\;\Varid{y}} produces an exceptional value, then it is thus one from the exception set \ensuremath{\Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{4}}}.
        
    \end{enumerate}
To account for both cases we need to take the union of the two exception sets, giving us a value with the exception type \mbox{\ensuremath{\beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{4}}\cup \Varid{e}_{\mathrm{3}} \rangle}}.

To get a better intuition for the behavior of these exception types and exception set operators, let us see what happens when we apply \ensuremath{\Varid{map}} to two different functions: the identity function \ensuremath{\Varid{id}} and the constant exception-valued function \ensuremath{\Varid{const}\;\lightning^\mathbf{E}}. These two functions can individually be given the exception types:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{61}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[21]{}\Varid{id}{}\<[37]%
\>[37]{}\mathrel{=}\lambda\Varid{x}.\Varid{x}{}\<[61]%
\>[61]{}:\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \emptyset}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle{}\<[E]%
\\
\>[21]{}\Varid{const}\;\lightning^\mathbf{E}{}\<[37]%
\>[37]{}\mathrel{=}\lambda\Varid{x}.\lightning^\mathbf{E}{}\<[61]%
\>[61]{}:\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \emptyset}\beta\langle \{\mathbf{E}\} \rangle{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The term \ensuremath{\Varid{id}} merely propagates its argument to the result unchanged, so it also propagates any exceptional values unchanged. The term \ensuremath{\Varid{const}\;\lightning^\mathbf{E}} discards its argument and always returns the exceptional value \ensuremath{\lightning^\mathbf{E}}. This behavior of \ensuremath{\Varid{id}} and \ensuremath{\Varid{const}\;\lightning^\mathbf{E}} is also reflected in their exception types.

When we apply \ensuremath{\Varid{map}} to \ensuremath{\Varid{id}}, we need to unify the exception type of the formal parameter \ensuremath{\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \Varid{e}_{\mathrm{3}}}\beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{1}} \rangle} with the exception type of the actual parameter \ensuremath{\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \emptyset}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle}. This can be accomplished by instantiating \ensuremath{\Varid{e}_{\mathrm{3}}} to \ensuremath{\emptyset} and \ensuremath{\Varid{e}_{\mathrm{2}}} to \ensuremath{\lambda\Varid{x}.\Varid{x}}---as \ensuremath{(\lambda\Varid{x}.\Varid{x})\;\Varid{e}_{\mathrm{1}}} evaluates to \ensuremath{\Varid{e}_{\mathrm{1}}}---giving us the resulting exception type
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{map}\;\Varid{id}{}\<[23]%
\>[23]{}:\forall \alpha\hsforall \;\Varid{e}_{\mathrm{4}}\;\Varid{e}_{\mathrm{5}}\hsdot{\circ }{.}[\mskip1.5mu \alpha\langle \Varid{e}_{\mathrm{4}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle\xrightarrow{ \emptyset}[\mskip1.5mu \alpha\langle \Varid{e}_{\mathrm{4}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In other words, mapping the identity function over a list propagates all exceptional values already present in the list and introduces no new exceptional values.

When we apply \ensuremath{\Varid{map}} to \ensuremath{\Varid{const}\;\lightning^\mathbf{E}} we unify the exception type of the formal parameter with \ensuremath{\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \emptyset}\beta\langle \{\mathbf{E}\} \rangle}, which can be accomplished by instantiating \ensuremath{\Varid{e}_{\mathrm{3}}} to \ensuremath{\emptyset} and \ensuremath{\Varid{e}_{\mathrm{2}}} to \ensuremath{\lambda\Varid{x}.\{\mathbf{E}\}}---as \ensuremath{(\lambda\Varid{x}.\{\mathbf{E}\})\;\Varid{e}_{\mathrm{1}}} evaluates to \ensuremath{\{\mathbf{E}\}}---giving us the exception type
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{map}\;(\Varid{const}\;\lightning^\mathbf{E}){}\<[23]%
\>[23]{}:\forall \alpha\hsforall \;\beta\;\Varid{e}_{\mathrm{4}}\;\Varid{e}_{\mathrm{5}}\hsdot{\circ }{.}[\mskip1.5mu \alpha\langle \Varid{e}_{\mathrm{4}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle\xrightarrow{ \emptyset}[\mskip1.5mu \beta\langle \{\mathbf{E}\} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
In other words, mapping the constant function with the exceptional value \ensuremath{\lightning^\mathbf{E}} as its range over a list discards all existing exceptional values from the list and produces only non-exceptional values or the exceptional value \ensuremath{\lightning^\mathbf{E}} as elements of the list.

% LNCS %include introduction/overview.lhs2tex
% LNCS %include introduction/contributions.lhs2tex
\section{The $\LambdaUnion$-calculus}\label{section-lambda-union}

%FIXME - ICFP: made the syntax of \lambda^\cup into not-a-figure
%FIXME - ICFP: neutered widening

The $\LambdaUnion$-calculus is a simply typed $\lambda$-calculus extended at the term-level with empty set and singleton set constants, and a set union operator. The $\LambdaUnion$-calculus forms the language of effects in the type-and-effect system developed in Section~\ref{section-exception-types}.

\subsection{Syntax, types and semantics}

We let $\LuVar \in \ClassVar$ range over an infinite set of variables and $c \in \ClassCon$ over a non-empty set of constants. The syntax of types $\LuTy$, terms $\LuTm$, and environments $\LuEnv$ is given by:
%\begin{figure}[h]
%\paragraph{Types}
\begin{align*}
    \LuTy \in \ClassLuTy \ ::=\ \LuBase \ |\  \LuArr{\LuTy_1}{\LuTy_2}
\end{align*}
%\paragraph{Terms}
\begin{align*}
    \LuTm \in \ClassLuTm \ ::=\    \LuVar
                         \ |\   \LuAbs{\LuVar}{\LuTy}{\LuTm}
                         \ |\   \LuApp{\LuTm_1}{\LuTm_2}
                         \ |\   \LuEmpty
                         \ |\   \LuCon
                         \ |\   \LuUnion{\LuTm_1}{\LuTm_2}
\end{align*}
%\paragraph{Environments}
\begin{align*}
    \LuEnv \in \ClassLuEnv\ ::=\ \EmptyEnv \ | \ \LuEnv, \LuVar : \LuTy
\end{align*}
%\caption{$\LambdaUnion$-calculus: syntax}
%\end{figure}

%\subsection{Typing relation}

The typing relation of the $\LambdaUnion$-calculus is an extension of the typing relation of the simply typed $\lambda$-calculus.
% ICFP \begin{figure}[h]
\begin{gather*}
    \RulX{T-Var}
         {}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy]{\LuVar}{\LuTy}}
    \quad
    \RulX{T-Abs}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy_1]{\LuTm}{\LuTy_2}}
         {\JudgeLuTy{\LuAbs{\LuVar}{\LuTy_1}{\LuTm}}{\LuArr{\LuTy_1}{\LuTy_2}}}
    \quad
    \RulX{T-App}
         {\JudgeLuTy{\LuTm_1}{\LuArr{\LuTy_1}{\LuTy_2}} \quad \JudgeLuTy{\LuTm_2}{\LuTy_1}}
         {\JudgeLuTy{\LuApp{\LuTm_1}{\LuTm_2}}{\LuTy_2}}
    \VER
    \RulX{T-Empty}
         {}
         {\JudgeLuTy{\LuEmpty}{\LuBase}}
    \quad
    \RulX{T-Con}
         {}
         {\JudgeLuTy{\LuCon}{\LuBase}}
    \quad
    \RulX{T-Union}
         {\JudgeLuTy{\LuTm_1}{\LuTy} \quad \JudgeLuTy{\LuTm_2}{\LuTy}}
         {\JudgeLuTy{\LuUnion{\LuTm_1}{\LuTm_2}}{\LuTy}}
\end{gather*}
% ICFP \caption{$\LambdaUnion$-calculus: type system}
% ICFP \end{figure}
The empty set and singleton set constants are of base type and the set union of two terms can only be taken if the involved terms have the same type.

%\subsection{Semantics}

In the $\LambdaUnion$-calculus, terms are interpreted as sets and types as powersets.
%\begin{figure}[h]
    \paragraph{Types and values}
    \begin{align*}
        V_\LuBase &= \mathcal{P}(\ClassCon) \\
        V_{\tau_1 \to \tau_2} &= \mathcal{P}(V_{\tau_1} \to V_{\tau_2})
    \end{align*}
    \paragraph{Environments}
    \begin{align*}
        \rho &: \ClassVar \to \bigcup \left\{V_\tau \mid \tau\ \mathrm{type}\right\}
    \end{align*}
    \paragraph{Terms}
    \begin{align*}
        \llbracket \LuVar \rrbracket_\rho &= \rho(x) \\
        \llbracket \LuAbs{\LuVar}{\LuTy}{\LuTm} \rrbracket_\rho &= \left\{ \lambda v \in V_\tau. \llbracket t \rrbracket_{\rho[\LuVar \mapsto v]} \right\} \\
        \llbracket \LuApp{\LuTm_1}{\LuTm_2} \rrbracket_\rho &= \bigcup \left\{ \varphi(\llbracket \LuTm_2 \rrbracket_\rho) \mid \varphi \in \llbracket \LuTm_1 \rrbracket_\rho \right\}\\
        \llbracket \LuEmpty \rrbracket_\rho &= \LuEmpty \\
        \llbracket \LuCon \rrbracket_\rho &= \LuCon \\
        \llbracket \LuUnion{\LuTm_1}{\LuTm_2} \rrbracket_\rho &= \llbracket \LuTm_1 \rrbracket_\rho \cup \llbracket \LuTm_2 \rrbracket_\rho
    \end{align*}
%    \caption{$\LambdaUnion$-calculus: denotational semantics}
%\end{figure}

\subsection{Subsumption and observational equivalence}

The set-structure of the $\LambdaUnion$-calculus induces a partial order on the terms.

%\begin{definition}
%We say that a term environment $\rho$ is \emph{compatible} with a type environment $\Gamma$ if $\mathrm{dom}(\rho) = \mathrm{dom}(\Gamma)$ and for all $x \in \mathrm{dom}(\rho)$ we have that $\Gamma \vdash \rho(x) : \Gamma(x)$.
%\end{definition}

\begin{definition}
Denote by $\LuCtx{}$ a \emph{context}---a $\LambdaUnion$-term with a single hole in it---and by $\LuCtx{\LuTm}$ the term obtained by replacing the hole in $\LuCtx{}$ with the term $\LuTm$.
\end{definition}

\begin{definition}\label{definition-subsumption}
    Let $\LuTm_1$ and $\LuTm_2$ be terms such that $\JudgeLuTy{\LuTm_1}{\LuTy}$ and $\JudgeLuTy{\LuTm_2}{\LuTy}$.
    We say the term $\LuTm_2$ \emph{subsumes} the term $\LuTm_1$, written $\JudgeLuSub{\LuTm_1}{\LuTm_2}$, if for any context $\LuCtx{}$ such that $\JudgeLuTy[]{\LuCtx{\LuTm_1}}{\LuBase}$ and $\JudgeLuTy[]{\LuCtx{\LuTm_2}}{\LuBase}$ we have that $\LuDen[\emptyset]{\LuCtx{\LuTm_1}} \subseteq \LuDen[\emptyset]{\LuCtx{\LuTm_2}}$.
\end{definition}

\begin{definition}
    Let $\LuTm_1$ and $\LuTm_2$ be terms such that $\JudgeLuTy{\LuTm_1}{\LuTy}$ and $\JudgeLuTy{\LuTm_2}{\LuTy}$.
    We say that terms $\LuTm_1$ and $\LuTm_2$ are \emph{observationally equivalent}, denoted $\JudgeLuEqv{\LuTm_1}{\LuTm_2}$, if
    \begin{enumerate}
        \item $\JudgeLuSub{\LuTm_1}{\LuTm_2}$ and $\JudgeLuSub{\LuTm_2}{\LuTm_1}$, or equivalently that
        \item for any context $\LuCtx{}$ such that $\JudgeLuTy[]{\LuCtx{\LuTm_1}}{\LuBase}$ and $\JudgeLuTy[]{\LuCtx{\LuTm_2}}{\LuBase}$ we have that $\LuDen[\emptyset]{\LuCtx{\LuTm_1}} = \LuDen[\emptyset]{\LuCtx{\LuTm_2}}$.
    \end{enumerate}
\end{definition}

%%include ../theorem/lu-gamma1.lhs2tex
%%include ../theorem/lu-gamma2.lhs2tex
%%include ../proof/lu-gamma2-sketch.lhs2tex

\subsection{Normalization}

To reduce $\LambdaUnion$-terms to a canonical normal form we combine the $\beta$-reduction rule of the simply typed $\lambda$-calculus with rewrite rules that deal with the associativity, commutativity, idempotence and identity (\ACIone) properties of the set union operator.

\subsubsection{$\beta$- and $\gamma$-reduction}

If a term $t$ is $\eta$-long---i.e., it cannot be $\eta$-expanded without introducing additional $\beta$-redexes---it can be written in the form
\begin{align*}
    t = \lambda x_1 \cdots x_n. f_1(t_{11}, ..., t_{1q_1}) \cup \cdots \cup f_p(t_{p1}, ..., t_{pq_p})
\end{align*}
where $f_i$ can be a free or bound variable, a singleton-set constant, or another $\eta$-long term; and $q_i$ is equal to the arity of $f_i$ (for all $1 \leq i \leq p$).
Here we have removed any empty set constants (unit elements), duplicate terms $f_i(t_{i1}, ..., t_{iq_i})$ (idempotent elements), and `forgotten' how the set union operator associates.

A \emph{normal form} $v$ of a term $t$---obtained by repeatedly applying the reduction rules
%\begin{figure}[h]
    \begin{gather*}
        \RulX{R-Beta}
             {
             }
             {(\lambda x.t_1)\ t_2 \longrightarrow t_1\left[t_2 / x\right]
             }
        \quad
        \RulX{R-Gamma$_1$}
             {
             }
             {(t_1 \cup \cdots \cup t_n) \ t \longrightarrow t_1\ t \cup \cdots \cup t_n\ t
             }
        \VER
        \RulX{R-Gamma$_2$}
             {
             }
             {(\lambda x.t_1) \cup \cdots \cup (\lambda x.t_n) \longrightarrow \lambda x.t_1 \cup \cdots \cup t_n
             }
    \end{gather*}
%\caption{$\LambdaUnion$-calculus: reduction}\label{figure-lu-reduction}
%\end{figure}
and removing any empty set constants and duplicate terms---can be written as
\begin{align*}
    v = \lambda x_1 \cdots x_n. k_1(v_{11}, ..., v_{1q_1}) \cup \cdots \cup k_p(v_{p1}, ..., v_{pq_p})
\end{align*}
where $k_i$ can be a free or bound variable, or a singleton-set constant, but not a $\lambda$-abstraction (as this would form a $\beta$-redex), nor a union (as this would form a $\gamma_1$-redex).
%For each $k_i, k_j$ with $i < j$ we must also have that $k_i < k_j$ for some total order on $\ClassVar \cup \ClassCon$.
%Not only does this imply that each term $k_i(v_{i1}, ..., v_{iq_i})$ occurs only once in $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$, but also the stronger condition that $k_i \neq k_j$ for all $i\neq j$.

\subsubsection{Canonical ordering}

To be able to efficiently check two normalized terms for definitional equality up to \ACIone, we also need to deal with the commutativity of the union operator. We can bring normalized terms into a fully canonical form by defining a total order on terms and using it to order unions of terms.

First, pick a strict total order $\prec$ on variables and constants. The order must be fixed and be invariant under $\alpha$-renaming of variables (for example, choose the De Bruijn index of a variable), but can otherwise be arbitrary.
We extend this order to a total order on $\beta\gamma$-normal $\eta$-long terms lexicographically:
\begin{enumerate}
\item Given two fully applied terms $k(v_1, ..., v_n)$ and $k^\prime(v_1^\prime, ..., v_m^\prime)$ we define:
\begin{align*}
    k(v_1, ..., v_n) &\prec k^\prime(v_1^\prime, ..., v_m^\prime) && \text{if $k \prec k^\prime$} \\
    k(v_1, ..., v_i, ..., v_n) &\prec k(v_1, ..., v_{i-1},v_i^\prime, ..., v_m^\prime) &&\text{if $v_i \prec v_i^\prime$}
\end{align*}
\item Given two values $\lambda x_1\cdots x_n. K_1 \cup \cdots \cup K_{i-1} \cup K_i \cup \cdots \cup K_p$ and $\lambda x_1\cdots x_n. K_1 \cup \cdots \cup K_{i-1} \cup K_i^\prime \cup \cdots \cup K_q^\prime$ that have been ordered such that $K_1 \prec \cdots \prec K_{i-1} \prec K_i \prec \cdots \prec K_p$ and $K_1 \prec \cdots \prec K_{i-1} \prec K_i^\prime \prec \cdots \prec K_q^\prime$, we define:
\begin{align*}
    &\lambda x_1\cdots x_n. K_1 \cup \cdots \cup K_{i-1} \cup K_i \cup \cdots \cup K_p \\
    &\quad\quad\quad\quad\prec \lambda x_1\cdots x_n. K_1 \cup \cdots \cup K_{i-1} \cup K_i^\prime \cup \cdots \cup K_q^\prime
\end{align*}
if $K_i \prec K_i^\prime$.
\end{enumerate}

Given a term $t$ with the types of the free variables given by the environment $\Gamma$, we denote by $\llfloor t \rrfloor_\Gamma$ the $\beta\gamma$-normal $\eta$-long and canonically ordered reduction of the term $t$.

\subsection{Pattern unification}
%Solving equations in $\lambda$-calculi is usually quite hard, but sometimes very easy.

\begin{definition}\label{definition-pattern}
A $\LambdaUnion$-term is called a \emph{pattern} if it is of the form $f(e_1, ..., e_n)$ where $f$ is a free variable and $e_1, ..., e_n$ are distinct bound variables.
\end{definition}

Note that this definition is a special case of what is usually called a \emph{pattern} in higher-order unification theory \cite{Miller1991,Dowek:2001:HUM:778522.778525}.

If $f(e_1, ..., e_n)$ is a pattern and $t$ a term, then the equation
\[ f : \LuTy_1 \to \cdots \to \LuTy_n \to \LuTy \vdash \forall e_1 : \LuTy_1, ..., e_n : \LuTy_n. f(e_1, ..., e_n) = t \]
has a unique solution given by the unifier \[ \theta = \left[f \mapsto \lambda e_1 : \LuTy_1, ..., e_n : \LuTy_n. t \right]. \]

\section{Source language}\label{section-source-language}

The type-and-effect system is applicable to a simple non-strict functional language that supports boolean, integer and list data types, as well as general recursion.
%In this section we briefly state its syntax and semantics.
%\begin{figure}[h]
\paragraph{Terms}
\begin{alignat*}{2}
    \Tm \in \ClassTm &\ ::=\   &&\ \TmVar                   %\tag{term variable}     \\
                     \ |  \ \TmCon{\Ty}              %\tag{term constant}     \\
                     \ |  \ \TmCrash{\Ty}{\ExnLbl}   %\tag{exceptional constant}\\
                     \ |  \ \TmAbs{\TmVar}{\Ty}{\Tm} %\tag{term abstraction}  \\
                     \ |  \ \TmApp{\Tm_1}{\Tm_2}     %\tag{term application}  \\
                     \ |  \ \TmFIX{\TmVar}{\Ty}{\Tm} %\tag{general recursion} \\
                     \\& &&\ \TmSeq{\Tm_1}{\Tm_2}     %\tag{forcing}           \\
                     \ |  \ \TmOp{\Tm_1}{\Tm_2}      %\tag{operator}          \\
                     \ |  \ \TmIf{\Tm_1}{\Tm_2}{\Tm_3}%\tag{conditional}      \\
                     \\& &&\ \TmNil{\Ty}              %\tag{nil constructor}   \\
                     \ |  \ \TmCons{\Tm_1}{\Tm_2}    %\tag{cons constructor}  \\
                     \ |  \ \TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}
                                                            %\tag{list eliminator}
\end{alignat*}
\paragraph{Values}
\begin{alignat}{2}
\Val \in \ClassVal &\ ::=\  &&\ \TmCon{\Ty}\ |\ \TmAbs{\TmVar}{\Ty}{\Tm}\ |\ \TmFIX{\TmVar}{\Ty}{\Tm}\ |\ \TmNil{\Ty}\ |\ \TmCons{\Tm_1}{\Tm_2} \notag
\end{alignat}
\begin{alignat}{2}
\ExnVal \in \ClassExnVal &\ ::=\  &&\ \TmCrash{\Ty}{\ExnLbl}\ |\ \Val \notag
\end{alignat}
%\caption{Source language: syntax}\label{figure-source-language-syntax}
%\end{figure}

Most constructs in the source language should be familiar. The $\mathbf{seq}$-construct evaluates the term on the left to a value and then continues evaluating the term on the right.

Missing from the language is a construct to `catch' exceptional values. While this may be surprising to programmers familiar with strict languages, it is a common design decision to omit such a construct from the pure fragment of non-strict languages. The omission of such a construct allows for the introduction of a certain amount of non-determinism in the operational semantics of the language---giving more freedom to an optimizing compiler---without breaking referential transparency.

The values of the source language are stratified into non-exceptional values $\Val$ and possibly exceptional values $\ExnVal$.

\subsection{Underlying type system}

The type system of the source language is given here for reference. This is the \emph{underlying type system} with respect to the type-and-effect system that is presented in Section~\ref{section-exception-types}. We assume that any term we type in the type-and-effect system is already well-typed in the underlying type system.

%\begin{figure*}[p]
    \begin{gather*}
        \RulX{U-Var}
             {}
             {\JudgeTy{\TyEnv, \TmVar : \Ty}
                      {\TmVar}
                      {\Ty}
             }
        \quad
        \RulX{U-Con}
             {}
             {\JudgeTy{\TyEnv}
                      {\TmCon{\Ty}}
                      {\Ty}
             }
        \quad
        \RulX{U-Crash}
             {}
             {\JudgeTy{\TyEnv}
                      {\TmCrash{\Ty}{\ExnLbl}}
                      {\Ty}
             }
        \quad
        \RulX{U-Abs}
             {\JudgeTy{\TyEnv, \TmVar : \Ty_1}
                      {\Tm}
                      {\Ty_2}
             }
             {\JudgeTy{\TyEnv}
                      {\TmAbs{\TmVar}{\Ty_1}{\Tm}}
                      {\TyArr{\Ty_1}{\Ty_2}}
             }
        \\[1.5ex]
        \RulX{U-App}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\TyArr{\Ty_2}{\Ty}}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\Ty_2}
             }
             {\JudgeTy{\TyEnv}
                      {\TmApp{\Tm_1}{\Tm_2}}
                      {\Ty}
             }
        \quad
        \RulX{U-Fix}
             {\JudgeTy{\TyEnv,\TmVar:\Ty}
                      {\Tm}
                      {\Ty}
             }
             {\JudgeTy{\TyEnv}
                      {\TmFIX{\TmVar}{\Ty}{\Tm}}
                      {\Ty}
             }
        \quad
        \RulX{U-Op}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\TyInt}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\TyInt}
             }
             {\JudgeTy{\TyEnv}
                      {\TmOp{\Tm_1}{\Tm_2}}
                      {\TyBool}
             }
        \\[1.5ex]
        \RulX{U-Seq}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\Ty_1}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\Ty_2}
             }
             {\JudgeTy{\TyEnv}
                      {\TmSeq{\Tm_1}{\Tm_2}}
                      {\Ty_2}
             }
        \quad
        \RulX{U-If}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\TyBool}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\Ty}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_3}
                      {\Ty}
             }
             {\JudgeTy{\TyEnv}
                      {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                      {\Ty}
             }             
        \\[1.5ex]
        \RulX{U-Nil}
             {}
             {\JudgeTy{\TyEnv}
                      {\TmNil{\Ty}}
                      {\TyList{\Ty}}
             }
        \quad
        \RulX{U-Cons}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\Ty}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\TyList{\Ty}}
             }
             {\JudgeTy{\TyEnv}
                      {\TmCons{\Tm_1}{\Tm_2}}
                      {\TyList{\Ty}}
             }
        \\[1.5ex]
        \RulX{U-Case}
             {%\begin{gathered}
                  \JudgeTy{\TyEnv}
                          {\Tm_1}
                          {\TyList{\Ty_1}}
                  \quad
                  \JudgeTy{\TyEnv}
                          {\Tm_2}
                          {\Ty}
                  \quad
                  \JudgeTy{\TyEnv, \TmVar_1 : \Ty_1, \TmVar_2 : \TyList{\Ty_1}}
                          {\Tm_3}
                          {\Ty}
              %\end{gathered}
             }
             {\JudgeTy{\TyEnv}
                      {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                      {\Ty}
             }
    \end{gather*}
%    \caption{Underlying type system ($\JudgeTy{\TyEnv}{\Tm}{\Ty}$)}
%    \label{figure-underlying-type-system}   
%\end{figure*}

\subsection{Operational semantics}

The operational semantics of the source language is given below. Note that there is a small amount of non-determinism in the order of reduction. For example, in the reduction rules for primitive operators.

We do not go so far as to have an \emph{imprecise exception semantics} \cite{PeytonJones:1999:SIE:301618.301637}. I.e., when the guard of a conditional evaluates to an exceptional value, we do not continue evaluation of the two branches in exception finding mode.

%\begin{figure*}[p]
    \begin{gather*}
        \RulX{E-App}
             {\JudgeEval{\Tm_1}
                        {\Tm_1^\prime}
             }
             {\JudgeEval{\TmApp{\Tm_1}{\Tm_2}}
                        {\TmApp{\Tm_1^\prime}{\Tm_2}}
             }
        \quad
        \RulX{E-AppAbs}
             {}
             {\JudgeEval{\TmApp{(\TmAbsExn{\TmVar}{\ExnTy}{\Exn}{\Tm_1})}{\Tm_2}}
                        {\Subst{\Tm_2}{\TmVar}{\Tm_1}}
             }
        \HOR
        \RulX{E-AppExn}
             {}
             {\JudgeEval{\TmApp{\TmCrash{}{\ExnLbl}}{\Tm_2}}
                        {\TmCrash{}{\ExnLbl}}
             }
        \VER
        \RulX{E-AnnApp}
             {\JudgeEval{\Tm}
                        {\Tm^\prime}
             }
             {\JudgeEval{\TmAnnApp{\Tm}{\Exn}}
                        {\TmAnnApp{\Tm^\prime}{\Exn}}
             }
        \HOR
        \RulX{E-AnnAppAbs}
             {}
             {\JudgeEval{\TmAnnApp{(\TmAnnAbs{\TmExnVar}{\Kind}{\Tm})}{\Exn}}
                        {\Subst{\Exn}{\TmExnVar}{\Tm}}
             }
        \VER
        \RulX{E-Fix$_1$}
             {\JudgeEval{\Tm}
                        {\Tm^\prime}
             }
             {\JudgeEval{\TmFixExn{\TmVar}{\ExnTy}{\Exn}{\Tm}}
                        {\TmFixExn{\TmVar}{\ExnTy}{\Exn}{\Tm^\prime}}
             }
        \quad
        \RulX{E-Fix$_2$}
             {}
             {\JudgeEval{\TmFixExn{\TmVar}{\ExnTy}{\Exn}{\Tm}}
                        {\Subst{\TmFixExn{\TmVar}{\ExnTy}{\Exn}{\Tm}}{\TmVar}{\Tm}}
             }
%        \HOR
%        \RulX{E-FixExn}
%             {}
%             {\JudgeEval{\TmFix{\TmCrash{}{\ExnLbl}}}
%                        {\TmCrash{}{\ExnLbl}}
%             }
        \VER
        \RulX{E-Op$_1$}
             {\JudgeEval{\Tm_1}{\Tm_1^\prime}}
             {\JudgeEval{\TmOp{\Tm_1}{\Tm_2}}{\TmOp{\Tm_1^\prime}{\Tm_2}}}
        \quad
        \RulX{E-Op$_2$}
             {\JudgeEval{\Tm_2}{\Tm_2^\prime}}
             {\JudgeEval{\TmOp{\Tm_1}{\Tm_2}}{\TmOp{\Tm_1}{\Tm_2^\prime}}}
        \HOR
        \RulX{E-Op}
             {}
             {\JudgeEval{\TmOp{\TmVal_1}{\TmVal_2}}{\Interp{\TmOp{\TmVal_1}{\TmVal_2}}}}
        \VER
        \RulX{E-OpExn$_1$}
             {}
             {\JudgeEval{\TmOp{\TmCrash{}{\ExnLbl}}{\Tm_2}}{\TmCrash{}{\ExnLbl}}}
        \quad
        \RulX{E-OpExn$_2$}
             {}
             {\JudgeEval{\TmOp{\Tm_1}{\TmCrash{}{\ExnLbl}}}{\TmCrash{}{\ExnLbl}}}
        \\[1.5ex]
        \RulX{E-Seq$_1$}
             {\JudgeEval{\Tm_1}{\Tm_1^\prime}}
             {\JudgeEval{\TmSeq{\Tm_1}{\Tm_2}}{\TmSeq{\Tm_1^\prime}{\Tm_2}}}
        \quad
        \RulX{E-Seq$_2$}
             {}
             {\JudgeEval{\TmSeq{\TmVal_1}{\Tm_2}}{\Tm_2}}
        \quad
        \RulX{E-SeqExn}
             {}
             {\JudgeEval{\TmSeq{\TmCrash{}{\ExnLbl}}{\Tm_2}}{\TmCrash{}{\ExnLbl}}}
        \\[1.5ex]
        \RulX{E-If}
             {\JudgeEval{\Tm_1}{\Tm_1^\prime}}
             {\JudgeEval{\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}{\TmIf{\Tm_1^\prime}{\Tm_2}{\Tm_3}}}
        \quad
        \RulX{E-IfTrue}
             {}
             {\JudgeEval{\TmIf{\TmTrue}{\Tm_2}{\Tm_3}}{\Tm_2}}
        \\[1.5ex]
        \RulX{E-IfFalse}
             {}
             {\JudgeEval{\TmIf{\TmFalse}{\Tm_2}{\Tm_3}}{\Tm_3}}
        \quad
        \RulX{E-IfExn}
             {}
             {\JudgeEval{\TmIf{\TmCrash{}{\ExnLbl}}{\Tm_2}{\Tm_3}}{\TmCrash{}{\ExnLbl}}}
        \\[1.5ex]
        \RulX{E-Case}
             {\JudgeEval{\Tm_1}{\Tm_1^\prime}}
             {\JudgeEval{\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                        {\TmCase{\Tm_1^\prime}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
             }
        \\[1.5ex]
        \RulX{E-CaseNil}
             {}
             {\JudgeEval{\TmCase{\TmNil{}}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                        {\Tm_2}
             }
        \\[1.5ex]
        \RulX{E-CaseCons}
             {}
             {\JudgeEval{\TmCase{\TmCons{\Tm_1}{\Tm_1^\prime}}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                        {\SubstTwo{\Tm_1}{\TmVar_1}{\Tm_1^\prime}{\TmVar_2}{\Tm_3}}
             }
        \\[1.5ex]
        \RulX{E-CaseExn}
             {}
             {\JudgeEval{\TmCase{\TmCrash{}{\ExnLbl}}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                        {\TmCrash{}{\ExnLbl}}
             }
    \end{gather*}
%    \caption{Operational semantics ($\JudgeEval{\Tm_1}{\Tm_2}$)}
%    \label{figure-operational-semantics}
%\end{figure*}

The reduction rules on the second row apply to constructs that are introduced to the language in Section~\ref{section-exception-types}. This also holds for the additional annotations on the $\lambda$-abstraction and the $\mathbf{fix}$-operator.

\section{Exception types}\label{section-exception-types}

%\subsection{Exception types}

The syntax of well-formed exception types is given in Figure~\ref{fig-exception-type-combined}.
We let $\ExnVar$ range over an infinite set of exception set variables and $\ExnLbl$ over a finite set of exception labels.
An exception type~$\ExnTy$ is formed out of base types (booleans and integers), compound types (lists), function types, and quantifiers (ranging over exception set variables---to avoid complicating the presentation we do \emph{not} allow quantification over type variables, i.e. polymorphism in the underlying type system).

\begin{figure}[h]
    \paragraph{Kinds, types and exception annotations}
    \begin{alignat}{2}
        \Kind \in \ClassKind &\ ::=\ &&\KindEXN \tag{exception set} \\
                             &\quad|  &&\Kind_1 \KindArr \Kind_2 \tag{exception set operator}\\
        \notag\\
        \Exn, \ExnAlt \in \ClassExn  &\ ::=\ &&\ExnVar \tag{exception set variables} \\
                            &\quad|  &&\ExnAbs{\ExnVar}{\Kind}{\Exn} \tag{exception set abstraction}\\
                            &\quad|    &&\ExnApp{\Exn_1}{\Exn_2} \tag{exception set application}\\
                            &\quad|    &&\ExnEmpty \tag{empty exception set} \\
                            &\quad|    &&\ExnCon{\ExnLbl} \tag{singleton exception set} \\
                            &\quad|    &&\ExnUnion{\Exn_1}{\Exn_2} \tag{exception set union} \\
    \notag\\
        \ExnTy \in \ClassExnTy &\ ::=\ &&\ExnForall{\ExnVar :: \Kind}\ExnTy \tag{exception set quantification} \\
                     &\quad|  &&\ExnBool \tag{boolean type} \\
                     &\quad|  &&\ExnInt  \tag{integer type} \\
                     &\quad|  &&\ExnTyList{\ExnTy}{\Exn} \tag{list type} \\
                     &\quad|  &&\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2} \tag{function type}
    \end{alignat}
%    \caption{Exception types: syntax}
%    \label{fig-exception-type-syntax}
%\end{figure}
%\begin{figure}[h]
    \paragraph{Well-formedness}
    \begin{gather*}
        \Rule{W-Forall}
             {\JudgeExnTyWff{d}{\KiEnv,\ExnVar :: \Kind}{\ExnTy}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}}
        \VER
        \Rule{W-Bool}
             {}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnBool}}
        \HOR
        \Rule{W-Int}
             {}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnInt}}
        \VER
        \Rule{W-List}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTy} \quad \JudgeKind{\KiEnv}{\Exn}{\KindEXN}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyList{\ExnTy}{\Exn}}}
        \VER
        \Rule{W-Arr}
             {\begin{gathered}\JudgeExnTyWff{d}{\KiEnv}{\ExnTy_1} \  \JudgeKind{\KiEnv}{\Exn_1}{\KindEXN} \  \JudgeExnTyWff{d}{\KiEnv}{\ExnTy_2} \  \JudgeKind{\KiEnv}{\Exn_2}{\KindEXN}\end{gathered}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}}
    \end{gather*}
     \caption{Exception types: syntax and well-formedness ($\JudgeExnTyWff{d}{\KiEnv}{\ExnTy}$)}
%    \label{fig-exception-type-well-formed}
    \label{fig-exception-type-combined}
\end{figure}

%Type signatures are denoted as $f : \ExnTy\ \&\ \Exn$, where $\ExnTy$ is the exception type of $f$ and $\Exn$ is the (top-most) effect.

For a list with exception type $\ExnTyList{\ExnTy}{\Exn}$ and effect $\ExnAlt$, the type $\ExnTy$ of the elements in the list is \emph{annotated} with an exception set expression~$\Exn$ of kind~$\KindEXN$. This expression gives a set of exceptions, from which any one may be raised when an element of the list is forced. The effect $\ExnAlt$ gives a set of exceptions, from which any one may be raised when a constructor forming the spine of the list is forced.

For a function with exception type $\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}$ and effect~$\ExnAlt$, the argument of type $\ExnTy_1$ is annotated with an exception set expression $\Exn_1$ that gives a set of exceptions that may be raised if the argument is forced in the body of the function. The result of type $\ExnTy_2$ is annotated with an exception set expression $\Exn_2$ that gives the set of exceptions that may be raised when the result of the function is forced. The effect $\ExnAlt$ gives the set of exceptions from which any one may be raised when the function closure is forced.

\begin{example}
The identity function
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}c<{\hspost}@{}}%
\column{9E}{@{}l@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{id}{}\<[9]%
\>[9]{}:{}\<[9E]%
\>[13]{}\forall \Varid{e}\hsforall \hsdot{\circ }{.}\ExnTyArr{\ExnBool}{\Varid{e}}{\ExnBool}{\Varid{e}}\ \&\ \emptyset{}\<[E]%
\\
\>[5]{}\Varid{id}{}\<[9]%
\>[9]{}\mathrel{=}{}\<[9E]%
\>[13]{}\lambda\Varid{x}.\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    propagates any exceptional value passed to it as an argument to the result unchanged. As the identity function is constructed by a literal $\lambda$-abstraction, no exception is raised when the resulting closure is forced, hence the empty effect.
\end{example}

\begin{example}
The exceptional function value
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\lightning^\mathbf{E}_{\TyBool \to \TyBool}:{}\<[22]%
\>[22]{}\forall \Varid{e}\hsforall \hsdot{\circ }{.}\ExnTyArr{\ExnBool}{\Varid{e}}{\ExnBool}{\emptyset}\ \&\ \{\mathbf{E}\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    raises an exception when its closure is forced---as happens when it is applied to an argument, for example. As this function can never produce a result, it certainly cannot produce an exceptional value. So the result type is annotated with an empty exception set.
\end{example}

The exception set expressions $\Exn$ and their kinds $\Kind$ are an instance of the \mbox{$\LambdaUnion$-calculus}, where exception set expressions are terms and kinds are the types. As the constants we take the set of exception labels present in the program.
Two exception set expressions are considered equivalent if they are convertible as $\LambdaUnion$-terms, which is to say that they reduce to the same normal form.

The type system resembles \SystemFw \cite{Girard1972} in that we have quantification, abstraction and application at the type level. A key difference is that abstraction and application are restricted to the effects ($\ClassExn$) and cannot be used in the types ($\ClassExnTy$) directly.
Quantification, on the other hand, is restricted to the types, where it ranges over effects, and is not allowed to appear in the effect itself. The types thus remain predicative.

\subsection{Subtyping}

Exception types are endowed with the usual subtyping relation for type-and-effect systems. The function type is contravariant in its first argument for both the type and the effect. The subeffecting relation $\JudgeSubExn{\KiEnv}{\Exn_1}{\Exn_2}$ is the subsumption relation $\JudgeLuSub{\LuTm_1}{\LuTm_2}$ from the $\LambdaUnion$-calculus (Definition~\ref{definition-subsumption}).

%\begin{figure}[h]
    \begin{gather*}
        \Rule{S-Refl}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy}}
        \quad
        \Rule{S-Trans}
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_2}
              \quad
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_3}
             }
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_3}}
        \\[1.5ex]
        \Rule{S-Forall}
             {\JudgeSubTy{\KiEnv, \ExnVar :: \Kind}{\ExnTy_1}{\ExnTy_2}}
             {\JudgeSubTy{\KiEnv}
                         {\ExnForall{\ExnVar :: \Kind}{\ExnTy_1}}
                         {\ExnForall{\ExnVar :: \Kind}{\ExnTy_2}}
             }
        \quad
        \Rule{S-List}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy^\prime}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn}{\Exn^\prime}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyList{\ExnTy}{\Exn}}
                         {\ExnTyList{\ExnTy^\prime}{\Exn^\prime}}
             }
        \\[1.5ex]
        %\Rule{S-Bool}
        %     {}
        %     {\JudgeSubTy{\KiEnv}{\ExnBool}{\ExnBool}}
        %\quad
        %\Rule{S-Int}
        %     {}
        %     {\JudgeSubTy{\KiEnv}{\ExnInt}{\ExnInt}}
        %\\[1.5ex]
        \Rule{S-Arr}
             {\begin{gathered}
              \JudgeSubTy{\KiEnv}{\ExnTy_1^\prime}{\ExnTy_1}
                \ \ 
              \JudgeSubExn{\KiEnv}{\Exn_1^\prime}{\Exn_1}
                \ \ 
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_2^\prime}
                \ \ 
              \JudgeSubExn{\KiEnv}{\Exn_2}{\Exn_2^\prime}
              \end{gathered}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}
                         {\ExnTyArr{\ExnTy_1^\prime}{\Exn_1^\prime}{\ExnTy_2^\prime}{\Exn_2^\prime}}
             }
    \end{gather*}
%\caption{Exception types: subtyping relation ($\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_2}$)}\label{figure-subtyping}
%\end{figure}

\subsection{Conservative types}

Any program that is typeable in the underlying type system should also have an exception type: the exception type system is a \emph{conservative extension} of the underlying type system. Like type systems for strictness or control flow analysis---and unlike type systems for information flow security or dimensional analysis---we do not want to reject any program that is well-typed in the underlying type system, but merely provide more insight into its behavior.

If we furthermore want the type system to be modular---allowing type checking and inference to work on individual modules instead of whole programs---we cannot and need not make any assumptions about the exception types of the arguments that are applied to any function, as the function may be called from outside the module with an argument that also comes from outside the module and which we cannot know anything about.

For base and compound types that stand in an argument position their effect and any nested annotations must thus be able to be instantiated to any arbitrary exception set expression. They must therefore be exception set variables that have been universally quantified.

These observations lead to the following definition of \emph{conservative exception types}:\footnote{\cite{HoldermansHage} call pattern types \emph{fully parametric} and conservative types \emph{fully flexible}.}

\begin{definition}
An exception set expression $\Exn$ is \emph{simple} if it is a single exception set variable $\ExnVar$, an exception set expression is a \emph{pattern} if it fits Definition~\ref{definition-pattern}, and any exception set expression is \emph{conservative}.

We lift these three judgments to exception types $\ExnTy$ in the following manner:

    \begin{itemize}
    
        \item If $\ExnTy = \ExnBool$ or $\ExnTy = \ExnInt$, then $\ExnTy$ is simple, a pattern and conservative.
        
        \item If $\ExnTy = [\Throws{\ExnTy^\prime}{\Exn}]$, then $\ExnTy$ is simple, a pattern or conservative if $\ExnTy^\prime$ and $\Exn$ are respectively simple, patterns  or conservative.
        
        \item If $\ExnTy = \forall \overline{\ExnVar_i :: \kappa_i}.\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}$, then $\ExnTy$ is both simple and a pattern if $\ExnTy_1$ and $\Exn_1$ are simple and $\ExnTy_2$ and $\Exn_2$ are patterns; and $\ExnTy$ is conservative if $\ExnTy_1$ and $\Exn_1$ are simple and $\ExnTy_2$ and $\Exn_2$ are conservative.
    
    \end{itemize}
\end{definition}

\begin{example} The function \ensuremath{\Varid{tail}} can be applied to any list, but may produce an additional exceptional value \ensuremath{\mathbf{E}}, because it is partial:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{tail}:\forall \Varid{e}_{\mathrm{1}}\hsforall \;\Varid{e}_{\mathrm{2}}\hsdot{\circ }{.}\ExnTyArr{\ExnTyList{\ExnBool}{\Varid{e}_{\mathrm{1}}}}{\Varid{e}_{\mathrm{2}}}{\ExnTyList{\ExnBool}{\Varid{e}_{\mathrm{1}}}}{\Varid{e}_{\mathrm{2}}\cup \{\mathbf{E}\}}\ \&\ \emptyset{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The type and effect of the argument are simple, while the type and effect of the result are conservative, making the whole type conservative.

The conjunction operator \ensuremath{\mathrel{\wedge}} can be applied to any two booleans, and---operators being strict in both arguments---will propagate any exceptional values:
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\land {}\<[11]%
\>[11]{}:\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\ExnTyArr{\ExnBool}{\Varid{e}_{\mathrm{1}}}{(\forall \Varid{e}_{\mathrm{2}}\hsforall \hsdot{\circ }{.}\ExnTyArr{\ExnBool}{\Varid{e}_{\mathrm{2}}}{\ExnBool}{\Varid{e}_{\mathrm{1}}\cup \Varid{e}_{\mathrm{2}}})}{\emptyset}\ \&\ \emptyset{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
Here both arguments have simple types and effects.
\end{example}

For function types that stand in an argument position (the functional parameters of a higher-order function) the situation is slightly more complicated. For the argument of this function we can inductively assume that this is a universally quantified exception set variable. The result of this function, however, is some exception set expression that depends on the exception set variables that were quantified over in the argument. We cannot simply introduce a new exception set variable here, but must introduce a Skolem function that depends on each of the universally quantified exception set variables.

\begin{example} Consider the higher-order function \ensuremath{\Varid{apply}} that applies its first argument to the second.
% apply : A e2:E. A e3:E=>E.
%           (A e1:E. bool<e1> --<e2>-> bool<e3 e2>) ->
%               A e4:E. bool<e4> -> bool<e2 + e3 e4>
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}c<{\hspost}@{}}%
\column{12E}{@{}l@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\Varid{apply}{}\<[12]%
\>[12]{}:{}\<[12E]%
\>[17]{}\forall \Varid{e}_{\mathrm{2}}\hsforall ::\KindEXN\hsdot{\circ }{.}\forall \Varid{e}_{\mathrm{3}}\hsforall ::\KindEXN\Rightarrow \KindEXN\hsdot{\circ }{.}{}\<[E]%
\\
\>[17]{}\hsindent{2}{}\<[19]%
\>[19]{}(\forall \Varid{e}_{\mathrm{1}}\hsforall ::\KindEXN\hsdot{\circ }{.}\ExnTyArr{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\ExnBool}{\Varid{e}_{\mathrm{3}}\;\Varid{e}_{\mathrm{1}}})\langle\Varid{e}_{\mathrm{2}}\rangle\rightarrow\;{}\<[E]%
\\
\>[19]{}\hsindent{2}{}\<[21]%
\>[21]{}(\forall \Varid{e}_{\mathrm{4}}\hsforall ::\KindEXN\hsdot{\circ }{.}\ExnTyArr{\ExnBool}{\Varid{e}_{\mathrm{4}}}{\ExnBool}{\Varid{e}_{\mathrm{2}}\cup \Varid{e}_{\mathrm{3}}\;\Varid{e}_{\mathrm{4}}})\langle\ExnEmpty \rangle{}\<[E]%
\\
\>[12]{}\ \&\ {}\<[12E]%
\>[17]{}\ExnEmpty {}\<[E]%
\\
\>[5]{}\Varid{apply}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[15]{}\lambda\Varid{f}.\lambda\Varid{x}.\Varid{f}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The first (functional) argument of \ensuremath{\Varid{apply}} has exception type \ensuremath{\forall \Varid{e}_{\mathrm{1}}\hsforall ::\KindEXN\hsdot{\circ }{.}\ExnTyArr{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\ExnBool}{\Varid{e}_{\mathrm{3}}\;\Varid{e}_{\mathrm{1}}}} and effect \ensuremath{\Varid{e}_{\mathrm{2}}}. It can be instantiated with any function that accepts an argument annotated with any exception set effect, and produces a result annotated with some exception set effect depending on the exception set effect of the argument; the function closure itself may raise any exception. All functions of underlying type \ensuremath{\TyBool\to \TyBool} satisfy these constraints, so we are not really constrained at all.

As \ensuremath{\Varid{e}_{\mathrm{1}}} has been quantified over, only the exception set operator~\ensuremath{\Varid{e}_{\mathrm{3}}} and the effect \ensuremath{\Varid{e}_{\mathrm{2}}} are left free. We quantify over them outside the outer function space constructor, allowing them to appear in the annotation \ensuremath{\Varid{e}_{\mathrm{2}}\cup \Varid{e}_{\mathrm{3}}\;\Varid{e}_{\mathrm{4}}} on the result. The exception set operator \ensuremath{\Varid{e}_{\mathrm{3}}} is now applied to \ensuremath{\Varid{e}_{\mathrm{4}}}, as the term-level application \ensuremath{\Varid{f}\;\Varid{x}} instantiates the quantified exception set variable \ensuremath{\Varid{e}_{\mathrm{1}}} to \ensuremath{\Varid{e}_{\mathrm{4}}}.

(Note that the exception annotation $e_2$ on the closure---unlike the exception set operator $e_3$ on the result---does not depend on the exception variable $e_1$, the annotation on the argument. As a closure is already a value, it being exceptional or not can never depend on the argument it is later applied to.)
\end{example}

\begin{example}
    The semantics of terms in the source language is not invariant under $\eta$-conversion in the presence of exceptional values---thus neither are exception types. The term
    \savecolumns
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\lambda\Varid{x}:\TyBool.\TmCrash{\TyBool\to\TyBool}{\ExnLblE}\;\Varid{x}{}\<[42]%
\>[42]{}:\forall \Varid{e}\hsforall ::\KindEXN\hsdot{\circ }{.}\ExnTyArrT{\ExnBool}{\Varid{e}}{\ExnBool}{\{\mathbf{E}\}}{\emptyset}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    does not have the same exception type as the $\eta$-equivalent term
    \restorecolumns
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\TmCrash{\TyBool\to\TyBool}{\ExnLblE}{}\<[42]%
\>[42]{}:\forall \Varid{e}\hsforall ::\KindEXN\hsdot{\circ }{.}\ExnTyArrT{\ExnBool}{\Varid{e}}{\ExnBool}{\emptyset}{\{\mathbf{E}\}}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    They cannot be distinguished by applying them to an argument
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{44}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}(\lambda\Varid{x}:\TyBool.\TmCrash{\TyBool\to\TyBool}{\ExnLblE}\;\Varid{x})\;{}\<[44]%
\>[44]{}\mathbf{true}{}\<[50]%
\>[50]{}:\ExnBool\ \&\ \{\mathbf{E}\}{}\<[E]%
\\
\>[9]{}\TmCrash{\TyBool\to\TyBool}{\ExnLblE}\;{}\<[44]%
\>[44]{}\mathbf{true}{}\<[50]%
\>[50]{}:\ExnBool\ \&\ \{\mathbf{E}\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    but they can be distinguished by forcing the closure
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{44}{@{}>{\hspre}l<{\hspost}@{}}%
\column{49}{@{}>{\hspre}l<{\hspost}@{}}%
\column{55}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}(\lambda\Varid{x}:\TyBool.\TmCrash{\TyBool\to\TyBool}{\ExnLblE}\;\Varid{x})\;{}\<[44]%
\>[44]{}\mathbf{seq}\;{}\<[49]%
\>[49]{}\mathbf{true}{}\<[55]%
\>[55]{}:\ExnBool\ \&\ \emptyset{}\<[E]%
\\
\>[9]{}\TmCrash{\TyBool\to\TyBool}{\ExnLblE}\;{}\<[44]%
\>[44]{}\mathbf{seq}\;{}\<[49]%
\>[49]{}\mathbf{true}{}\<[55]%
\>[55]{}:\ExnBool\ \&\ \{\mathbf{E}\}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{example}

\subsection{Exception type completion}

Given an underlying type $\Ty$ we can compute the most general exception type $\ExnTy$ that erases to $\Ty$. This is done using the type completion system below, that defines a type completion relation $\JudgeComplete{\KindENV}{\Ty}{\ExnTy}{\Exn}{\KindENV'}$.

    \begin{gather*}
        \Rule{C-Bool}
             {}
             {\JudgeComplete{\KindEnv{i}}
                            {\TyBool}
                            {\ExnBool}
                            {\ExnVar\ \overline{\ExnVar_i}}
                            {\ExnVar :: \overline{\Kind_i\KindArr}\KindEXN}
             }
        \VER
        \Rule{C-Int}
             {}
             {\JudgeComplete{\KindEnv{i}}
                            {\TyInt}
                            {\ExnInt}
                            {\ExnVar\ \overline{\ExnVar_i}}
                            {\ExnVar :: \overline{\Kind_i\KindArr}\KindEXN}
             }
        \VER
        \Rule{C-List}
             {\JudgeComplete{\KindEnv{i}}
                            {\Ty}
                            {\ExnTy}
                            {\Exn}
                            {\KindEnv{j}}
             }
             {\JudgeComplete{\KindEnv{i}}
                            {\TyList{\Ty}}
                            {\ExnTyList{\ExnTy}{\Exn}}
                            {\ExnVar\ \overline{\ExnVar_i}}
                            {\ExnVar :: \overline{\Kind_i\KindArr}%
                                \KindEXN, \KindEnv{j}}
             }
        \VER
        \Rule{C-Arr}
             {\JudgeComplete{}
                            {\Ty_1}
                            {\ExnTy_1}
                            {\Exn_1}
                            {\KindEnv{j}}
              \quad\quad\quad\quad
              \JudgeComplete{\KindEnv{i},\KindEnv{j}}
                            {\Ty_2}
                            {\ExnTy_2}
                            {\Exn_2}
                            {\KindEnv{k}}
             }
             {\JudgeComplete{\KindEnv{i}}
                            {\TyArr{\Ty_1}{\Ty_2}}
                            {\ExnForall{\overline{\ExnVar_j :: \Kind_j}}\left(\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}\right)}
                            {\ExnVar\ \overline{\ExnVar_i}}
                            {\ExnVar :: \overline{\Kind_i\KindArr}%
                                \KindEXN, \KindEnv{k}}
             }
        \VER
    \end{gather*}


A judgment $\JudgeComplete{\KindEnv{i}}{\Ty}{\ExnTy}{\Exn}{\KindEnv{j}}$ is read: if the kinded exception set variables $\KindEnv{i}$ are in scope, then the underlying type $\Ty$ is completed to the exception type $\ExnTy$ and effect $\Exn$, while introducing the kinded free exception set variables $\KindEnv{j}$.
A completed exception type is always a pattern type.

\begin{example} The higher-order underlying type \[ \TyArr{\TyList{\TyArr{\TyBool}{\TyBool}}}{\TyArr{\TyList{\TyBool}}{\TyList{\TyBool}}} \] is completed to the pattern type
    \begin{align*}
        &    {\ExnTyForall{\ExnVar_2}{\KindEXN}{\ExnTyForall{\ExnVar_2^\prime}{\KindEXN}{\ExnTyForall{\ExnVar_3}{\KindEXN\KindArr\KindEXN}{}}}} \\
        & \quad \Throws{[\ExnTyForall{\ExnVar_1}{\KindEXN}{\Throws{\ExnBool}{\ExnVar_1}\xrightarrow{\ExnVar_2^\prime}\Throws{\ExnBool}{\ExnVar_3\ \ExnVar_1}}]}{\ExnVar_2} \to \\
        & \quad\quad (\ExnTyForall{\ExnVar_5}{\KindEXN}{\ExnTyForall{\ExnVar_5^\prime}{\KindEXN}{\Throws{[\Throws{\ExnBool}{\ExnVar_5^\prime}]}{\ExnVar_5}}} \xrightarrow{\ExnVar_6\ \ExnVar_2\ \ExnVar_2^\prime\ \ExnVar_3} \\
        & \quad\quad\quad\quad\quad\quad \Throws{\ExnTyList{\ExnBool}{\ExnVar_7^\prime\ \ExnVar_2\ \ExnVar_2^\prime\ \ExnVar_3\ \ExnVar_5\ \ExnVar_5^\prime}}{\ExnVar_7\ \ExnVar_2\ \ExnVar_2^\prime\ \ExnVar_3\ \ExnVar_5\ \ExnVar_5^\prime})
    \end{align*}
    with effect $\ExnVar_4$, and while introducing the free \ThesisPaper{exception set}{} variables
    \begin{align*}
        \ExnVar_4  &:: \KindEXN, \\
        \ExnVar_6 &:: \KindEXN\KindArr\KindEXN\KindArr(\KindEXN\KindArr\KindEXN)\KindArr\KindEXN, \\
        \ExnVar_7, \ExnVar_7^\prime &:: \KindEXN\KindArr\KindEXN\KindArr(\KindEXN\KindArr\KindEXN)\KindArr\KindEXN\KindArr\KindEXN\KindArr\KindEXN
    \end{align*}

Note that the types of both arguments are simple types with simple exception annotations. However, as the first argument is a functional argument, the result type of that function is still a pattern.

The exception annotation on the right-most function-space constructor is a pattern that depends on $\ExnVar_2$, $\ExnVar_2^\prime$ and $\ExnVar_3$. While we previously noted that the annotation on a function-space constructor cannot depend on the annotation belonging to the argument of that function, it is possible for a set of exceptional values that the closure may come to depend on any previous arguments of the whole function. This is more concretely demonstrated by the following function:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}c<{\hspost}@{}}%
\column{12E}{@{}l@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\Varid{f}{}\<[12]%
\>[12]{}::{}\<[12E]%
\>[15]{}\ExnTyForall{\ExnVar_1,\ExnVar_2}{\KindEXN}{\Throws{\ExnBool}{\ExnVar_1}\xrightarrow{\ExnEmpty}\Throws{\ExnBool}{\ExnVar_2}\xrightarrow{\ExnVar_1}\Throws{\ExnBool}{\ExnVar_2}}{}\<[E]%
\\
\>[9]{}\Varid{f}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[15]{}\lambda x : \TyBool . x\ \mathbf{seq}\ \lambda y : \TyBool. y{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\end{example}
Whether the closure that is returned after partially applying \ensuremath{\Varid{f}} to one argument is an exceptional value or not, depends on that argument \ensuremath{\Varid{x}} being exceptional or not.

\subsection{Least exception types}

Besides completing an underlying type $\Ty$ to a most general exception type, we also want to compute a least exception type~$\bot_\Ty$.
Given an effect kind $\overline{\kappa_i\Rightarrow}\KindEXN$, denote by $\emptyset_{\overline{\kappa_i\Rightarrow}\KindEXN}$ the effect $\lambda \overline{e_i :: \kappa_i}. \emptyset$.
We can construct a least exception type by first completing the type $\Ty$ to the most general exception type, and then substituting $\emptyset_{\kappa_j}$ for all free freshly introduced exception set variables $\KindEnv{j}$.

\begin{example} The least exception type \[ \bot_{\TyArr{\TyList{\TyArr{\TyBool}{\TyBool}}}{\TyArr{\TyList{\TyBool}}{\TyList{\TyBool}}}} \] is the conservative type
    \begin{align*}
        &    {\ExnTyForall{\ExnVar_2}{\KindEXN}{\ExnTyForall{\ExnVar_2^\prime}{\KindEXN}{\ExnTyForall{\ExnVar_3}{\KindEXN\KindArr\KindEXN}{}}}} \\
        & \quad \Throws{[\ExnTyForall{\ExnVar_1}{\KindEXN}{\Throws{\ExnBool}{\ExnVar_1}\xrightarrow{\ExnVar_2^\prime}\Throws{\ExnBool}{\ExnVar_3\ \ExnVar_1}}]}{\ExnVar_2} \to \\
        & \quad\quad (\ExnTyForall{\ExnVar_5}{\KindEXN}{\ExnTyForall{\ExnVar_5^\prime}{\KindEXN}{\Throws{[\Throws{\ExnBool}{\ExnVar_5^\prime}]}{\ExnVar_5}}} \xrightarrow{\ExnEmpty} \Throws{\ExnTyList{\ExnBool}{\ExnEmpty}}{\ExnEmpty})
    \end{align*}
\end{example}

\begin{figure*}[p]
    \begin{gather*}
        \Rule{T-Var}
             {}
             {\JudgeExnTy{\TyEnv, \TmVar : \ExnTy\ \&\ \Exn}
                         {\KiEnv}
                         {\TmVar}
                         {\ExnTy}
                         {\Exn}
             }
        \VER
        \Rule{T-Con}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCon{\Ty}}
                         {\BottomTy{\Ty}}
                         {\ExnEmpty}
             }
        \HOR
        \Rule{T-Crash}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCrash{\Ty}{\ExnLbl}}
                         {\BottomTy{\Ty}}
                         {\ExnCon{\ExnLbl}}
             }
        \VER
        \Rule{T-Abs}
             {\JudgeExnTy{\TyEnv, \TmVar : \ExnTy_1\ \&\ \Exn_1}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy_2}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAbsExn{\TmVar}{\ExnTy_1}{\Exn_1}{\Tm}}
                         {\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}
                         {\ExnEmpty}
             }
        \VER
        \Rule{T-AnnAbs}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv, \ExnVar :: \Kind}
                         {\Tm}
                         {\ExnTy}
                         {\Exn}
              \quad
              \ExnVar \notin \fv{\TyEnv,\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAnnAbs{\ExnVar}{\Kind}{\Tm}}
                         {\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}
                         {\Exn}
             }
        \VER
        \Rule{T-App}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTyArr{\ExnTy_2}{\Exn_2}{\ExnTy}{\Exn}}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy_2}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmApp{\Tm_1}{\Tm_2}}
                         {\ExnTy}
                         {\Exn}
             }
        \VER
        \Rule{T-AnnApp}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}
                         {\Exn}
              \quad
              \JudgeExn{\KiEnv}
                       {\Exn_2}
                       {\Kind}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAnnApp{\Tm_1}{\Exn_2}}
                         {\Subst{\Exn_2}{\ExnVar}{\ExnTy}}
                         {\Exn}
             }
        \VER
        \Rule{T-Fix}
             {\begin{gathered}
              \JudgeExnTy{\TyEnv,\TmVar:\ExnTy\ \&\ \Exn}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy}
                         {\Exn}
              \end{gathered}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmFixExn{\TmVar}{\ExnTy}{\Exn}{\Tm}}
                         {\ExnTy}
                         {\Exn}
             }
        \VER
        \Rule{T-Op}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnInt}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnInt}
                         {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmOp{\Tm_1}{\Tm_2}}
                         {\ExnBool}
                         {\Exn}
             }
        \VER
        \Rule{T-Seq}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTy_1}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy_2}
                         {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmSeq{\Tm_1}{\Tm_2}}
                         {\ExnTy_2}
                         {\Exn}
             }
        \VER
        \Rule{T-If}
             {\begin{gathered}
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnBool}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_3}
                         {\ExnTy}
                         {\Exn}
              \end{gathered}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                         {\ExnTy}
                         {\Exn}
             }             
        \VER
        \Rule{T-Nil}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmNil{\Ty}}
                         {\ExnTyList{\BottomTy{\Ty}}{\ExnEmpty}}
                         {\ExnEmpty}
             }
        \VER
        \Rule{T-Cons}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTy}
                         {\Exn_1}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTyList{\ExnTy}{\Exn_1}}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCons{\Tm_1}{\Tm_2}}
                         {\ExnTyList{\ExnTy}{\Exn_1}}
                         {\Exn_2}
             }
        \VER
        \Rule{T-Case}
             {\begin{gathered}
                  \JudgeExnTy{\TyEnv}
                             {\KiEnv}
                             {\Tm_1}
                             {\ExnTyList{\ExnTy_1}{\Exn_1}}
                             {\Exn^\prime}
                  \quad
                  \JudgeExnTy{\TyEnv}
                             {\KiEnv}
                             {\Tm_2}
                             {\ExnTy}
                             {\Exn}
                  \\
                  \JudgeExnTy{\TyEnv, \TmVar_1 : \ExnTy_1\ \&\ \Exn_1, \TmVar_2 : \ExnTyList{\ExnTy_1}{\Exn_1}\ \&\ \Exn^\prime}
                             {\KiEnv}
                             {\Tm_3}
                             {\ExnTy}
                             {\Exn}
                    \quad
                    \JudgeSubExn{\KiEnv}{\Exn^\prime}{\Exn}
              \end{gathered}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                         {\ExnTy}
                         {\Exn}
             }
        \VER
        \Rule{T-Sub}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy^\prime}
                         {\Exn^\prime}
              \quad
              \JudgeSubTy{\KiEnv}
                         {\ExnTy^\prime}
                         {\ExnTy}
              \quad
              \JudgeSubExn{\KiEnv}
                          {\Exn^\prime}
                          {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy}
                         {\Exn}
             }
    \end{gather*}
    \caption{Declarative type system ($\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$)}\label{figure-declarative-type-system}
\end{figure*}

\begin{figure*}[p]
    \begin{gather*}
        \Rule{L-Var}
             {}
             {\JudgeElab{\TyEnv, \TmVar : \ExnTy\ \&\ \Exn}
                        {\KiEnv}
                        {\TmVar}
                        {\TmVar}
                        {\ExnTy}
                        {\Exn}
             }
        \VER
        \Rule{L-Con}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCon{\Ty}}
                        {\TmCon{\Ty}}
                        {\BottomTy{\Ty}}
                        {\ExnEmpty}
             }
        \HOR
        \Rule{L-Crash}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCrash{\Ty}{\ExnLbl}}
                        {\TmCrash{\Ty}{\ExnLbl}}
                        {\BottomTy{\Ty}}
                        {\ExnCon{\ExnLbl}}
             }
        \VER
        \Rule{L-Abs}
             {\begin{gathered}
                \JudgeTyElab{\KiEnv, \overline{\ExnVar_i :: \Kind_i}}
                            {\ExnTy_1}
                            {\Ty_1}
                \quad
                \JudgeKind{\KiEnv, \overline{\ExnVar_i :: \Kind_i}}
                          {\Exn_1}
                          {\KindEXN}
                \\
                \JudgeElab{\TyEnv, x : \ExnTy_1\ \&\ \Exn_1}
                          {\KiEnv, \overline{\ExnVar_i :: \Kind_i}}
                          {\Tm}
                          {\Tm^\prime}
                          {\ExnTy_2}
                          {\Exn_2}
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmAbs{\TmVar}{\Ty_1}{\Tm}}
                        {\TmAnnAbsS{\ExnVar_i}{\Kind_i}{\TmAbsExn{\TmVar}{\ExnTy_1}{\Exn_1}{\Tm^\prime}}}
                        {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}}
                        {\ExnEmpty}
             }
        \VER
        \Rule{L-App}
             {\begin{gathered}
                \JudgeSubTy{\KiEnv}
                           {\ExnTy_2}
                           {\SubstS{\ExnAlt_i}{\ExnVar_i}{\ExnTy_1}}
                \quad
                \JudgeSubExn{\KiEnv}
                            {\Exn_2}
                            {\SubstS{\ExnAlt_i}{\ExnVar_i}{\Exn_1}}
                \quad
                \overline{
                    \JudgeKind{\KiEnv}
                              {\ExnAlt_i}
                              {\Kind_i}
                }
                \\
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm_1}
                          {\Tm_1^\prime}
                          {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy}{\Exn}}}
                          {\Exn^\prime}
                \quad
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm_2}
                          {\Tm_2^\prime}
                          {\ExnTy_2}
                          {\Exn_2}
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmApp{\Tm_1}{\Tm_2}}
                        {\TmApp{\TmAnnApp{\Tm_1^\prime}{\overline{\ExnAlt_i}}}{\Tm_2^\prime}}
                        {\SubstS{\ExnAlt_i}{\ExnVar_i}{\ExnTy}}
                        {\ExnUnion{\SubstS{\ExnAlt_i}{\ExnVar_i}{\Exn}}{\Exn^\prime}}
             }
        \VER
        \Rule{L-Fix}
             {\begin{gathered}
                \JudgeTyElab{\KiEnv}
                            {\ExnTy}
                            {\Ty}
                \quad
                \JudgeKind{\KiEnv}
                          {\Exn}
                          {\KindEXN}
                \quad
                \JudgeSubTy{\KiEnv}
                           {\ExnTy^\prime}
                           {\ExnTy}
                \quad
                \JudgeSubExn{\KiEnv}
                            {\Exn^\prime}
                            {\Exn}
                \\
                \JudgeElab{\TyEnv,x:\ExnTy\ \&\ \Exn}
                          {\KiEnv}
                          {\Tm}
                          {\Tm^\prime}
                          {\ExnTy^\prime}
                          {\Exn^\prime}
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmFIX{x}{\Ty}{\Tm}}
                        {\TmFixExn{x}{\ExnTy}{\Exn}{\Tm^\prime}}
                        {\ExnTy}
                        {\Exn}
             }
        \VER
        \Rule{L-Op}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnInt}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnInt}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmOp{\Tm_1}{\Tm_2}}
                        {\TmOp{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnBool}
                        {\ExnUnion{\Exn_1}{\Exn_2}}
             }
        \VER
        \Rule{L-Seq}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnTy_1}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTy_2}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmSeq{\Tm_1}{\Tm_2}}
                        {\TmSeq{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnTy_2}
                        {\ExnUnion{\Exn_1}{\Exn_2}}
             }
        \VER
        \Rule{L-If}
             {\begin{gathered}
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_1}
                            {\Tm_1^\prime}
                            {\ExnBool}
                            {\Exn_1}
                  \\
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_2}
                            {\Tm_2^\prime}
                            {\ExnTy_2}
                            {\Exn_2}
                  \quad
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_3}
                            {\Tm_3^\prime}
                            {\ExnTy_3}
                            {\Exn_3}
             \end{gathered}}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                        {\TmIf{\Tm_1^\prime}{\Tm_2^\prime}{\Tm_3^\prime}}
                        {\TyJoin{\ExnTy_2}{\ExnTy_3}}
                        {\ExnUnion{\Exn_1}{\ExnUnion{\Exn_2}{\Exn_3}}}
             }             
        \VER
        \Rule{L-Nil}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmNil{\Ty}}
                        {\TmNil{\Ty}}
                        {\ExnTyList{\BottomTy{\Ty}}{\ExnEmpty}}
                        {\ExnEmpty}
             }
        \VER
        \Rule{L-Cons}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnTy_1}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTyList{\ExnTy_1^\prime}{\Exn_1^\prime}}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCons{\Tm_1}{\Tm_2}}
                        {\TmCons{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnTyList{\TyJoin{\ExnTy_1}{\ExnTy_1^\prime}}{\ExnUnion{\Exn_1}{\Exn_1^\prime}}}
                        {\Exn_2}
             }
        \VER
        \Rule{L-Case}
             {\begin{gathered}
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_1}
                            {\Tm_1^\prime}
                            {\ExnTyList{\ExnTy_1}{\Exn_1}}
                            {\Exn_1^\prime}
                  \quad
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_2}
                            {\Tm_2^\prime}
                            {\ExnTy_2}
                            {\Exn_2}
                  \\
                  \JudgeElab{\TyEnv, \TmVar_1 : \ExnTy_1\ \&\ \Exn_1, \TmVar_2 : \ExnTyList{\ExnTy_1}{\Exn_1}\ \&\ \Exn_1^\prime}
                            {\KiEnv}
                            {\Tm_3}
                            {\Tm_3^\prime}
                            {\ExnTy_3}
                            {\Exn_3}
              \end{gathered}
             }
             {\begin{multlined}
                  \JudgeElabM{\TyEnv}
                             {\KiEnv}                 
                             {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                             {\TmCase{\Tm_1^\prime}{\Tm_2^\prime}{\TmVar_1}{\TmVar_2}{\Tm_3^\prime}}
                             {\TyJoin{\ExnTy_2}{\ExnTy_3}}
                             {\ExnUnion{\Exn_1^\prime}{\ExnUnion{\Exn_2}{\Exn_3}}}
              \end{multlined}
             }
    \end{gather*}
    \caption{Syntax-directed type elaboration system ($\JudgeElab{\TyEnv}{\KiEnv}{\Tm}{\Tm^\prime}{\ExnTy}{\Exn}$)}\label{type-elaboration-system}
\end{figure*}

\subsection{Exception typing and elaboration}

In Figure~\ref{figure-declarative-type-system} we give a declarative system for deriving exception typing judgments $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$.

These judgments work on an explicitly typed language and for this purpose we extend the terms of the source language with two new term-level constructs: effect abstraction and effect application.

%\begin{figure}[h]
\paragraph{Terms}
\begin{alignat}{2}
\!  \Tm \in \ClassExnTm &\ ::=\   &&\ ...                            \notag       \\
                        &\quad|  &&\ \TmAbs{\TmVar}{\ExnTy\ \&\ \Exn}{\Tm} \tag{term abstraction} \\
                        &\quad|  &&\ \TmFixExn{\TmVar}{\ExnTy}{\Exn}{\Tm} \tag{general recursion} \\
                        &\quad|  &&\ ...                            \notag       \\
                        &\quad|  &&\ \TmAnnAbs{\ExnVar}{\Kind}{\Tm} \tag{effect abstraction}  \\
                        &\quad|  &&\ \TmAnnApp{\Tm}{\Exn}           \tag{effect application}
\end{alignat}
%\caption{Source language: extended syntax}\label{figure-source-language-syntax-extended}
%\end{figure}

As the source language is not explicitly typed, we also give a type elaboration system that given an implicitly typed term in the source language produces an explicitly typed term (Figure~\ref{type-elaboration-system}).

The auxiliary judgment $\JudgeTyElab{\KiEnv}{\ExnTy}{\Ty}$ holds for any exception type $\ExnTy$ that erases to the underlying type $\Ty$. The type $\ExnTy_1 \sqcup \ExnTy_2$ is an exception type such that $\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_1 \sqcup \ExnTy_2}$ and $\JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_1 \sqcup \ExnTy_2}$.

\subsection{Presentation of exception types}

For most-general conservative exception types the location of the quantifiers is uniquely determined, we can therefore omit them from the type without introducing ambiguity. For example, the exception type of the \ensuremath{\Varid{map}} function from the introduction may be presented as:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}(\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \Varid{e}_{\mathrm{3}}}\beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{1}} \rangle)\to [\mskip1.5mu \alpha\langle \Varid{e}_{\mathrm{4}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle\to [\mskip1.5mu \beta\langle \Varid{e}_{\mathrm{2}}\;\Varid{e}_{\mathrm{4}}\cup \Varid{e}_{\mathrm{3}} \rangle\mskip1.5mu]\langle \Varid{e}_{\mathrm{5}} \rangle{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

\section{Type inference}\label{section-type-inference-algorithm}

















%In this section we give an inference algorithm for the exception types presented in the previous section.
A type inference algorithm is given in Figure~\ref{figure-type-inference-algorithm}.

\begin{figure}[p]
\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}c<{\hspost}@{}}%
\column{38E}{@{}l@{}}%
\column{41}{@{}>{\hspre}l<{\hspost}@{}}%
\column{42}{@{}>{\hspre}l<{\hspost}@{}}%
\column{45}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}c<{\hspost}@{}}%
\column{48E}{@{}l@{}}%
\column{51}{@{}>{\hspre}l<{\hspost}@{}}%
\column{58}{@{}>{\hspre}l<{\hspost}@{}}%
\column{64}{@{}>{\hspre}l<{\hspost}@{}}%
\column{73}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[5]{}\mathcal{R}:\ClassTyEnv\times \ClassKiEnv\times \ClassTm\to \ClassExnTm\times \ClassExnTy\times \ClassExn{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmVar){}\<[38]%
\>[38]{}\mathrel{=}{}\<[38E]%
\>[41]{}\Varid{x}:\TyEnv(x){}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; c_\Ty){}\<[38]%
\>[38]{}\mathrel{=}{}\<[38E]%
\>[41]{}c_\Ty : \BottomTy{\Ty}\ \&\ \ExnEmpty{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmCrash{\Ty}{\ExnLbl}){}\<[38]%
\>[38]{}\mathrel{=}{}\<[38E]%
\>[41]{}\TmCrash{\Ty}{\ExnLbl} : \BottomTy{\Ty}\ \&\ \ExnCon{\ExnLbl}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmAbs{\TmVar}{\Ty}{\Tm}){}\<[38]%
\>[38]{}\mathrel{=}{}\<[38E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;{}\<[17]%
\>[17]{}\ExnTy_1\ \&\ \Varid{e}\triangleright\overline{\ExnVar_i :: \Kind_i}{}\<[48]%
\>[48]{}\mathrel{=}{}\<[48E]%
\>[51]{}\mathcal{C}(\emptyset; \Ty){}\<[E]%
\\[\blanklineskip]%
\>[17]{}\Tm' : \ExnTy_2\ \&\ \Exn_2{}\<[48]%
\>[48]{}\mathrel{=}{}\<[48E]%
\>[51]{}\mathcal{R}(\TyEnv, \TmVar : \ExnTy_1\ \&\ \Varid{e}; \KiEnv,\overline{\ExnVar_i :: \Kind_i}; \Tm){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;{}\<[17]%
\>[17]{}\TmAnnAbsS{\ExnVar_i}{\Kind_i}{\TmAbsExn{\TmVar}{\ExnTy_1}{e}{\Tm^\prime}} : \ExnForall{\overline{\ExnVar_i :: \Kind_i}}{\ExnTyArr{\ExnTy_1}{\Varid{e}}{\ExnTy_2}{\Exn_2}}\ \&\ \ExnEmpty{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmApp{\Tm_1}{\Tm_2}){}\<[38]%
\>[38]{}\mathrel{=}{}\<[38E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;{}\<[17]%
\>[17]{}\Tm'_{\mathrm{1}} : \ExnTy_1\ \&\ \Exn_1{}\<[73]%
\>[73]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{1}}){}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{2}} : \ExnTy_2\ \&\ \Exn_2{}\<[73]%
\>[73]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{2}}){}\<[E]%
\\
\>[17]{}\ExnTyArr{\ExnTy_2^\prime}{\ExnVar_2^\prime}{\ExnTy^\prime}{\Exn^\prime}\triangleright \overline{\ExnVar_i :: \Kind_i}{}\<[73]%
\>[73]{}\mathrel{=}\mathcal{I}(\ExnTy_1){}\<[E]%
\\
\>[17]{}\theta{}\<[73]%
\>[73]{}\mathrel{=}\left[\ExnVar_2^\prime\mapsto \Exn_2\right]\hsdot{\circ }{.}\mathcal{M}(\emptyset; \ExnTy_2^\prime; \ExnTy_2){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;{}\<[17]%
\>[17]{}\TmApp{\TmAnnApp{\Tm_1^\prime}{\overline{\theta e_i}}}{\Tm_2^\prime} : \llfloor \theta \ExnTy^\prime\rrfloor_{\KiEnv}\ \&\ \llfloor \ExnUnion{\theta \Exn^\prime}{\Exn_1}\rrfloor_{\KiEnv}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmFIX{\TmVar}{\Ty}{\Tm})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{do}\;{}\<[17]%
\>[17]{}\Varid{i}; \ExnTy_0\ \&\ \Exn_0{}\<[42]%
\>[42]{}\leftarrow \mathrm{0}; \BottomTy{\Ty}\ \&\ \ExnEmpty{}\<[E]%
\\
\>[17]{}\mathbf{repeat}\;{}\<[25]%
\>[25]{}\Tm^\prime_{i+1} : \ExnTy_{i+1}\ \&\ \Exn_{i+1}{}\<[58]%
\>[58]{}\leftarrow \mathcal{R}(\TyEnv,\Varid{x}:\ExnTy_i\mathbin{\&}\Exn_i; \KiEnv; \Tm){}\<[E]%
\\
\>[25]{}\Varid{i}{}\<[58]%
\>[58]{}\leftarrow \Varid{i}\mathbin{+}\mathrm{1}{}\<[E]%
\\
\>[17]{}\mathbf{until}\;\ExnTy_i\ \&\ \Exn_i\equiv \ExnTy_{i-1}\ \&\ \Exn_{i-1}{}\<[E]%
\\
\>[17]{}\mathbf{return}\;\TmFixExn{\TmVar}{\ExnTy_i}{\Exn_i}{\Tm^\prime_i} : \ExnTy_i\ \&\ \Exn_i{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmSeq{\Tm_1}{\Tm_2})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;{}\<[17]%
\>[17]{}\Tm'_{\mathrm{1}} : \ExnTy_1\ \&\ \Exn_1{}\<[45]%
\>[45]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{1}}){}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{2}} : \ExnTy_2\ \&\ \Exn_2{}\<[45]%
\>[45]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{2}}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;{}\<[17]%
\>[17]{}\TmSeq{\Tm^\prime_1}{\Tm^\prime_2} : \ExnTy_2\ \&\ \llfloor \ExnUnion{\Exn_1}{\Exn_2}\rrfloor_{\KiEnv}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmOp{\Tm_1}{\Tm_2})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;{}\<[17]%
\>[17]{}\Tm'_{\mathrm{1}} : \ExnInt\ \&\ \Exn_1{}\<[46]%
\>[46]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{1}}){}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{2}} : \ExnInt\ \&\ \Exn_2{}\<[46]%
\>[46]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{2}}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;{}\<[17]%
\>[17]{}\TmOp{\Tm^\prime_1}{\Tm^\prime_2} : \ExnBool\ \&\ \llfloor \ExnUnion{\Exn_1}{\Exn_2}\rrfloor_{\KiEnv}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmIf{\Tm_1}{\Tm_2}{\Tm_3})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;{}\<[17]%
\>[17]{}\Tm'_{\mathrm{1}} : \ExnBool\ \&\ \Exn_1{}\<[47]%
\>[47]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{1}}){}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{2}} : \ExnTy_2\ \&\ \Exn_2{}\<[47]%
\>[47]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{2}}){}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{3}} : \ExnTy_3\ \&\ \Exn_3{}\<[47]%
\>[47]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{3}}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;{}\<[17]%
\>[17]{}\TmIf{\Tm^\prime_1}{\Tm^\prime_2}{\Tm^\prime_3} : \llfloor \TyJoin{\ExnTy_2}{\ExnTy_3}\rrfloor_{\KiEnv}\ \&\ \llfloor \ExnUnion{\Exn_1}{\ExnUnion{\Exn_2}{\Exn_3}}\rrfloor_{\KiEnv}{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmNil{\Ty}){}\<[38]%
\>[38]{}\mathrel{=}{}\<[38E]%
\>[41]{}\TmNil{\Ty} : \ExnTyList{\BottomTy{\Ty}}{\ExnEmpty}\ \&\ \ExnEmpty{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmCons{\Tm_1}{\Tm_2})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;{}\<[17]%
\>[17]{}\Tm'_{\mathrm{1}} : \ExnTy_1\ \&\ \Exn_1{}\<[64]%
\>[64]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{1}}){}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{2}} : \ExnTyList{\ExnTy_2}{\Exn_2^\prime}\ \&\ \Exn_2{}\<[64]%
\>[64]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{2}}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;{}\<[17]%
\>[17]{}\Tm'_{\mathrm{1}}::\Tm'_{\mathrm{2}} : \llfloor \ExnTyList{(\TyJoin{\ExnTy_1}{\ExnTy_2})}{\ExnUnion{\Exn_1}{\Exn_2^\prime}}\rrfloor_{\KiEnv}\ \&\ \Exn_2{}\<[E]%
\\[\blanklineskip]%
\>[5]{}\mathcal{R}(\TyEnv; \KiEnv; \TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3})\mathrel{=}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;{}\<[17]%
\>[17]{}\Tm'_{\mathrm{1}} : \ExnTyList{\ExnTy_1}{\Exn_1^\prime}\ \&\ \Exn_1{}\<[64]%
\>[64]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{1}}){}\<[E]%
\\
\>[17]{}\TyEnv^\prime{}\<[64]%
\>[64]{}\mathrel{=}\TyEnv, \TmVar_{\mathrm{1}} : \ExnTy_1\ \&\ \Exn_1^\prime, \TmVar_{\mathrm{2}} : \ExnTyList{\ExnTy_1}{\Exn_1^\prime}\ \&\ \Exn_1{}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{2}} : \ExnTy_2\ \&\ \Exn_2{}\<[64]%
\>[64]{}\mathrel{=}\mathcal{R}(\TyEnv; \KiEnv; \Tm_{\mathrm{2}}){}\<[E]%
\\
\>[17]{}\Tm'_{\mathrm{3}} : \ExnTy_3\ \&\ \Exn_3{}\<[64]%
\>[64]{}\mathrel{=}\mathcal{R}(\TyEnv^\prime; \KiEnv; \Tm_{\mathrm{3}}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{in}\;{}\<[17]%
\>[17]{}\TmCase{\Tm^\prime_1}{\Tm^\prime_2}{\TmVar_1}{\TmVar_2}{\Tm^\prime_3} : {}\<[E]%
\\
\>[17]{}\hsindent{28}{}\<[45]%
\>[45]{}\llfloor \TyJoin{\ExnTy_2}{\ExnTy_3}\rrfloor_{\KiEnv}\ \&\ \llfloor \ExnUnion{\Exn_1}{\ExnUnion{\Exn_2}{\Exn_3}}\rrfloor_{\KiEnv}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
\caption{Type inference algorithm ($\mathcal{R}$)}\label{figure-type-inference-algorithm}
\end{figure}

\subsection{Polymorphic abstraction}
The cases for abstraction and application are handled similarly to the corresponding cases in \cite{HoldermansHage}.
%The cases for abstraction and application in Figure~\ref{figure-type-inference-algorithm} are handled similarly to the corresponding cases in \cite{HoldermansHage}.

In the case of abstractions, we first complete the type of the bound variable to a most general exception type using the procedure \ensuremath{\mathcal{C}:\ClassKiEnv\times \ClassTy\to \ClassExnTy\times \ClassExn\times \ClassKiEnv}. This procedure is a functional interpretation of the type completion relation $\JudgeComplete{\KindENV}{\Ty}{\ExnTy}{\Exn}{\KindENV'}$, where the first two arguments $\KindENV$ and $\Ty$ are taken to be the domain and the last three arguments $\ExnTy$, $\Exn$ and $\KindENV'$ are taken to be the range. Next, we infer the exception type of the body of the abstraction under the assumption that the bound variable has the just completed exception type-and-effect $\ExnTy_1\ \&\ \ExnVar_1$. Finally we quantify over all free variables $\overline{\ExnVar_i :: \Kind_i}$ introduced by completion.

In the case of applications, we instantiate ($\mathcal{I}$) all quantified variables of the exception type of $t_1$ with fresh exception variables. Next we use the auxiliary procedure $\mathcal{M}$ to find a matching substitution between the exception types of the formal and the actual parameters.

\begin{figure}[ht]
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{23}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{51}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\mathcal{M}:{}\<[19]%
\>[19]{}\ClassKiEnv\times \ClassExnTy\times \ClassExnTy\to \ClassSubst{}\<[E]%
\\
\>[9]{}\mathcal{M}({}\<[16]%
\>[16]{}\KindENV; {}\<[23]%
\>[23]{}\ExnBool; {}\<[37]%
\>[37]{}\ExnBool){}\<[51]%
\>[51]{}\mathrel{=}\emptyset{}\<[E]%
\\
\>[9]{}\mathcal{M}({}\<[16]%
\>[16]{}\KindENV; {}\<[23]%
\>[23]{}\ExnInt; {}\<[37]%
\>[37]{}\ExnInt){}\<[51]%
\>[51]{}\mathrel{=}\emptyset{}\<[E]%
\\
\>[9]{}\mathcal{M}({}\<[16]%
\>[16]{}\KindENV; {}\<[23]%
\>[23]{}\ExnTyList{\ExnTy^\prime}{\ExnPat}; {}\<[37]%
\>[37]{}\ExnTyList{\ExnTy}{\Exn}){}\<[E]%
\\
\>[23]{}\hsindent{2}{}\<[25]%
\>[25]{}\mathrel{=}\left[\Varid{e'}\mapsto \lambda \overline{e_i :: \KindENV_{e_i}}.\Exn\right]\hsdot{\circ }{.}\mathcal{M}(\KindENV; \ExnTy^\prime; \ExnTy){}\<[E]%
\\
\>[9]{}\mathcal{M}({}\<[16]%
\>[16]{}\KindENV; {}\<[23]%
\>[23]{}\ExnTyArr{\ExnTy_1}{\ExnVar}{\ExnTy_2^\prime}{\ExnPat}; {}\<[38]%
\>[38]{}\ExnTyArr{\ExnTy_1}{\ExnVar}{\ExnTy_2}{\Exn}){}\<[E]%
\\
\>[23]{}\hsindent{2}{}\<[25]%
\>[25]{}\mathrel{=}\left[\Varid{e'}\mapsto \lambda \overline{e_i :: \KindENV_{e_i}}.\Exn\right]\hsdot{\circ }{.}\mathcal{M}(\KindENV; \ExnTy_2^\prime; \ExnTy_2){}\<[E]%
\\
\>[9]{}\mathcal{M}({}\<[16]%
\>[16]{}\KindENV; {}\<[23]%
\>[23]{}\ExnTyForall{\ExnVar}{\Kind}{\ExnTy^\prime}; {}\<[37]%
\>[37]{}\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}){}\<[51]%
\>[51]{}\mathrel{=}\mathcal{M}(\KindENV,\Varid{e}::\Kind; \ExnTy^\prime; \ExnTy){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \caption{Exception type matching ($\mathcal{M}$)}\label{figure-matching}
\end{figure}

The interesting cases of exception type matching are the cases for list and function types, where we perform pattern unification on the exception annotations. The produced substitution $\theta$ covers all variables $\overline{\ExnVar_i :: \Kind_i}$ freshly introduced by the instantiation procedure~$\mathcal{I}$. Finally, we apply the substitution $\theta$ to the exception type~$\ExnTy^\prime$ and effect~$\Exn^\prime$ of the result of $t_1$.

\subsection{Polymorphic recursion}

The $\mathbf{fix}$-construct abstracts over a variable that is of an exception polymorphic type. The algorithm handles this case with a Kleene--Mycroft iteration---which we conjecture to always converge.\footnote{\cite{HoldermansHage} note that $\lambda$-bound polymorpism gives us $\mathbf{fix}$-bound polymorphism ``for free.'' We believe this statement to be overly optimistic. While the highly polymorphic nature of these types do effectively force us to also handle polymorphic recursion, the inference step is arguably as complicated as the case for polymorphic abstraction.}

\begin{example}[Dussart--Henglein--Mossin]
    Consider the term
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}c<{\hspost}@{}}%
\column{12E}{@{}l@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\Varid{f}{}\<[12]%
\>[12]{}:{}\<[12E]%
\>[16]{}\TyBool\to \TyBool\to \TyBool{}\<[E]%
\\
\>[9]{}\Varid{f}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[16]{}\mathbf{fix}\ \Varid{f'} : \TyBool\to \TyBool\to \TyBool. {}\<[E]%
\\
\>[16]{}\hsindent{5}{}\<[21]%
\>[21]{}\lambda\Varid{x}:\TyBool.\lambda\Varid{y}:\TyBool.\;\mathbf{if}\;\Varid{x}\;\mathbf{then}\;\mathbf{true}\;\mathbf{else}\;\Varid{f'}\;\Varid{y}\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    Algorithm $\mathcal{R}$ infers the exception type and elaborated term
%    \begin{code}
%        dhm  ::  forall e_1:EXN. ExnTyArrS ExnTyBool e_1 (forall e_2:EXN. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1 # e_2) ExnEmpty) ExnEmpty
%        dhm  =   FIX (f) (forall e_1:EXN. ExnTyArrS ExnTyBool e_1 (forall e_2:EXN. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1 # e_2) ExnEmpty) ExnEmpty)
%                    (LLAMBDA (e_1 : EXN) (LAMBDA (x :: ExnTyBool :&: e_1) (LLAMBDA (e_2 : EXN) (PLAMBDA (y :: ExnTyBool :&: e_2))))
%                        if x then True else f (Angled e_2) y (Angled e_1) x
%    \end{code}    
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}c<{\hspost}@{}}%
\column{12E}{@{}l@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\Varid{f}{}\<[12]%
\>[12]{}:{}\<[12E]%
\>[16]{}\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\ExnTyArrS{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\forall \Varid{e}_{\mathrm{2}}\hsforall \hsdot{\circ }{.}\ExnTyArrT{\ExnBool}{\Varid{e}_{\mathrm{2}}}{\ExnBool}{\Varid{e}_{\mathrm{1}}\cup \Varid{e}_{\mathrm{2}}}{\ExnEmpty}}{\ExnEmpty}{}\<[E]%
\\
\>[9]{}\Varid{f}{}\<[12]%
\>[12]{}\mathrel{=}{}\<[12E]%
\>[16]{}\mathbf{fix}\ \Varid{f'} : \forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\ExnTyArrS{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\forall \Varid{e}_{\mathrm{2}}\hsforall \hsdot{\circ }{.}\ExnTyArrT{\ExnBool}{\Varid{e}_{\mathrm{2}}}{\ExnBool}{\Varid{e}_{\mathrm{1}}\cup \Varid{e}_{\mathrm{2}}}{\ExnEmpty}}{\ExnEmpty}. {}\<[E]%
\\
\>[16]{}\hsindent{5}{}\<[21]%
\>[21]{}\Lambda\Varid{e}_{\mathrm{1}}::\KindEXN.\lambda\Varid{x}:\ExnBool\ \&\ \Varid{e}_{\mathrm{1}}.\Lambda\Varid{e}_{\mathrm{2}}::\KindEXN.\lambda\Varid{y}:\ExnBool\ \&\ \Varid{e}_{\mathrm{2}}.{}\<[E]%
\\
\>[21]{}\hsindent{4}{}\<[25]%
\>[25]{}\mathbf{if}\;\Varid{x}\;\mathbf{then}\;\mathbf{true}\;\mathbf{else}\;\Varid{f'}\;\langle \Varid{e}_{\mathrm{2}}\rangle\;\Varid{y}\;\langle \Varid{e}_{\mathrm{1}}\rangle\;\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    Let us convince ourselves that the elaborated term is type-correct. 
    \begin{align*}
        x &: \ExnBool\ \&\ e_1 \\
        y &: \ExnBool\ \&\ e_2 \\
        \TmTrue &: \ExnBool\ \&\ \emptyset \\
        f' \langle e_2\rangle\ y\ \langle e_1\rangle\ x &: \ExnBool\ \&\ e_2 \cup e_1
    \end{align*}
   Therefore, \[ \TmIf{x}{\TmTrue}{f' \langle e_2\rangle\ y\ \langle e_1\rangle\ x} : \ExnBool \sqcup \ExnBool\ \&\ e_1 \cup \emptyset \cup e_2 \cup e_1 \]
    By commutativity and idempotence of the union operator and the empty set being the unit, this reduces to
    \[ \TmIf{x}{\TmTrue}{f' \langle e_2\rangle\ y\ \langle e_1\rangle\ x} : \ExnBool\ \&\ e_1 \cup e_2 \]

    Type checking is easier than type inference, however. To infer the type of the recursive definition \ensuremath{\Varid{f}} we have to ``guess'' a type for it. How do we guess this type? We first try the least exception type $\bot_{\TyBool\to\TyBool\to\TyBool}$:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\ExnTyArrS{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\forall \Varid{e}_{\mathrm{2}}\hsforall \hsdot{\circ }{.}\ExnTyArrT{\ExnBool}{\Varid{e}_{\mathrm{2}}}{\ExnBool}{\ExnEmpty}{\ExnEmpty}}{\ExnEmpty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    If we continue inferring the type with this guess, then we end up with a larger type than the guess:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\ExnTyArrS{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\forall \Varid{e}_{\mathrm{2}}\hsforall \hsdot{\circ }{.}\ExnTyArrT{\ExnBool}{\Varid{e}_{\mathrm{2}}}{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\ExnEmpty}}{\ExnEmpty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    We try inferring the type again, but now start with this type as our guess instead of the least type. We end up with an even larger type:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\forall \Varid{e}_{\mathrm{1}}\hsforall \hsdot{\circ }{.}\ExnTyArrS{\ExnBool}{\Varid{e}_{\mathrm{1}}}{\forall \Varid{e}_{\mathrm{2}}\hsforall \hsdot{\circ }{.}\ExnTyArrT{\ExnBool}{\Varid{e}_{\mathrm{2}}}{\ExnBool}{\Varid{e}_{\mathrm{1}}\cup \Varid{e}_{\mathrm{2}}}{\ExnEmpty}}{\ExnEmpty}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    Finally, if we take this type as our guess, we obtain the same type and conclude we have reached a fixed point.
\end{example}

\ThesisPaper{TODOX{Example: Glynn, Stuckey, Sulzman}}{}

\subsection{Least upper bounds}

The remaining cases of the algorithm are all relatively straightforward. Several of the cases (\textbf{if-then-else}, \textbf{case-of} and the list-consing constructor) require the least upper bound of two exception types to be computed. The fact that exception types and annotations occurring in argument positions of function types are always simple makes this easy, as they must be equal up to $\alpha$-renaming \cite{HoldermansHage}. This allows us to treat those arguments invariantly instead of contravariantly, obviating the need to also compute greatest lower bounds of exception types and annotations.

\begin{figure}[ht]
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}c<{\hspost}@{}}%
\column{14E}{@{}l@{}}%
\column{18}{@{}>{\hspre}l<{\hspost}@{}}%
\column{53}{@{}>{\hspre}c<{\hspost}@{}}%
\column{53E}{@{}l@{}}%
\column{61}{@{}>{\hspre}l<{\hspost}@{}}%
\column{82}{@{}>{\hspre}l<{\hspost}@{}}%
\column{105}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\sqcup {}\<[14]%
\>[14]{}:{}\<[14E]%
\>[18]{}\ClassExnTy\times \ClassExnTy\to \ClassExnTy{}\<[E]%
\\
\>[9]{}\ExnBool{}\<[53]%
\>[53]{}\sqcup {}\<[53E]%
\>[61]{}\ExnBool{}\<[105]%
\>[105]{}\mathrel{=}\ExnBool{}\<[E]%
\\
\>[9]{}\ExnInt{}\<[53]%
\>[53]{}\sqcup {}\<[53E]%
\>[61]{}\ExnInt{}\<[105]%
\>[105]{}\mathrel{=}\ExnInt{}\<[E]%
\\
\>[9]{}\ExnTyList{\ExnTy}{\Exn}{}\<[53]%
\>[53]{}\sqcup {}\<[53E]%
\>[61]{}\ExnTyList{\ExnTy^\prime}{\Exn^\prime}{}\<[105]%
\>[105]{}\mathrel{=}\ExnTyList{(\ExnTy\sqcup \ExnTy^\prime)}{\ExnUnion{\Exn}{\Exn^\prime}}{}\<[E]%
\\
\>[9]{}\ExnTyArr{\ExnTy_1}{\Varid{e}}{\ExnTy_2}{\Exn}{}\<[53]%
\>[53]{}\sqcup {}\<[53E]%
\>[61]{}\ExnTyArr{\ExnTy_1}{\Varid{e}}{{}\<[82]%
\>[82]{}\ExnTy_2^\prime}{\Exn^\prime}{}\<[105]%
\>[105]{}\mathrel{=}\ExnTyArr{\ExnTy_1}{\Varid{e}}{(\ExnTy_2\sqcup \ExnTy_2^\prime)}{\Exn\cup \Exn^\prime}{}\<[E]%
\\
\>[9]{}\ExnForall{\Varid{e}::\Kind}{\ExnTy}{}\<[53]%
\>[53]{}\sqcup {}\<[53E]%
\>[61]{}\ExnForall{\Varid{e}::\Kind}{\ExnTy^\prime}{}\<[105]%
\>[105]{}\mathrel{=}\ExnForall{\Varid{e}::\Kind}{(\ExnTy\sqcup \ExnTy^\prime)}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
    \caption{Exception types: least upper bounds ($\sqcup$)}\label{figure-lub}
\end{figure}

\subsection{Complexity}
There are three aspects that affect the run-time complexity of the algorithm: the complexity of the underlying type system, reduction of the effects, and the fixpoint-iteration in the inference step of the $\mathbf{fix}$-construct.
We have a simply typed underlying type system, but if we would extend this to full Hindley--Milner, then it is possible for types to become exponentially larger than terms \cite{Mairson:1989:DMT:96709.96748,Kfoury:1990:MTD:101856.101870}. The effects are $\LambdaUnion$-terms, which contains the simply typed $\lambda$-calculus as a special case. Reduction of terms in the simply typed $\lambda$-calculus is non-elementary recursive \cite{stat79b}. It is also easy to find an artificial family of terms that requires at least a linear number of iterations to converge to a fixpoint. For these reasons we do not believe the algorithm to have an attractive theoretical bound on time-complexity.

Anecdotal evidence suggests that the practical time-complexity is acceptable, however. Hindley--Milner has almost linear complexity in non-pathological cases. Types do not grow larger than the terms. The same seems to hold for the effects. Reduction of effects takes a small number of steps, as does the convergence of the fixpoint-iteration.
In cases where the exception annotation does become too large, a widening rule could be applied.

\section{Related work}\label{section-related-work}

\subsection{Higher-ranked polymorphism in type-and-effect systems}

\paragraph{Effect polymorphism} For plain type systems, Hindley--Milner's \ensuremath{\mathbf{let}}-bound polymorphism generally provides a good compromise between expressiveness of the type system and complexity of the inference algorithm \cite{Hindley1969,Milner78atheory,Damas:1982:PTF:582153.582176}.
Type systems were extended with effects---including \ensuremath{\mathbf{let}}-bound effect-polymorphism---by \cite{Lucassen:1988:PES:73560.73564,Jouvelot:1991:ART:99583.99623}; and \cite{JFP:1457464,Talpin:1994:TED:191349.184660}.
In type-and-effect systems it has long been recognized that $\mathbf{fix}$-bound polymorphism (polymorphic recursion) \emph{in the effects} is often beneficial or even necessary for achieving precise analysis results. For example, in type-and-effect systems for regions \cite{Tofte:1994:ITC:174675.177855}, dimensions \cite{Kennedy:1994:DT:645390.651419,Rittri:1994:STT:194679.194683,Rittri:1995:DIU:224164.224197}, binding times \cite{Dussart:1995:PRS:647163.717680}, and exceptions \cite{Glynn:2002:EAN:581478.581488,Koot:2015:TEA:2678015.2682542}.

Inferring principal types in a type system with polymorphic recursion is equivalent to solving the undecidable semi-unification problem \cite{Mycroft1984,Kfoury:1990:USP:100216.100279,Kfoury:1993:TRP:169701.169687,Henglein:1993:TIP:169701.169692}.
When restricted to polymorphic recursion in the effects, the problem often becomes decidable again. In \cite{Tofte:1994:ITC:174675.177855} this is a conjecture based on empirical observation. \cite{Rittri:1995:DIU:224164.224197} gives a semi-unification procedure based on the general semi-unification semi-algorithm by \cite{Baaz93APTCC} and proves it terminates in the special case of semi-unification in Abelian groups. \cite{Dussart:1995:PRS:647163.717680} use a constraint-based algorithm. They show that all variables that do not occur free in the context or type can be eliminated from the constraint set by a constraint reduction step during each Kleene--Mycroft iteration. As at most $n^2$ subeffecting constraints can be formed over $n$ free variables, the whole procedure must terminate. By not restarting the Kleene--Mycroft iteration from bottom, their algorithm runs in polynomial time---even in the presence of nested fixpoints.

The extension to polymorphic effect-abstraction ($\lambda$-bound, higher-ranked effect polymorphism) remained less well-studied, possibly because it is of limited use without the simultaneous introduction of effect operators---in contrast to the situation of higher-ranked polymorphism in plain type systems.

\paragraph{Effect operators} \cite{KennedyThesis} presents a type system that ensures the dimensional consistency of an ML-like language extended with units of measure ($\mathrm{ML}_\delta$). This language has predicative prenex dimension polymorphism. Kennedy gives an Algorithm~$\mathcal{W}$-like type inference procedure that uses equational unification to deal with the Abelian group (\textsc{ag}) structure of dimension expressions. Also described are two explicitly typed variants of the language: a System F-like language with higher-ranked dimension polymorphism ($\Lambda_\delta$), and a System~$\mathrm{F}_\omega$-like language that extends $\Lambda_\delta$ with dimension operators ($\Lambda_{\delta\omega}$). \cite{KennedyThesis} notes that this language can type strictly more programs than the language without dimension operators:
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{21}{@{}>{\hspre}c<{\hspost}@{}}%
\column{21E}{@{}l@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{29}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\Varid{twice}{}\<[21]%
\>[21]{}:{}\<[21E]%
\>[25]{}\forall \Conid{F}\hsforall ::\KindDIM\Rightarrow \KindDIM\hsdot{\circ }{.}{}\<[E]%
\\
\>[25]{}\hsindent{4}{}\<[29]%
\>[29]{}(\forall \Varid{d}\hsforall ::\KindDIM\hsdot{\circ }{.}\TyReal{\Varid{d}}\to \TyReal{\Conid{F}\;\Varid{d}})\to {}\<[E]%
\\
\>[29]{}\hsindent{4}{}\<[33]%
\>[33]{}(\forall \Varid{d}\hsforall ::\KindDIM\hsdot{\circ }{.}\TyReal{\Varid{d}}\to \TyReal{\Conid{F}\;(\Conid{F}\;\Varid{d})}){}\<[E]%
\\
\>[9]{}\Varid{twice}{}\<[21]%
\>[21]{}\mathrel{=}{}\<[21E]%
\>[25]{}\Lambda\Conid{F}::\KindDIM\Rightarrow \KindDIM.{}\<[E]%
\\
\>[25]{}\hsindent{4}{}\<[29]%
\>[29]{}\lambda\Varid{f}:(\forall \Varid{d}\hsforall ::\KindDIM\hsdot{\circ }{.}\TyReal{\Varid{d}}\to \TyReal{\Conid{F}\;\Varid{d}}).{}\<[E]%
\\
\>[29]{}\hsindent{4}{}\<[33]%
\>[33]{}\Lambda\Varid{d}::\KindDIM.\lambda\Varid{x}:\TyReal{\Varid{d}}.\Varid{f}\;\langle \Conid{F}\;\Varid{d}\rangle\;(\Varid{f}\;\langle \Varid{d}\rangle\;\Varid{x}){}\<[E]%
\\[\blanklineskip]%
\>[9]{}\Varid{square}{}\<[21]%
\>[21]{}:{}\<[21E]%
\>[25]{}\forall \Varid{d}\hsforall ::\KindDIM\hsdot{\circ }{.}\TyReal{\Varid{d}}\to \TyReal{\Varid{d}^\mathrm{2}}{}\<[E]%
\\
\>[9]{}\Varid{square}{}\<[21]%
\>[21]{}\mathrel{=}{}\<[21E]%
\>[25]{}\Lambda\Varid{d}::\KindDIM.\lambda\Varid{x}:\TyReal{\Varid{d}}.\Varid{x}^\mathrm{2}{}\<[E]%
\\[\blanklineskip]%
\>[9]{}\Varid{fourth}{}\<[21]%
\>[21]{}:{}\<[21E]%
\>[25]{}\forall \Varid{d}\hsforall ::\KindDIM\hsdot{\circ }{.}\TyReal{\Varid{d}}\to \TyReal{\Varid{d}^\mathrm{4}}{}\<[E]%
\\
\>[9]{}\Varid{fourth}{}\<[21]%
\>[21]{}\mathrel{=}{}\<[21E]%
\>[25]{}\Varid{twice}\;\langle \Lambda\Varid{d}::\KindDIM.\Varid{d}^\mathrm{2}\rangle\;\Varid{square}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Without dimension operators the type of the higher-order function \ensuremath{\Varid{twice}} would not allow the application of the function \ensuremath{\Varid{square}} at the two distinct types \ensuremath{\forall \Varid{d}\hsforall ::\KindDIM\hsdot{\circ }{.}\TyReal{\Varid{d}}\to \TyReal{\Varid{d}^\mathrm{2}}} and \ensuremath{\forall \Varid{d}\hsforall ::\KindDIM\hsdot{\circ }{.}\TyReal{\Varid{d}^\mathrm{2}}\to \TyReal{\Varid{d}^\mathrm{4}}} when invoked from the function \ensuremath{\Varid{fourth}}.

The language $\Lambda_{\delta\omega}$ bears a striking resemblance to the language in Section~\ref{section-exception-types}: the empty and singleton exception sets constants, and the exception set union operator have been replaced with a unit dimension, and dimension product and inverse operators---as dimensions have an \textsc{ag} structure, whereas exception sets have an \ACIone structure; in the dimension type system the annotation is placed only on the real number base type instead of on the compound types, and there is no effect. No type inference algorithm is given for this language, however.

\cite{Faxen:1996:PPF:646912.710963} presents a type system for flow analysis that uses constrained type schemes in the style of \cite{Aiken:1993:TIC:165180.165188}, and has $\lambda$-bound polymorphism (but no type operators) in the style of System~F. To make the inference algorithm terminate for recursive programs the size of the name supply needs to be bounded, leading to imprecision. \cite{SmithWang} present a similar framework, but one that can be instantiated with variants of either $k$-\textsc{cfa} \cite{Shivers:1991:CAH:124950} or \textsc{cpa} \cite{Agesen:1995:CPA:646153.679533} to ensure termination.

\cite{HoldermansHage} design a \SystemFw-like type system for flow analysis for a strict language that has both polymorphic abstraction and effect operators. Our type inference algorithm builds on their techniques. A key difference is that they work with a constraint-based type system and a constraint solver, while we replace these with reduction of terms in an algebraic $\lambda$-calculus. This difference expresses itself particularly in how the case of (polymorphic) recursion is handled. We believe our approach will scale more easily to analyses that are either not conservative extensions of the underlying type system, or require more expressive effects (see Section~\ref{section-future-research}).

\subsection{$\LambdaUnion$-calculus}

\cite{DBLP:conf/lics/Breazu-Tannen88a}, \cite{Okada1989}, and \cite{BREAZUTANNEN19913} prove that if a simply typed $\lambda$-calculus is extended with a many-sorted algebraic rewrite system $R$ (by introducing the symbols of the algebraic theory as higher-order constants in the $\lambda$-calculus), then the combined rewrite system $\beta\eta R$ is confluent and strongly normalizing if $R$ is confluent and strongly normalizing.

\cite{Revesz:1992:LEL:131057.131060} introduced an untyped $\lambda$-calculus with applicative lists. A model is given by \cite{Durfee97amodel}. This calculus satisfies the equations
    \begin{align}
        \langle t_1, ..., t_n \rangle\ t^\prime &= \langle t_1\ t^\prime, ..., t_n\ t^\prime \rangle \tag{$\gamma_1$} \\
        \lambda x. \langle t_1, ... t_n \rangle &= \langle \lambda x. t_1, ..., \lambda x. t_n \rangle \tag{$\gamma_2$}
    \end{align}
similar to our typed $\LambdaUnion$-calculus.

\subsection{Exception analyses}

Several exception analyses have been described in the literature; these primarily target the detection of uncaught exceptions in ML.
The exception analysis by \cite{kyi} is based on abstract interpretation.
\cite{Guzman94anextended} and \cite{Fahndrich:1998:TDE:893957} describe type-based exception analyses. \cite{Leroy:2000:TAU:349214.349230} presents a row-based type system for exception analysis that contains a data-flow analysis component targeted towards tracking value-carrying exceptions.

\cite{Glynn:2002:EAN:581478.581488} developed the first exception analysis for a non-strict language; a type-based analysis using Boolean constraints. \cite{Koot:2015:TEA:2678015.2682542} present a constraint-based type system for exception analysis of a non-strict language, where the exception-flow could depend on the data-flow using conditional constraints. This increases the accuracy in the presence of exceptions raised by pattern-matching failures.
\section{Further research}\label{section-future-research}

%At least two opportunities for further research present itself:

\paragraph{Can we infer types for Kennedy's higher-ranked $\Lambda_{\delta\omega}$?} One problem that immediately presents itself is that this type system is not a conservative extension of the underlying type system: programs can be rejected because they, while being type correct in the underlying type system, may still be dimensionally inconsistent.
Unlike the system in this paper, the annotations on function arguments will no longer be of the simple form (patterns) required for the straightforward matching step in the type inference algorithm. Instead, we suspect we have to solve a higher-order equational (pre)unification problem, which is only semi-decidable.
\cite{Snyder:1990:HOE:648229.752474}, \cite{NipkowQian1991} and \cite{QIAN1996401} do give us semi-algorithms for solving such problems.
    
\paragraph{Can we further improve the precision of exception types?}
\cite{Koot:2015:TEA:2678015.2682542} argue
%It is argued by \cite{Koot:2015:TEA:2678015.2682542}
that an accurate exception typing system for non-strict languages should also take the data flow of the program into account, as many exceptions that can be raised in non-strict languages are caused by incomplete case-analyses during pattern-matching. The canonical example is the \ensuremath{\Varid{risers}} function---which splits a list into monotonically increasing subsegments; for example, \ensuremath{\Varid{risers}\;[\mskip1.5mu \mathrm{1},\mathrm{3},\mathrm{5},\mathrm{1},\mathrm{2}\mskip1.5mu]} evaluates to \ensuremath{[\mskip1.5mu [\mskip1.5mu \mathrm{1},\mathrm{3},\mathrm{5}\mskip1.5mu],[\mskip1.5mu \mathrm{1},\mathrm{2}\mskip1.5mu]\mskip1.5mu]}---by \cite{Mitchell:2008:PBE:1411286.1411293}:
    
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}c<{\hspost}@{}}%
\column{34E}{@{}l@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\Varid{risers}{}\<[17]%
\>[17]{}:[\mskip1.5mu \TyInt\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \TyInt\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[9]{}\Varid{risers}\;{}\<[17]%
\>[17]{}[\mskip1.5mu \mskip1.5mu]{}\<[34]%
\>[34]{}\mathrel{=}{}\<[34E]%
\>[37]{}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[9]{}\Varid{risers}\;{}\<[17]%
\>[17]{}[\mskip1.5mu \Varid{x}\mskip1.5mu]{}\<[34]%
\>[34]{}\mathrel{=}{}\<[34E]%
\>[37]{}[\mskip1.5mu [\mskip1.5mu \Varid{x}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[9]{}\Varid{risers}\;(\Varid{x}_{\mathrm{1}}::\Varid{x}_{\mathrm{2}}::\Varid{xs}){}\<[34]%
\>[34]{}\mathrel{=}{}\<[34E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\mathbf{if}\;\Varid{x}_{\mathrm{1}}\leq \Varid{x}_{\mathrm{2}}\;\mathbf{then}\;(\Varid{x}_{\mathrm{1}}::\Varid{y})::\Varid{ys}\;\mathbf{else}\;[\mskip1.5mu \Varid{x}_{\mathrm{1}}\mskip1.5mu]::(\Varid{y}::\Varid{ys}){}\<[E]%
\\
\>[13]{}\hsindent{4}{}\<[17]%
\>[17]{}\mathbf{where}\;(\Varid{y}::\Varid{ys})\mathrel{=}\Varid{risers}\;(\Varid{x}_{\mathrm{2}}::\Varid{xs}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks
The inference algorithm in Figure~\ref{figure-type-inference-algorithm} assigns \ensuremath{\Varid{risers}} the type
    % (∀e1::E.(∀e2::E.([int⟨e2⟩]⟨e1⟩→[[int⟨e2⟩]⟨∅⟩]⟨({risers}∪(e1∪e2))⟩))) & ∅    
    \begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[9]{}\forall \Varid{e}_{\mathrm{1}}\hsforall ::\KindEXN\hsdot{\circ }{.}\forall \Varid{e}_{\mathrm{2}}\hsforall ::\KindEXN\hsdot{\circ }{.}{}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\ExnTyArr{\ExnTyList{\ExnInt}{\Varid{e}_{\mathrm{2}}}}{\Varid{e}_{\mathrm{1}}}{\ExnTyList{\ExnTyList{\ExnInt}{\Varid{e}_{\mathrm{2}}}}{\ExnEmpty}}{\Varid{e}_{\mathrm{1}}\cup \Varid{e}_{\mathrm{2}}\cup \{\mathbf{E}\}}\ \&\ \emptyset{}\<[E]%
\ColumnHook
\end{hscode}\resethooks
where \ensuremath{\mathbf{E}} is the label of the exception raised when the pattern-match in the \ensuremath{\mathbf{where}}-clause fails.\footnote{This exception is left implicit in the above program, but becomes explicit when the code is desugared into our core language.} However, the pattern-match happens on the result of the recursive call \ensuremath{\Varid{risers}\;(\Varid{x}_{\mathrm{2}}::\Varid{xs})}. When \ensuremath{\Varid{risers}} is given a non-empty list (such as \ensuremath{\Varid{x}_{\mathrm{2}}::\Varid{xs}}) as an argument, it always returns a non-empty list as its result. The pattern-match can thus never fail, and the exception labelled \ensuremath{\mathbf{E}} can thus never be raised.

%In our previous work we demonstrated
\cite{Koot:2015:TEA:2678015.2682542} demonstrate
how this exception can be elided by having the exception flow depend on the data flow. The $\LambdaUnion$-calculus terms that form the effect annotations cannot express this dependence, however.
%In our earlier work we used
\cite{Koot:2015:TEA:2678015.2682542} use
a slightly ad hoc form of conditional constraints to model this dependence. We believe that extending a $\lambda$-calculus with an equational theory of Boolean rings may form the basis of a more principled approach. Boolean rings have already been successfully used to design type systems for strictness analysis \cite{Wright}, records \cite{LIX-RR-96-09} and exception tracking \cite{Benton:2007:SEA:1190315.1190320}.

\paragraph{Metatheory}
We have not yet worked out the metatheory of the type system presented in this paper. Of particular interest are the (syntactic) soundness, completeness and totality of the inference step for recursive definitions. We expect that soundness and completeness can be shown by a similar argument as in \cite{Mycroft1984} and \cite{Dussart:1995:PRS:647163.717680}.

We conjectured the totality of our inference algorithm. We have a good reason to do so: we only expect the fixpoint iteration to diverge if no fixpoint exists---that is to say, the program is type incorrect. Assuming the program is well-typed in the underlying type system, there are no type incorrect programs in our exception typing system, however.

To show the fixpoint iteration is guaranteed to terminate in their binding-time analysis, \cite{Dussart:1995:PRS:647163.717680} note that only a finite number of type constraints and therefore constrained type schemes can be formed over a finite number of variables (after constraints have been simplified). As it is still possible to form an infinite number of $\LambdaUnion$-normal forms over a finite number of variables, such an argument is not going to work directly.
\section{Conclusion}

We show that it is feasible to extend non-strict higher-order languages with exception-annotated types, as is already done in some strict first-order languages. We argue that higher-ranked exception polymorphic types with exception set operators \emph{\`a la} System~$F_\omega$ are not only more accurate, but are also more readable when presented to the programmer \emph{vis-\`a-vis} constrained type schemes: the exception terms in the annotations more closely mirror what is happening at the term level than constraint sets do.

\section*{Acknowledgements}
We would like to thank Jurriaan Hage and the members of the Software Technology reading club at Utrecht University for their comments on earlier drafts of this paper. Vincent van Oostrom and Femke van Raamsdonk provided some helpful pointers to related literature.

%\clearpage

%\bibliographystyle{plainnat}
\bibliographystyle{splncs03}
\renewcommand{\bibname}{}   %% LNCS HACK
\small                      %% LNCS HACK
\bibliography{higher-ranked-exception-types-neutered}

%BEGIN sigplanconf-template.tex

% We recommend abbrvnat bibliography style.
%\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright
%
%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...
%
%\end{thebibliography}

%END sigplanconf-template.tex


\clearpage

\appendix

\section{Prototype}

A prototype implementation of the inference algorithm is available from \url{https://www.staff.science.uu.nl/~0422819/hret/supplementary-material.tar.gz}.

\end{document}

\section{Metatheory}

\subsection{$\LambdaUnion$-calculus}

\begin{lemma}
    The terms $\LuApp{(\LuUnion{\LuTm_1}{\LuTm_2})}{\LuTm}$ and $\LuUnion{\LuApp{\LuTm_1}{\LuTm}}{\LuApp{\LuTm_2}{\LuTm}}$ are equivalent.
\end{lemma}
\begin{proof}
    \begin{align*}
        &\LuDen{\LuApp{(\LuUnion{\LuTm_1}{\LuTm_2})}{\LuTm}} \\
        &= \bigcup\left\{\varphi(\LuDen{\LuTm})\mid\varphi\in\LuDen{\LuUnion{\LuTm_1}{\LuTm_2}}\right\} \\
        &= \bigcup\left\{\varphi(\LuDen{\LuTm})\mid\varphi\in\LuDen{\LuTm_1}\cup\LuDen{\LuTm_2}\right\} \\
        &= \bigcup\left\{\varphi(\LuDen{\LuTm})\mid\varphi\in\LuDen{\LuTm_1}\right\} \cup \bigcup\left\{\varphi(\LuDen{\LuTm})\mid\varphi\in\LuDen{\LuTm_2}\right\} \\
        &= \LuDen{\LuApp{\LuTm_1}{\LuTm}} \cup \LuDen{\LuApp{\LuTm_2}{\LuTm}} \\
        &= \LuDen{\LuUnion{(\LuApp{\LuTm_1}{\LuTm})}{(\LuApp{\LuTm_2}{\LuTm})}} \qedhere
    \end{align*}
\end{proof}

\begin{lemma}
    The terms $\LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)}$ and $\LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}}$ are extensionally equivalent.
\end{lemma}
\begin{proof}
    We show that \[\llbracket \LuApp{\left(\LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)}\right)}{\LuTm_3} \rrbracket_\rho = \llbracket \LuApp{\left(\LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}}\right)}{\LuTm_3} \rrbracket_\rho \] for all suitable $\rho$ and $\LuTm_3$.
    \begin{align*}
        & \llbracket \LuApp{\left(\LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)}\right)}{\LuTm_3} \rrbracket_\rho \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \llbracket \LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)} \rrbracket_\rho \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \llbracket \LuAbs{\LuVar}{\LuTy}{\LuTm_1} \rrbracket_\rho \cup \llbracket \LuAbs{\LuVar}{\LuTy}{\LuTm_2} \rrbracket_\rho \right\} \\
        %&= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \left\{ \lambda v \in V_\tau. \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto v\right]}, \lambda v \in V_\tau. \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto v\right]}\right\} \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \left\{ \lambda v \in V_\tau. \llbracket \LuTm_i \rrbracket_{\rho\left[\LuVar \mapsto v\right]} \mid i \in \left\{1,2\right\} \right\} \right\} \\
        &= \bigcup \left\{ \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]}, \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \right\} \\
        &= \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \cup \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \\
        &= \bigcup \left\{ \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \cup \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \right\} \\
        &= \bigcup \left\{ \llbracket \LuUnion{\LuTm_1}{\LuTm_2} \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \left\{ \lambda v \in V_\tau. \llbracket \LuUnion{\LuTm_1}{\LuTm_2} \rrbracket_{\rho\left[\LuVar \mapsto v\right]} \right\} \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \llbracket \LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}} \rrbracket_\rho \right\} \\
        &= \llbracket \LuApp{\left(\LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}}\right)}{\LuTm_3} \rrbracket_\rho \qedhere
    \end{align*}
\end{proof}

\subsection{Declarative type system}

\begin{lemma}[Canonical forms]\label{thm-canonical-forms}\ 
    \begin{enumerate}
        \item If $\ExnVal$ is a possibly exceptional value of type $\ExnBool$, then $\ExnVal$ is either $\TmTrue$, $\TmFalse$, or~$\TmCrash{}{\ExnLbl}$.
        \item If $\ExnVal$ is a possibly exceptional value of type $\ExnInt$, then $\ExnVal$ is either some integer $n$, or an exceptional value $\TmCrash{}{\ExnLbl}$.
        \item If $\ExnVal$ is a possibly exceptional value of type $\ExnTyList{\ExnTy}{\Exn}$, then $\ExnVal$ is either $\TmNil{}$, $\TmCons{\Tm}{\Tm^\prime}$, or~$\TmCrash{}{\ExnLbl}$.
        \item If $\ExnVal$ is a possibly exceptional value of type $\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}$, then $\ExnVal$ is either $\TmAbsExn{x}{\ExnTy_1}{\Exn_1}{\Tm^\prime}$ or $\TmCrash{}{\ExnLbl}$.
        \item If $\ExnVal$ is a possibly exceptional value of type $\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}$, then $\ExnVal$ is $\TmAnnAbs{\ExnVar}{\Kind}{\Tm}$
    \end{enumerate}
\end{lemma}
\begin{proof}
    For each part, inspect all forms of $\ExnVal$ and discard the unwanted cases by inversion of the typing relation. Note that $\BottomTy{\Ty}$ cannot give us a type of the form $\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}$.
\end{proof}
\TODO: Say something about \CiteRule{T-Sub}?

\begin{theorem}[Progress]\label{thm-progress}
    If $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$ with $\Tm$ a closed term, then $\Tm$ is either a possibly exceptional value $\ExnVal$ or there is a closed term $\Tm^\prime$ such that $\JudgeEval{\Tm}{\Tm^\prime}$.
\end{theorem}
\begin{proof}
By induction on the typing derivation $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$.

    The case \CiteRule{T-Var} can be discarded, as a variable is not a closed term. The cases \CiteRule{T-Con}, \CiteRule{T-Crash}, \CiteRule{T-Abs}, \CiteRule{T-AnnAbs}, \CiteRule{T-Nil} and \CiteRule{T-Cons} are immediate as they are values.

    \CaseRule{T-App} We can immediately apply the induction hypothesis to $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm_1}{\ExnTyArr{\ExnTy_2}{\Exn_2}{\ExnTy}{\Exn}}{\Exn}$, giving us either a $\Tm_1^\prime$ such that $\JudgeEval{\Tm_1}{\Tm_1^\prime}$ or that $\Tm_1 = \ExnVal$. In the former case we can make progress using \CiteRule{E-App}. In the latter case the canonical forms lemma tells us that either $\Tm_1 = \TmAbsExn{x}{\ExnTy_2}{\Exn_2}{\Tm_1^\prime}$ or $\Tm_1 = \TmCrash{}{\ExnLbl}$, in which case we can make progress using \CiteRule{E-AppAbs} or \CiteRule{E-AppExn}, respectively.
    
    The remaining cases follow by analogous reasoning.
\end{proof}

\begin{figure}[ht]
    \begin{align*}
        \Subst{\Exn}{\ExnVar}{\ExnVar} &\equiv \Exn \\
        \Subst{\Exn}{\ExnVar}{\ExnVar^\prime} &\equiv \ExnVar^\prime &&\text{if $\ExnVar \neq \ExnVar^\prime$}\\
        \Subst{\Exn}{\ExnVar}{\ExnCon{\ExnLbl}} &\equiv \ExnCon{\ExnLbl} \\
        \Subst{\Exn}{\ExnVar}{\ExnEmpty} &\equiv \ExnEmpty \\
        \Subst{\Exn}{\ExnVar}{\left(\ExnAbs{\ExnVar^\prime}{\Kind}{\Exn^\prime}\right)} &\equiv \ExnAbs{\ExnVar^\prime}{\Kind}{\Subst{\Exn}{\ExnVar}{\Exn^\prime}} &&\text{if $\ExnVar \neq \ExnVar^\prime$ and $\ExnVar^\prime \notin \fv{\Exn}$}\\
        \Subst{\Exn}{\ExnVar}{\left(\ExnApp{\ExnVar_1}{\ExnVar_2}\right)} &\equiv \ExnApp{\left(\Subst{\Exn}{\ExnVar}{\ExnVar_1}\right)}{\left(\Subst{\Exn}{\ExnVar}{\ExnVar_2}\right)} \\
        \Subst{\Exn}{\ExnVar}{\left(\ExnUnion{\ExnVar_1}{\ExnVar_2}\right)} &\equiv \ExnUnion{\Subst{\Exn}{\ExnVar}{\ExnVar_1}}{\Subst{\Exn}{\ExnVar}{\ExnVar_2}}
    \end{align*}
    \caption{Annotation substitution}
\end{figure}

\begin{figure}[ht]
    \begin{align*}
        \Subst{\Tm}{x}{x} &\equiv \Tm \\
        \Subst{\Tm}{x}{x^\prime} &\equiv x^\prime &&\text{if $x \neq x^\prime$} \\
        \Subst{\Tm}{x}{\TmCon{\Ty}} &\equiv \TmCon{\Ty} \\
        \Subst{\Tm}{x}{\left(\TmAbs{x^\prime}{\ExnTy}{\Tm^\prime}\right)} &\equiv \TmAbs{x^\prime}{\ExnTy}{\Subst{\Tm}{x}{\Tm^\prime}} &&\text{if $x \neq x^\prime$ and $x^\prime \notin \fv{\Tm}$}\\
        & \dots
    \end{align*}
    \caption{Term substitution}
\end{figure}

\begin{lemma}[Annotation substitution]\label{thm-annotation-substitution}\ 
    \begin{enumerate}
        \item If $\JudgeExn{\KiEnv,\BindKi{\ExnVar}{\Kind^\prime}}{\Exn}{\Kind}$ and $\JudgeExn{\KiEnv}{\Exn^\prime}{\Kind^\prime}$ then $\JudgeExn{\KiEnv}{\Subst{\Exn^\prime}{\ExnVar}{\Exn}}{\Kind}$.
        \item If $\JudgeSubExn{\KiEnv,\BindKi{\ExnVar}{\Kind^\prime}}{\Exn_1}{\Exn_2}$ and $\JudgeKind{\KiEnv}{\Exn^\prime}{\Kind^\prime}$ then $\JudgeSubExn{\KiEnv}{\Subst{\Exn^\prime}{\ExnVar}{\Exn_1}}{\Subst{\Exn^\prime}{\ExnVar}{\Exn_2}}$.
        \item If $\JudgeSubTy{\KiEnv,\BindKi{\ExnVar}{\Kind^\prime}}{\ExnTy_1}{\ExnTy_2}$ and $\JudgeKind{\KiEnv}{\Exn^\prime}{\Kind^\prime}$ then $\JudgeSubExn{\KiEnv}{\Subst{\Exn^\prime}{\ExnVar}{\ExnTy_1}}{\Subst{\Exn^\prime}{\ExnVar}{\ExnTy_2}}$.
        \item If $\JudgeExnTy{\TyEnv}{\KiEnv,\BindKi{\ExnVar}{\Kind^\prime}}{\Tm}{\ExnTy}{\Exn}$ and $\JudgeExn{\KiEnv}{\Exn^\prime}{\Kind^\prime}$ then $\JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Exn^\prime}{\ExnVar}{\Tm}}{\Subst{\Exn^\prime}{\ExnVar}{\ExnTy}}{\Exn}$.
    \end{enumerate}
\end{lemma}

\TODO: In part 4, either we need the assumption $e \notin \fv{\Exn}$ (which seems to be satisfied everywhere we want to apply this lemma), or we also need to apply the substitution to $\Exn$ (is this expected or not in a type-and-effect system)? \CiteRule{T-Fix} seems to be to only rule where an exception variable can flow from $\ExnTy$ to $\Exn$.... 
\begin{proof}
1. By induction on the derivation of $\JudgeExn{\KiEnv,\BindKi{\ExnVar}{\Kind^\prime}}{\Exn}{\Kind}$.
The cases \CiteRule{A-Var}, \CiteRule{A-Abs} and \CiteRule{A-App} are analogous to the respective cases in the proof of term substitution below.
In the case \CiteRule{A-Con} one can strengthen the assumption $\JudgeExn{\KiEnv,\BindKi{\ExnVar}{\Kind^\prime}}{\ExnCon{\ExnLbl}}{\KindEXN}$ to $\JudgeExn{\KiEnv}{\ExnCon{\ExnLbl}}{\KindEXN}$ as $\ExnVar \notin \fv{\ExnCon{\ExnLbl}}$, the result is then immediate; similarly for \CiteRule{A-Empty}. The case \CiteRule{A-Union} goes analogous to \CiteRule{A-App}.

2. \TODO

3. \TODO

4. By induction on the derivation of $\JudgeExnTy{\TyEnv}{\KiEnv,\BindKi{\ExnVar}{\Kind^\prime}}{\Tm}{\ExnTy}{\Exn}$. Most cases can be discarded by a straightforward application of the induction hypothesis; we show only the interesting case.

    \def\currentprefix{annotation-substitution:T-AnnApp}
    \CaseRule{T-AnnApp} \TODO
    
\TODO

\end{proof}

\begin{lemma}[Term substitution]\label{thm-term-substitution}
If $\JudgeExnTy{\TyEnv,\BindTy{\TmVar}{\ExnTy^\prime}{\Exn^\prime}}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$ and $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm^\prime}{\ExnTy^\prime}{\Exn^\prime}$ then $\JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Tm^\prime}{\TmVar}{\Tm}}{\ExnTy}{\Exn}$.
\end{lemma}
\begin{proof}
By induction on the derivation of $\JudgeExnTy{\TyEnv,\BindTy{\TmVar}{\ExnTy^\prime}{\Exn}}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$.

    \def\currentprefix{term-substitution:T-App}
    \CaseRule{T-Var} We either have $\Tm = \TmVar$ or $\Tm = \TmVar^\prime$ with $\TmVar \neq \TmVar^\prime$.
    In the first case we need to show that $\JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Tm^\prime}{\TmVar}{\TmVar}}{\ExnTy}{\Exn}$, which by definition of substitution is equal to $\JudgeExnTy{\TyEnv}{\KiEnv}{\TmVar}{\ExnTy}{\Exn}$, but this is one of our assumptions.
    In the second case we need to show that $\JudgeExnTy{\TyEnv,\BindTy{\TmVar^\prime}{\ExnTy}{\Exn}}{\KiEnv}{\Subst{\Tm}{\TmVar}{\TmVar^\prime}}{\ExnTy}{\Exn}$, which by definition of substitution is equal to $\JudgeExnTy{\TyEnv,\BindTy{\TmVar^\prime}{\ExnTy}{\Exn}}{\KiEnv}{\TmVar^\prime}{\ExnTy}{\Exn}$. This follows immediately from \CiteRule{T-Var}.

    \def\currentprefix{term-substitution:T-Abs}
    \CaseRule{T-Abs} Our assumptions are
        \begin{align}
            & \JudgeExnTy{\TyEnv,\BindTy{x}{\ExnTy^\prime}{\Exn^\prime},\BindTy{y}{\ExnTy_1}{\Exn_1}}{\KiEnv}{\Tm}{\ExnTy_2}{\Exn_2} \labell{ass1} \\
            & \JudgeExnTy{\TyEnv}{\KiEnv}{\Tm^\prime}{\ExnTy^\prime}{\Exn^\prime}. \labell{ass2}
        \end{align}
    By the Barendregt convention we may assume that $y \neq x$ and $y \notin \fv{\Tm^\prime}$. We need to show that $\JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Tm^\prime}{x}{(\TmAbsExn{y}{\ExnTy_1}{\Exn_1}{\Tm})}}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}{\ExnEmpty}$, which by definition of substitution is equal to
        \begin{align}
            & \JudgeExnTy{\TyEnv}{\KiEnv}{\TmAbsExn{y}{\ExnTy_1}{\Exn_1}{\Subst{\Tm^\prime}{x}{\Tm}}}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}{\ExnEmpty}. \labell{ts}
        \end{align}
    We weaken \eqrefl{ass2} to $\JudgeExnTy{\TyEnv,\BindTy{y}{\ExnTy_1}{\Exn_1}}{\KiEnv}{\Tm^\prime}{\ExnTy^\prime}{\Exn^\prime}$ and apply the induction hypothesis on this and \eqrefl{ass1} to obtain
        \begin{align}
            & \JudgeExnTy{\TyEnv,\BindTy{y}{\ExnTy_1}{\Exn_1}}{\KiEnv}{\Subst{\Tm^\prime}{x}{\Tm}}{\ExnTy_2}{\Exn_2}. \labell{ih}
        \end{align}
    The desired result \eqrefl{ts} can be constructed from \eqrefl{ih} using \CiteRule{T-Abs}.

    \def\currentprefix{term-substitution:T-AnnAbs}
    \CaseRule{T-AnnAbs} Our assumptions are $\JudgeExnTy{\TyEnv,\BindTy{x}{\ExnTy^\prime}{\Exn^\prime}}{\KiEnv,\BindKi{\ExnVar}{\Kind}}{\Tm}{\ExnTy}{\Exn}$ and $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm^\prime}{\ExnTy^\prime}{\Exn^\prime}$.
    By the Barendregt convention we may assume that $\ExnVar \notin \fv{\Tm^\prime}$.
    We need to show that $\JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Tm^\prime}{x}{\left(\TmAnnAbs{\ExnVar}{\Kind}{\Tm}\right)}}{\ExnTy}{\Exn}$, which is equal to $\JudgeExnTy{\TyEnv}{\KiEnv}{\TmAnnAbs{\ExnVar}{\Kind}{\Subst{\Tm^\prime}{\Kind}{\Tm}}}{\ExnTy}{\Exn}$ by definition of substitution.
    By applying the induction hypothesis we obtain $\JudgeExnTy{\TyEnv}{\KiEnv,\BindKi{\ExnVar}{\Kind}}{\Subst{\Tm^\prime}{x}{\Tm}}{\ExnTy}{\Exn}$.
    The desired result can be constructed using \CiteRule{T-AnnAbs}.

    \def\currentprefix{term-substitution:T-App}
    \CaseRule{T-App} Our assumptions are
        \begin{align}
           & \JudgeExnTy{\TyEnv,\BindTy{x}{\ExnTy^\prime}{\Exn^\prime}}{\KiEnv}{\Tm_1}{\ExnTyArr{\ExnTy_2}{\Exn_2}{\ExnTy}{\Exn}}{\Exn} \labell{ass1} \\
           & \JudgeExnTy{\TyEnv,\BindTy{x}{\ExnTy^\prime}{\Exn^\prime}}{\KiEnv}{\Tm_2}{\ExnTy_2}{\Exn_2}. \labell{ass2}
        \end{align}
    We need to show that $\JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Tm^\prime}{x}{(\TmApp{\Tm_1}{\Tm_2})}}{\ExnTy}{\Exn}$, which by definition of substitution is equal to
        \begin{align}
            & \JudgeExnTy{\TyEnv}{\KiEnv}{\TmApp{\left(\Subst{\Tm^\prime}{x}{\Tm_1}\right)}{\left(\Subst{\Tm^\prime}{x}{\Tm_2}\right)}}{\ExnTy}{\Exn}. \labell{ts}
        \end{align}
    By applying the induction hypothesis to \eqrefl{ass1} respectively \eqrefl{ass2} we obtain
        \begin{align}
            & \JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Tm^\prime}{x}{\Tm_1}}{\ExnTyArr{\ExnTy_2}{\Exn_2}{\ExnTy}{\Exn}}{\Exn} \labell{ass1ih} \\
            & \JudgeExnTy{\TyEnv}{\KiEnv}{\Subst{\Tm^\prime}{x}{\Tm_2}}{\ExnTy_2}{\Exn_2}. \labell{ass2ih}
        \end{align}
    The desired result \eqrefl{ts} can be constructed by applying \CiteRule{T-App} to \eqrefl{ass1ih} and \eqrefl{ass2ih}.
    
    All other cases are either immediate or analogous to the case of \CiteRule{T-App}.
\end{proof}

\begin{lemma}[Inversion]\label{thm-inversion}\ 
    \begin{enumerate}
        \item If $\JudgeExnTy{\TyEnv}{\KiEnv}{\TmAbsExn{x}{\ExnTy}{\Exn}{\Tm}}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}{\Exn_3}$, then
            \begin{itemize}
                \item $\JudgeExnTy{\TyEnv,\BindTy{x}{\ExnTy}{\Exn}}{\KiEnv}{\Tm}{\ExnTy^\prime}{\Exn^\prime}$,
                \item $\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy}$ and $\JudgeSubExn{\KiEnv}{\Exn_1}{\Exn}$,
                \item $\JudgeSubTy{\KiEnv}{\ExnTy^\prime}{\ExnTy_2}$ and $\JudgeSubExn{\KiEnv}{\Exn^\prime}{\Exn_2}$.
            \end{itemize}
        \item If $\JudgeExnTy{\TyEnv}{\KiEnv}{\TmAnnAbs{\ExnVar}{\Kind}{\Tm}}{\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}{\Exn}$, then
            \begin{itemize}
                \item $\JudgeExnTy{\TyEnv}{\KiEnv,\BindKi{\ExnVar}{\Kind}}{\Tm}{\ExnTy^\prime}{\Exn^\prime}$,
                \item $\JudgeSubTy{\KiEnv,\BindKi{\ExnVar}{\Kind}}{\ExnTy^\prime}{\ExnTy}$,
                \item $\JudgeSubExn{\KiEnv}{\Exn^\prime}{\Exn}$.
                \item \TODO\ $e \notin \fv{\Exn}$ and/or $e \notin \fv{\Exn^\prime}$.
            \end{itemize}
    \end{enumerate}
\end{lemma}
\begin{proof}
1. By induction on the typing derivation.

    \CaseRule{T-Abs} We have $\ExnTy = \ExnTy_1$, $\Exn = \Exn_1$ and take $\ExnTy^\prime = \ExnTy_2$, $\Exn^\prime = \Exn_2$, the result then follows immediately from the assumption $\JudgeExnTy{\TyEnv,\BindTy{x}{\ExnTy}{\Exn}}{\KiEnv}{\Tm}{\ExnTy_2}{\Exn_2}$ and reflexivity of the subtyping and subeffecting relations.
    
    \def\currentprefix{inversion:T-Sub}
    \CaseRule{T-Sub} We are given the additional assumptions
        \begin{align}
            & \JudgeExnTy{\TyEnv}{\KiEnv}{\TmAbsExn{x}{\ExnTy}{\Exn}{\Tm}}{\ExnTyArr{\ExnTy_1^\prime}{\Exn_1^\prime}{\ExnTy_2^\prime}{\Exn_2^\prime}}{\Exn_3^\prime}, \labell{ass1} \\
            & \JudgeSubExn{\KiEnv}{\ExnTyArr{\ExnTy_1^\prime}{\Exn_1^\prime}{\ExnTy_2^\prime}{\Exn_2^\prime}}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}, \labell{ass2}\\
            & \JudgeSubExn{\KiEnv}{\Exn_3^\prime}{\Exn_3}.
        \end{align}
    Applying the induction hypothesis to \eqrefl{ass1} gives us
        \begin{align}
            & \JudgeExnTy{\TyEnv,\BindTy{x}{\ExnTy}{\Exn}}{\KiEnv}{\Tm}{\ExnTy_2^{\prime\prime}}{\Exn_2^{\prime\prime}}, \labell{ih1}\\
            & \JudgeSubTy{\KiEnv}{\ExnTy_1^\prime}{\ExnTy}, \quad \JudgeSubExn{\KiEnv}{\Exn_1^\prime}{\Exn}, \labell{ih2}\\
            & \JudgeSubTy{\KiEnv}{\ExnTy_2^{\prime\prime}}{\ExnTy_2^\prime}, \quad \JudgeSubExn{\KiEnv}{\Exn_2^{\prime\prime}}{\Exn_2^\prime}. \labell{ih3}
        \end{align}
    Inversion of the subtyping relation on \eqrefl{ass2} gives us
        \begin{align}
            & \JudgeSubTy{\KiEnv}{\ExnTy_1^\prime}{\ExnTy}, \quad \JudgeSubExn{\KiEnv}{\Exn_1^\prime}{\Exn}, \labell{inv1}\\
            & \JudgeSubTy{\KiEnv}{\ExnTy_2^{\prime\prime}}{\ExnTy_2^\prime}, \quad \JudgeSubExn{\KiEnv}{\Exn_2^{\prime\prime}}{\Exn_2^\prime}. \labell{inv2}
        \end{align}
    The result follows from \eqrefl{ih1} and combining \eqrefl{inv1} with \eqrefl{ih2} and \eqrefl{ih3} with \eqrefl{inv2} using the transitivity of the subtyping and subeffecting relations.

2. By induction on the typing derivation.

    \CaseRule{T-AnnAbs} We need to show that $\JudgeExnTy{\TyEnv}{\KiEnv,\BindKi{\ExnVar}{\Kind}}{\Tm}{\ExnTy}{\Exn}$, which is one of our assumptions, and that $\JudgeSubTy{\KiEnv,\BindKi{\ExnVar}{\Kind}}{\ExnTy}{\ExnTy}$ and $\JudgeSubExn{\KiEnv}{\Exn}{\Exn}$; this follows from the reflexivity of the subtyping, respectively subeffecting, relation (noting that $\ExnVar \notin \fv{\Exn}$).
    
    \CaseRule{T-Sub} Similar to the case \CiteRule{T-Sub} in part 1.

\end{proof}

\begin{theorem}[Preservation]\label{thm-preservation}
    If $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$ and $\JudgeEval{\Tm}{\Tm^\prime}$, then $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm^\prime}{\ExnTy}{\Exn}$.
\end{theorem}
\begin{proof}
    By induction on the typing derivation $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$.

    The cases for \CiteRule{T-Var}, \CiteRule{T-Con}, \CiteRule{T-Crash}, \CiteRule{T-Abs}, \CiteRule{T-AnnAbs}, \CiteRule{T-Nil}, and \CiteRule{T-Cons} can be discarded immediately, as they have no applicable evaluation rules.

    \TODO
\end{proof}

\subsection{Syntax-directed type elaboration}

\subsection{Type inference algorithm}

\begin{theorem}[Syntactic soundness]\label{thm-syntactic-soundness}
    If $\Reconstruct\ \TyEnv\ \KiEnv\ \Tm = \langle \ExnTy; \Exn \rangle$, then $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$.
\end{theorem}
\begin{proof}
    By induction on the term $\Tm$.
    
    \TODO
\end{proof}

\begin{theorem}[Termination]\label{thm-termination}
    $\Reconstruct\ \TyEnv\ \KiEnv\ \Tm$ terminates.
\end{theorem}
\begin{proof}
    By induction on the term $\Tm$.
    
    \TODO
\end{proof}

\clearpage

\section{TODO}

\begin{itemize}

    \item naming and ordering of quantified exception set variables in the examples is inconsistent.
    
    \item notation of type signatures in the examples is inconsisten.

    \item standard polyrec examples (DHM + GSM)
    
    \item polyrec does not ``come for free''
    
    \item type inference: we have a fixpoint a la DHM
    
    \item widening
    
    \item ``algebraic'' effects?
    
    \item unexpected decidablity
    
    \item ack: Vincent + Femke; Andrew + Jeremy + Stephanie + Andres; ST-RC
    
    \item check wiki and folder for notes
    
    \item exception type of twice (and other h-o funs)
    
    \item no slanted-greek for lambda and Lambda
    
    \item typeset System $F_\omega$ correctly
    
    \item roll Metatheory into earlier sections, add new section Analysis (also add to Overview)
    
    \item Untracked exceptions can break information flow security.
    
    \item Elaborte in the subsection ``Contributions''. Mention prototype?
    
    \item : vs ::
    
    \item add function composition as an additional example

\end{itemize}

\subsection*{Abstract}

    \begin{itemize}

        \item title: Higher-order effect types
    
    \end{itemize}

\subsection{Introduction}

    \begin{itemize}
    
        \item In the final example (map (const undefined)) no non-exceptional values will be \emph{actually} present in the resulting list
    
        \item Why not \ensuremath{\alpha\langle \Varid{e}_{\mathrm{1}} \rangle\xrightarrow{ \Varid{e}_{\mathrm{3}}}\beta\langle \Varid{e}_{\mathrm{2}} \rangle}?! Give some examples why higher-rankedness is needed. The example on the poster/\ensuremath{\Varid{map}} isn't sufficient. Postpone to a later section?
        
        \item Need an example that clearly demonstrates why HRP is \emph{needed} (May be difficult without also constructing a complete subtyping-based analysis?)

    \end{itemize}
    
\subsection{The $\LambdaUnion$-calculus}

    \begin{itemize}
    
        \item \TODOX{We can make union only work on base types (as we not longer \emph{need} to distribute unions over applications)? Only need during widening, now...}

        \item \TODOX{Prove more Lemmas about reduction rules (esp. $\gamma_1$)}
        
        \item Add reduction rules for $\emptyset$ and idempotence to the Figure. (Do wee need the bars above the rules?)
    
        \item Prove semantics is ACI1. We have a different unit for each type!
        \item $\mathcal{P}(V_{\tau_1} \to V_{\tau_2}) \simeq V_{\tau_1} \to \mathcal{P}(V_{\tau_2})$? Cardinallity suggests not: $2^{(\beta^\alpha)} \neq (2^\beta)^\alpha$.
        \item If we don't distribute unions over applications, can we ever get them deep inside terms?
        \item If we don't \emph{and} the outermost lambdas are not there because is always of kind star, can we get non-trivial terms? I.e. something other than $e_1(e_{11},...,e_{1n_1}) \cup \cdots \cup e_k(e_{k1},...,e_{kn_k}$ (note: $e$ and not $t$ as arugments).
        
    \end{itemize}
    
    \subsubsection{Widening}

        \begin{itemize}
        
            \item Does this give us any bounds on the complexity? (Or do the fact that we have arguments prevent this?)
            
            \item Footnote about \emph{narrowing}.
            
            \item Note that this is the reason $\cup$ needs to be higher-order.
        
        \end{itemize}
    
\subsection{Source language}

    \begin{itemize}

        \item We either need to omit the type annotations on $\TmCrash{\Ty}{\ExnLbl}$, or add them to $\TmIf{}{}{}$ and $\TmCase{}{}{}{}{}$.
    
        \item We do not have a rule \CiteRule{E-AnnAppExn}. Check that the canonical forms lemma gives us that terms of universally quantified type cannot be exceptional values.
        
        \item Replace the arrow with another one? (This one clashes with the reduction relation from $\LambdaUnion$.)
        
        \item Define the meaning of the double brackets in the redecution rule E-Op.
        
        \item Let-bindings can be defined in terms of abstractions (because HRP)

    \end{itemize}
    
\subsection{Exception types}

    \begin{itemize}
    
        \item ``Type signatures are denoted as ...'' there are several other ways used to write this
        
        \item The syntax of environments is omitted from the ``syntax'' figure
        
        \item Merge the figures with syntax and well-formedness?
    
        \item Elaborate on well-formedness
        
        \item Prove that $\xleftrightarrow{*} \iff \simeq$.
    
        \item \TODOX{Rename stuff in \CiteRule{T-App} in the elaboration system (now subtype/-effect of the result instead of the argument and clashes with the indices enumerated over by $i$!}
        
        \item \TODOX{\CiteRule{T-AnnAbs}: $e \notin \mathrm{fv}(\Gamma)$}

        \item $\ExnVar \in \ClassExnVar$

        \item Well-formedness of exception types: embed conservativity / full-flexibility?

        \item Can we roll \textsc{Univ} and \textsc{Arr} into a single construct: $\ExnTyForall{\ExnVar}{\Kind}{\ExnTyArr{\ExnTy_1}{\ExnVar}{\ExnTy_2}{\Exn(\ExnVar)}}$? Still need to deal with the well-formedness of $\ExnTy_1$... Also may need to quantify over more than one variable simultaneously...

    \end{itemize}
    
\subsubsection{Subtyping}

    \begin{itemize}

        \item Is \CiteRule{S-Refl} an admissable/derivable rule, or should we drop \CiteRule{S-Bool} and \CiteRule{S-Int}?
        
        \item Possibly useful lemma: $\ExnTy_1 = \ExnTy_2 \iff \ExnTy_1 \leq \ExnTy_2 \land \ExnTy_2 \leq \ExnTy_1$.

    \end{itemize}

\subsubsection{Conservative types}

    \begin{itemize}

        \item \TODOX{Atomicity: \ensuremath{\Varid{e}_{\mathrm{1}}\cup \Varid{e}_{\mathrm{2}}\to \ExnTyList{\Varid{e}_{\mathrm{1}}}{\Varid{e}_{\mathrm{2}}}} is not useful, because no introspection}

        \item \TODO check all examples types against prototype

        \item \TODO properly typeset example types

        \item \TODO Skolemization and explicit existential quantification over unification variables?

    \end{itemize}
    
\subsubsection{Declarative type system}

    \begin{itemize}

        \item \TODOX{Exception type erasure relation}
        
        \item \TODOX{Least upper bounds (declaratively, as subtypes)}

    \end{itemize}

    \begin{itemize}
    
        \item In T-AnnAbs, $\Gamma, \xi = \Delta$?

        \item In T-Abs and T-AnnAbs, should the term-level term-abstraction also have an explicit effect annotation?

        \item In T-AnnAbs, might need a side condition stating that $\ExnVar$ is not free in $\KiEnv$.

        \item In T-App, note the double occurence of $\Exn$ when typing $\Tm_1$. Is subeffecting sufficient here? Also note that we do \emph{not} expect an exception variable in the left-hand side annotation of the function space constructor.
        
        \item In T-AnnApp, note the substitution. We need a substitution lemma for annotations.
        
        \item In T-Fix, the might be some universal quantifiers in our way. Do annotation applications in $\Tm$ take care of this, already? Perhaps we do need to change $\TmFix{\Tm}$ into a binding construct to resolve this? Also, there is some implicit subeffecting going on between the annotations and effect.
        
        \item In T-Case, note the use of explicit subeffecting. Can this be done using implicit subeffecting?
        
        \item For T-Sub, should we introduce a term-level coercion, as in Dussart--Henglein--Mossin? We now do shape-conformant subtyping, is subeffecting sufficient?
        
        \item Do we need additional kinding judgements in some of the rules? Can we merge the kinding judgement with the subtyping and/or -effecting judgement? Kind-preserving substitutions.
        
    \end{itemize}
    
\subsubsection{Type elaboration system}

    \begin{itemize}
    
        \item In \CiteRule{T-App} and {T-Fix}, note that there are substitutions in the premises of the rules. Are these inductive? (Probably, as these premises are not ``recursive'' ones.)

    \end{itemize}
    
\subsection{Type inference}

    \begin{itemize}

        \item Complexity: reduction corresponds to agressive constraint simplification

        \item alternative (faster?) version of Kleene-Mycroft

        \item In R-App and R-Fix: check that the fresh variables generated by \ensuremath{\mathcal{I}(\cdot )} are subsituted away by the substitution \ensuremath{\theta} created by \ensuremath{\mathcal{M}(\cdot ; \cdot ; \cdot )}. Also, we don't need those variables in the algorithm if we don't generate the elaborated term.

        \item In R-Fix we could get rid of the auxillary underlying type function if the fixpoint construct was replaced with a binding variant with an explicit type annotation.
        
        \item For R-Fix, make sure the way we handle fixpoints of exceptional value in a manner that is sound w.r.t. to the operational semantics we are going to give to this.

        \item Note that we do not construct the elaborated term, as it is not useful other than for metatheoretic purposes.
        
        \item Lemma: The algorithm maintains the invariant that exception types and exceptions are in normal form. 
        
        \item Typesetting issues \ensuremath{\llfloor \cdot \rrfloor_{\cdot }}

    \end{itemize}
    
\subsection{Related work}

    \begin{itemize}
    
        \item linear-algebriac lambda-calculi (Arrighi and Dowek, Vaux)
    
        \item More differences between \cite{HoldermansHage} (e.g. data types)?
        
        \item Christian Mossin. ``Exact flow types'' (intersection types, also non-elementary recursive by Statman)
        
        \item algebraic lambda calculus: higher-order $\to$ second-order?
    
    \end{itemize}
    
\subsection{Future research}

    \begin{itemize}

        \item higher-ranked algebraic effect types, Koka
    
    \end{itemize}
