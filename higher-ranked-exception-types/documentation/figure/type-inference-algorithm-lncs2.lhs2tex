\begin{figure}[p]
\begin{code}
    RECONSTRUCT :: Product ClassTyEnv (Product ClassKiEnv ClassTm) -> Product (Product ClassExnTm ClassExnTy) ClassExn

    reconstruct env kenv Var         =  x :: env_x

    reconstruct env kenv (ConX)      =  Result ConX bottomTy ExnEmpty

    reconstruct env kenv Crash       =  Result Crash bottomTy ExnCon

    reconstruct env kenv Abs         =
        let     TripleC ExnTy_1 e kenv'        =  complete EmptyEnv ty
                                             
                TupleR tm' ExnTy_2 Exn_2       =  reconstruct (extendTyEnv env Var ExnTy_1 e) (kenv,kenv') Tm
        in      Result ElabAbs (ExnForall kenv' (ExnTyArr ExnTy_1 e ExnTy_2 Exn_2)) ExnEmpty

    reconstruct env kenv (App)       =
        let     TupleR tm'_1 ExnTy_1 Exn_1                              = reconstruct env kenv tm_1
                TupleR tm'_2 ExnTy_2 Exn_2                              = reconstruct env kenv tm_2
                TupleI (ExnTyArr ExnTy_2' ExnVar_2' ExnTy' Exn') kenv'  = instantiate ExnTy_1
                subst                                                   = Subst ExnVar_2' Exn_2 . match EmptyEnv ExnTy_2' ExnTy_2
        in      Result ElabApp (simplify kenv (applySubst ExnTy')) (simplify kenv (ExnUnion (applySubst Exn') (Exn_1)))

    reconstruct env kenv (Fix) =
        do      TripleX i ExnTy_0 Exn_0  <- TripleX 0 bottomTyU ExnEmpty
                repeat  (TupleR tm'_i' ExnTy_i1 Exn_i1)  <- reconstruct (env, x :: ExnTy_i & Exn_i) kenv tm
                        i                                <- i + 1
                until (Tuple ExnTy_i Exn_i) == Tuple ExnTy_im Exn_im
                return (ResultF ElabFix ExnTy_i Exn_i)

    reconstruct env kenv (Seq) =      
        let     TupleR tm'_1 ExnTy_1 Exn_1  = reconstruct env kenv tm_1
                TupleR tm'_2 ExnTy_2 Exn_2  = reconstruct env kenv tm_2
        in      Result ElabSeq ExnTy_2 (simplify kenv (ExnUnion Exn_1 Exn_2))

    reconstruct env kenv (BinOp) =
        let     TupleR tm'_1 ExnTyInt Exn_1  = reconstruct env kenv tm_1
                TupleR tm'_2 ExnTyInt Exn_2  = reconstruct env kenv tm_2
        in      Result ElabBinOp ExnTyBool (simplify kenv (ExnUnion Exn_1 Exn_2))

    reconstruct env kenv (If) =
        let     TupleR tm'_1 ExnTyBool Exn_1  = reconstruct env kenv tm_1
                TupleR tm'_2 ExnTy_2 Exn_2    = reconstruct env kenv tm_2
                TupleR tm'_3 ExnTy_3 Exn_3    = reconstruct env kenv tm_3
        in      Result ElabIf (simplify kenv (ExnTyJoin ExnTy_2 ExnTy_3)) (simplify kenv (ExnUnion Exn_1 (ExnUnion Exn_2 Exn_3)))

    reconstruct env kenv Nil         =  Result Nil (ExnTyList bottomTy ExnEmpty) ExnEmpty

    reconstruct env kenv (Cons) =  
        let     TupleR tm'_1 ExnTy_1 Exn_1                     = reconstruct env kenv tm_1
                TupleR tm'_2 (ExnTyList ExnTy_2 Exn_2') Exn_2  = reconstruct env kenv tm_2
        in      Result (tm'_1 : tm'_2) (simplify kenv (ExnTyList (ExnTyJoin ExnTy_1 ExnTy_2) (ExnUnion Exn_1 Exn_2'))) Exn_2

    reconstruct env kenv (Case) =     
        let     TupleR tm'_1 (ExnTyList ExnTy_1 Exn_1') Exn_1  = reconstruct env kenv tm_1
                gamma'                                         = extendTyEnv (extendTyEnv env Var_1 ExnTy_1 Exn_1') Var_2 (ExnTyList ExnTy_1 Exn_1') Exn_1
                TupleR tm'_2 ExnTy_2 Exn_2                     = reconstruct env kenv tm_2
                TupleR tm'_3 ExnTy_3 Exn_3                     = reconstruct gamma' kenv tm_3
        in      Result ElabCase
                                            (simplify kenv (ExnTyJoin ExnTy_2 ExnTy_3)) (simplify kenv (ExnUnion Exn_1 (ExnUnion Exn_2 Exn_3)))
\end{code}
\caption{Type inference algorithm ($\mathcal{R}$)}\label{figure-type-inference-algorithm}
\end{figure}
