\section{Related work}

\subsection{Higher-ranked polymorphism in type and effect systems}

\citet{KennedyThesis} presents a type system that ensures the dimensional consistency of  a ML-like language extended with units of measure ($\mathrm{ML}_\delta$). This language has predicative, prenex dimension polymorphism. Kennedy gives an Algorithm~$\mathcal{W}$-like type inference procedure that uses equational unification to deal with the Abelian group (AG) structure of dimension expressions. Also described are two explicitly typed variants of the language: a System F-like language with arbitrary rank dimension polymorphism ($\Lambda_\delta$), and a System~$\mathrm{F}_\omega$-like language that extends $\Lambda_\delta$ with dimension operators ($\Lambda_{\delta\omega}$). This latter language bears a striking resemblance to our language in Figure~\ref{fig-exception-type-syntax}: the empty and singleton exception sets constants and the exception set union operator have been replaced with a unit dimension and dimension product and inverse operators, because dimensions have an AG structure, while exception sets have an ACI1 structure; in the dimension type system the annotation is placed only on the real number base type instead of on the compound types, and there is no effect. No type inference algorithm is presented for this language, however.

Polymorphic recursion

Stefan

RW in Stefan (Faxen?)

\LORUMIPSUM

\subsection{Exception analyses}
ML. Haskell.

\LORUMIPSUM

\LORUMIPSUM

\subsection{$\LambdaUnion$-calculus}

Revezc

Andrew J. Kennedy, Type inference and equational theories


Tanner etc.

\LORUMIPSUM

\section{Further research}

At least two opportunities for further research present itself:
\begin{enumerate}
    \item Can we adapt our type inference algorithm to automatically infer types for Kennedy's higher-ranked $\Lambda_{\delta\omega}$? \TODOX{Kennedy's example of a term than can then be typed} One problem that immediately presents itself is that this type system is not a conservative extension of the underlying type system: programs can be rejected because, while type correct in the underlying type system, the program may still be dimensionally inconsistent.
    
    Unlike in this system, the annotations on function arguments will no longer be of the simple form (variables only) required for the straightforward matching step in our type inference algorithm. Instead we will likely have to solve a higher-order (equational) unification problem, which is only semi-decidable. \citet{Snyder:1990:HOE:648229.752474} and \citet{NipkowQian1991} do gives us semi-algorithms for solving such problems (although, at least in the latter approach, the equational theory is assumed to be regular, which the theory of Abelian groups is not).
    
    \item In previous work \cite{Koot:2015:TEA:2678015.2682542} we argued that an accurate exception typing system for non-strict languages should also take the data flow of the program into account, as many exceptions that can be raised in non-strict languages are caused by incomplete pattern matches. The canonical example is the |risers| function---which splits a list into monotonically increasing subsegments; e.g., |risers [1, 3, 5, 1, 2] ---> [[1, 3, 5], [1, 2]]|---by \citet{Mitchell:2008:PBE:1411286.1411293}:
    
    \begin{code}
        risers  :: [Int] -> [[Int]]
        risers  []               =  []
        risers  [x]              =  [[x]]
        risers (x_1 : x_2 : xs)  =
            if x_1 <= x_2 then (x_1 : y) : ys else [x_1] : (y : ys)
                where (y : ys) = risers (x_2 : xs)
    \end{code}

    Our type inference algorithm assigns |risers| the exception type

    % (∀e1::E.(∀e2::E.([int⟨e2⟩]⟨e1⟩→[[int⟨e2⟩]⟨∅⟩]⟨({risers}∪(e1∪e2))⟩))) & ∅    
    \begin{code}
        forall e_1 : EXN. forall e_2 : EXN.
            ExnTyArr (ExnTyList ExnTyInt e_2) e_1 (ExnList (ExnTyList ExnTyInt e_2) ExnEmpty) (e_1 # e_2 # ExnConE) :&: EmptySet
    \end{code}
    
    where |ExnLblE| is the label of the exception raised when the pattern match in the |where|-clause fails.\footnote{This exception is left implicit in the above program, but becomes explicit when the code is desugared into our core language.} However, we pattern match on the result of the recursive call |risers (x_2 : xs)|. When |risers| is given a non-empty list (for example |x_2 : xs|) as an argument, it will always return a non-empty list as its result. The pattern match can thus never fail, and the exception labelled |ExnLblE| will thus never be raised.
    
    In our previous work showed how \TODO

    \TODOX{BR (Wright, Benson)}
\end{enumerate}
