\section{Exception types}\label{section-exception-types}

\subsection{Exception types}

The syntax of well-formed exception types are given in Figure~\ref{fig-exception-type-syntax} and Figure~\ref{fig-exception-type-well-formed}. An exception type~$\ExnTy$ is formed out of base types (booleans), compound types (lists), function types and quantification over exception variables.\footnote{To avoid complicating the presentation we do \emph{not} allow quantification over type variables, i.e. polymorpism in the underlying type system.}

For a list with exception type $\ExnTyList{\ExnTy}{\Exn}$ and effect $\ExnAlt$, the type $\ExnTy$ of the elements in the list is \emph{annotated} with an exception set expression $\Exn$ of kind~$\KindEXN$. This expression gives a set of exceptions which may be raised when an element of the list is forced. The effect $\ExnAlt$ gives a set of exceptions that may be raised when a constructor forming the spine of the list is forced.

For a function with exception type $\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}$ and effect~$\ExnAlt$, the argument of type $\ExnTy_1$ is annotated with an exception set expression $\Exn_1$ that gives set of exceptions that may be raised if the argument is forced by the function. The result of type $\ExnTy_2$ is annotated with an exception set expression $\Exn_2$ that gives the set of exceptions that may be raised when the result of the function is forced. The effect $\ExnAlt$ gives the set of exceptions that may be raised if the function closure is forced.

\begin{figure}[h!]
    \begin{alignat}{2}
        \Kind \in \ClassKind &\ ::=\ &&\KindEXN \tag{exception set} \\
                             &\quad||  &&\Kind_1 \KindArr \Kind_2 \tag{exception set operator}\\
        \notag\\
        \Exn, \ExnAlt \in \ClassExn  &\ ::=\ &&\ExnVar \tag{exception set variables} \\
                            &\quad||  &&\ExnAbs{\ExnVar}{\Kind}{\Exn} \tag{exception set abstraction}\\
                            &\quad||    &&\ExnApp{\Exn_1}{\Exn_2} \tag{exception set application}\\
                            &\quad||    &&\ExnEmpty \tag{empty exception set} \\
                            &\quad||    &&\ExnCon{\ExnLbl} \tag{singleton exception} \\
                            &\quad||    &&\ExnUnion{\Exn_1}{\Exn_2} \tag{exception set union} \\
    \notag\\
        \ExnTy \in \ClassExnTy &\ ::=\ &&\ExnForall{\ExnVar :: \Kind}\ExnTy \tag{exception set quantification} \\
                     &\quad||  &&\ExnBool \tag{boolean type} \\
                     &\quad||  &&\ExnInt  \tag{integer type} \\
                     &\quad||  &&\ExnTyList{\ExnTy}{\Exn} \tag{list type} \\
                     &\quad||  &&\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2} \tag{function type}
    \end{alignat}
    \caption{Exception types: syntax}
    \label{fig-exception-type-syntax}
\end{figure}

\begin{example} The identity function
    \begin{code}
    id  ::  forall e. ExnArr ExnBool e ExnBool e :&: EmptySet
    id  =   LAMBDA x x
    \end{code}
    propagates any exceptional value passed to it as an argument to the result unchanged. As the identity function is constructed by a literal $\lambda$-abstraction, no exception is raised when the resulting closure is forced, hence the empty effect.
\end{example}

%format bottom_E_fun = "\lightning^\mathbf{E}_{\TyBool \to \TyBool}"
\begin{example} The exceptional function value
    \begin{code}
    bottom_E_fun ::  forall e. ExnArr ExnBool e ExnBool EmptySet :&: e_E
    \end{code}
    raises an exception when its closure is forced, for example as happens when it is applied to an argument. As this function can never produce a result, it certainly cannot produce an exceptional value, so the result type is annotated with an empty exception set.
\end{example}

\begin{figure}[t]
    \begin{gather*}
        \Rule{W-Univ}
             {\JudgeExnTyWff{d}{\KiEnv,\ExnVar :: \Kind}{\ExnTy}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}}
        \HOR
        \Rule{W-Bool}
             {}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyBool}}
        \VER
        \Rule{W-List}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTy} \quad \JudgeKind{\KiEnv}{\Exn}{\KindEXN}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyList{\ExnTy}{\Exn}}}
        \VER
        \Rule{W-Arr}
             {\begin{gathered}\JudgeExnTyWff{d}{\KiEnv}{\ExnTy_1} \quad \JudgeKind{\KiEnv}{\Exn_1}{\KindEXN} \\ \JudgeExnTyWff{d}{\KiEnv}{\ExnTy_2} \quad \JudgeKind{\KiEnv}{\Exn_2}{\KindEXN}\end{gathered}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}}
    \end{gather*}
    \caption{Exception types: well-formedness ($\JudgeExnTyWff{d}{\KiEnv}{\ExnTy}$)}
    \label{fig-exception-type-well-formed}
\end{figure}

The exception set expressions $\Exn$ and their kinds $\Kind$ are an instance of the \mbox{$\LambdaUnion$-calculus}, where exception set expressions are terms and kinds are the types. Two exception set expressions are considered equivalent if they are convertible as $\LambdaUnion$-terms, which is to say that they reduce to the same normal form.

The type system resembles \SystemFw \cite{Girard1972} in that we have quantification, abstraction and application at the type level. A key difference is that abstraction and application are restricted to the effects ($\ClassExn$) and cannot be used in the types ($\ClassExnTy$) directly.
Quantification on the other hand is resticted to the types, over effects, and not allowed in the effect itself. The types thus remain predicative.

\subsection{Conservativeness}

\TODOX{Atomicity: |e_1 # e_2 -> ExnTyList e_1 e_2| is not useful, because no introspection}

Any program that is typeable in the underlying type system should also have an exception type: the exception type system is a conservative extension of the underlying type system. Like type systems for strictness or control flow analysis, and unlike type systems for information flow security or dimensional analysis, we do not want to reject any program that is well-typed in the underlying type system, but merely provide more insight into its behavior.

If we furthermore want our type system to be modular---allowing type checking and inference to work on individual modules instead of whole programs---we cannot make any assumptions about the exception types of the arguments that are applied to any function, as the function may be called from outside the module with an argument that also comes from outside the module and which we cannot know anything about.\footnote{\citet{HoldermansHage} call such types \emph{fully flexible}.}

For base and compound types that stand in an argument position their effect and any nested annotations must thus be instantiatable to any arbitrary exception set expression. They must thus be exception set variables that have been universally quantified.

\begin{itemize}
    \item \TODO check all examples types against prototype
    \item \TODO properly typeset example types
    \item \TODO Skolemization and expliciy existential quantication over unification variables?
\end{itemize}

\begin{example}\
\begin{code}
    tail :: forall e_1 e_2. ExnArr (ExnList ExnBool e_1) e_2 (ExnList ExnBool e_1) (e_2 # ExnConE) :&: EmptySet
\end{code}

\begin{code}
    &&  :: forall e_1. ExnArr ExnBool e_1 ((forall e_2. ExnArr ExnBool e_2 ExnBool (e_1 # e_2))) EmptySet :&: EmptySet
\end{code}
\end{example}

For function types that stand in an argument position (the functional parameters of a higher-order function) the situation is slightly more complicated. For the argument of this function we can inductively assume that this is a universally quantified exception set variable. The result of this function, however, is some exception set expression that depends on the exception set variables that were quantified over in the argument. We cannot simply introduce a new exception set variable here, but must introduce a Skolem function that depends on each of the universally quantified exception set variables.

\begin{example} Consider the higher-order function |apply| that applies its first argument to the second.
% apply : A e2:E. A e3:E=>E.
%           (A e1:E. bool<e1> --<e2>-> bool<e3 e2>) ->
%               A e4:E. bool<e4> -> bool<e2 + e3 e4>
\begin{code}
    apply  ::   forall e_2 : EXN. forall e_3 : EXN => EXN.
                  ExnArrA ((forall e_1 : EXN. ExnArr ExnBool e_1 ExnBool (e_3 e_1))) e_2
                    (ExnArrB ((forall e_4 : EXN. ExnArr ExnBool e_4 ExnBool (e_2 # e_3 e_4))) ExnEmpty)
           :&:  ExnEmpty
    apply  =  LAMBDA f (LAMBDA x (f x))
\end{code}

The first (functional) argument of |apply| has exception type |forall e_1 :: EXN. ExnArr ExnBool e_1 ExnBool (e_3 e_1)| and effect |e_2|. It can be instantiated with any function that accepts an argument annotated with any exception set effect, and produces a result annotated with some exception set effect depending on the exception set effect of the argument; the function closure itself may raise any exception. All functions of underlying type |Bool -> Bool| satisfy these constraints, so they do not really constrain us in any way.

As |e_1| has been quantified over, only the exception set operator~|e_3| and the effect |e_2| are left free. We quantify over them outside the outer function space constructor, allowing them to appear in the annotation |e_2 # e_3 e_4| on the result. The exception set operator |e_3| is now applied to |e_4|, as the term-level application |f x| instantiates the quantified exception set variable |e_1| to |e_4|.

(Note that the exception annotation $e_2$ on the closure---unlike the exception set operator $e_3$ on the result---does not depend on the exception variable $e_1$ annotation the argument. As a closure is already a value, it being exceptional or not can never depend on the argument it is later applied to.)
\end{example}

%format CrashB2B = "\TmCrash{\TyBool\to\TyBool}{\ExnLblE}"
\begin{example}
    Exception types are not invariant under $\eta$-conversion. The term
    \savecolumns
    \begin{code}
        LAMBDA (x :: Bool) (CrashB2B x)  :: forall e : EXN. ExnTyArrT ExnBool e ExnBool ExnConE EmptySet
    \end{code}
    does not have the same exception type as the $\eta$-equivalent term
    \restorecolumns
    \begin{code}
        CrashB2B                         :: forall e : EXN. ExnTyArrT ExnBool e ExnBool EmptySet ExnConE
    \end{code}
    We cannot observe a difference between these terms by applying an argument to them
    \begin{code}
        (LAMBDA (x :: Bool) (CrashB2B x))  True  :: ExnBool :&: ExnConE
        CrashB2B                           True  :: ExnBool :&: ExnConE
    \end{code}
    but we can by forcing the closure
    \begin{code}
        (LAMBDA (x :: Bool) (CrashB2B x))  seq  True  :: ExnBool :&: EmptySet
        CrashB2B                           seq  True  :: ExnBool :&: ExnConE
    \end{code}
\end{example}

\subsection{Least exception types}

\TODO

\subsection{Exception type completion}

During exception type inference we need to compute the least constraint exception type that erases to a given underlying type.

\subsection{Subtyping}

\begin{itemize}
    \item Is \CiteRule{S-Refl} an admissable/derivable rule, or should we drop \CiteRule{S-Bool} and \CiteRule{S-Int}?
\end{itemize}

\begin{figure}[h]
    \begin{gather*}
        \Rule{S-Refl}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy}}
        \quad
        \Rule{S-Trans}
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_2}
              \quad
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_3}
             }
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_3}}
        \\[1.5ex]
        \Rule{S-Bool}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnBool}{\ExnBool}}
        \quad
        \Rule{S-Int}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnInt}{\ExnInt}}
        \\[1.5ex]
        \Rule{S-Arr}
             {\begin{gathered}
              \JudgeSubTy{\KiEnv}{\ExnTy_1^\prime}{\ExnTy_1}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn_1^\prime}{\Exn_1}
                \\
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_2^\prime}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn_2}{\Exn_2^\prime}
              \end{gathered}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}
                         {\ExnTyArr{\ExnTy_1^\prime}{\Exn_1^\prime}{\ExnTy_2^\prime}{\Exn_2^\prime}}
             }
        \\[1.5ex]
        \Rule{S-List}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy^\prime}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn}{\Exn^\prime}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyList{\ExnTy}{\Exn}}
                         {\ExnTyList{\ExnTy^\prime}{\Exn^\prime}}
             }
        \VER
        \Rule{S-Forall}
             {\JudgeSubTy{\KiEnv, \ExnVar :: \Kind}{\ExnTy_1}{\ExnTy_2}}
             {\JudgeSubTy{\KiEnv}
                         {\ExnForall{\ExnVar :: \Kind}{\ExnTy_1}}
                         {\ExnForall{\ExnVar :: \Kind}{\ExnTy_2}}
             }
    \end{gather*}
\caption{Exception types: subtyping relation ($\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_2}$)}
\end{figure}

\begin{itemize}

    \item Possibly useful lemma: $\ExnTy_1 = \ExnTy_2 \iff \ExnTy_1 \leq \ExnTy_2 \land \ExnTy_2 \leq \ExnTy_1$.

\end{itemize}

\subsection{Declarative exception type system}

%include ../figure/declarative-exception-type-system.lhs2tex

\begin{itemize}

    \item In T-Abs and T-AnnAbs, should the term-level term-abstraction also have an explicit effect annotation?

    \item In T-AnnAbs, might need a side condition stating that $\ExnVar$ is not free in $\KiEnv$.

    \item In T-App, note the double occurence of $\Exn$ when typing $\Tm_1$. Is subeffecting sufficient here? Also note that we do \emph{not} expect an exception variable in the left-hand side annotation of the function space constructor.
    
    \item In T-AnnApp, note the substitution. We need a substitution lemma for annotations.
    
    \item In T-Fix, the might be some universal quantifiers in our way. Do annotation applications in $\Tm$ take care of this, already? Perhaps we do need to change $\TmFix{\Tm}$ into a binding construct to resolve this? Also, there is some implicit subeffecting going on between the annotations and effect.
    
    \item In T-Case, note the use of explicit subeffecting. Can this be done using implicit subeffecting?
    
    \item For T-Sub, should we introduce a term-level coercion, as in Dussart--Henglein--Mossin? We now do shape-conformant subtyping, is subeffecting sufficient?
    
    \item Do we need additional kinding judgements in some of the rules? Can we merge the kinding judgement with the subtyping and/or -effecting judgement? Kind-preserving substitutions.
    
\end{itemize}

\subsection{Type elaboration system}

\begin{itemize}

    \item \TODOX{Source language extentsion}

    \item \TODOX{Type completion}
    
    \item \TODOX{least types}

    \item \TODOX{Type erasure relation}
    
    \item \TODOX{leat upper bound (declarativly in terms of subtyping}

    \item In \CiteRule{T-App} and {T-Fix}, note that there are substitutions in the premises of the rules. Are these inductive? (Probably, as these premises are not ``recursive'' ones.)

\end{itemize}

%include ../figure/type-elaboration-system.lhs2tex

\begin{itemize}

 \item For T-Fix: how would a binding fixpoint construct work?

\end{itemize}

\subsection{Type simplification}

In their fully flexible form the location of the quantifiers is uniquely determined, so we can omit them from the type without introducing ambiguity. For example, the exception type of the |map| function from the introduction can be presented to the programmer as:
\begin{code}
(ThrowsArr (Throws alpha e_1) (Throws beta (e_2 e_1)) (e_3)) -> Throws ([Throws alpha e_4]) e_5 -> Throws ([Throws beta (e_2 e_4 # e_3)]) e_5
\end{code}

\begin{itemize}

    \item \TODOX{apply?}

\end{itemize}
