\section{Exception types}\label{section-exception-types}

\subsection{Exception types}

The syntax of well-formed exception types are given in Figure~\ref{fig-exception-type-syntax} and Figure~\ref{fig-exception-type-well-formed}. An exception type~$\ExnTy$ is formed out of base types (booleans), compound types (lists), function types and quantification over exception variables.\footnote{To avoid complicating the presentation we do \emph{not} allow quantification over type variables, i.e. polymorphism in the underlying type system.}

For a list with exception type $\ExnTyList{\ExnTy}{\Exn}$ and effect $\ExnAlt$, the type $\ExnTy$ of the elements in the list is \emph{annotated} with an exception set expression $\Exn$ of kind~$\KindEXN$. This expression gives a set of exceptions which may be raised when an element of the list is forced. The effect $\ExnAlt$ gives a set of exceptions that may be raised when a constructor forming the spine of the list is forced.

For a function with exception type $\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}$ and effect~$\ExnAlt$, the argument of type $\ExnTy_1$ is annotated with an exception set expression $\Exn_1$ that gives set of exceptions that may be raised if the argument is forced by the function. The result of type $\ExnTy_2$ is annotated with an exception set expression $\Exn_2$ that gives the set of exceptions that may be raised when the result of the function is forced. The effect $\ExnAlt$ gives the set of exceptions that may be raised if the function closure is forced.

\begin{figure}[h!]
    \begin{alignat}{2}
        \Kind \in \ClassKind &\ ::=\ &&\KindEXN \tag{exception set} \\
                             &\quad||  &&\Kind_1 \KindArr \Kind_2 \tag{exception set operator}\\
        \notag\\
        \Exn, \ExnAlt \in \ClassExn  &\ ::=\ &&\ExnVar \tag{exception set variables} \\
                            &\quad||  &&\ExnAbs{\ExnVar}{\Kind}{\Exn} \tag{exception set abstraction}\\
                            &\quad||    &&\ExnApp{\Exn_1}{\Exn_2} \tag{exception set application}\\
                            &\quad||    &&\ExnEmpty \tag{empty exception set} \\
                            &\quad||    &&\ExnCon{\ExnLbl} \tag{singleton exception} \\
                            &\quad||    &&\ExnUnion{\Exn_1}{\Exn_2} \tag{exception set union} \\
    \notag\\
        \ExnTy \in \ClassExnTy &\ ::=\ &&\ExnForall{\ExnVar :: \Kind}\ExnTy \tag{exception set quantification} \\
                     &\quad||  &&\ExnBool \tag{boolean type} \\
                     &\quad||  &&\ExnInt  \tag{integer type} \\
                     &\quad||  &&\ExnTyList{\ExnTy}{\Exn} \tag{list type} \\
                     &\quad||  &&\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2} \tag{function type}
    \end{alignat}
    \caption{Exception types: syntax}
    \label{fig-exception-type-syntax}
\end{figure}

\begin{example} The identity function
    \begin{code}
    id  ::  forall e. ExnArr ExnBool e ExnBool e :&: EmptySet
    id  =   LAMBDA x x
    \end{code}
    propagates any exceptional value passed to it as an argument to the result unchanged. As the identity function is constructed by a literal $\lambda$-abstraction, no exception is raised when the resulting closure is forced, hence the empty effect.
\end{example}

%format bottom_E_fun = "\lightning^\mathbf{E}_{\TyBool \to \TyBool}"
\begin{example} The exceptional function value
    \begin{code}
    bottom_E_fun ::  forall e. ExnArr ExnBool e ExnBool EmptySet :&: e_E
    \end{code}
    raises an exception when its closure is forced, for example as happens when it is applied to an argument. As this function can never produce a result, it certainly cannot produce an exceptional value, so the result type is annotated with an empty exception set.
\end{example}

\begin{figure}[t]
    \begin{gather*}
        \Rule{W-Univ}
             {\JudgeExnTyWff{d}{\KiEnv,\ExnVar :: \Kind}{\ExnTy}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}}
        \VER
        \Rule{W-Bool}
             {}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnBool}}
        \HOR
        \Rule{W-Int}
             {}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnInt}}
        \VER
        \Rule{W-List}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTy} \quad \JudgeKind{\KiEnv}{\Exn}{\KindEXN}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyList{\ExnTy}{\Exn}}}
        \VER
        \Rule{W-Arr}
             {\begin{gathered}\JudgeExnTyWff{d}{\KiEnv}{\ExnTy_1} \quad \JudgeKind{\KiEnv}{\Exn_1}{\KindEXN} \\ \JudgeExnTyWff{d}{\KiEnv}{\ExnTy_2} \quad \JudgeKind{\KiEnv}{\Exn_2}{\KindEXN}\end{gathered}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}}
    \end{gather*}
    \caption{Exception types: well-formedness ($\JudgeExnTyWff{d}{\KiEnv}{\ExnTy}$)}
    \label{fig-exception-type-well-formed}
\end{figure}

The exception set expressions $\Exn$ and their kinds $\Kind$ are an instance of the \mbox{$\LambdaUnion$-calculus}, where exception set expressions are terms and kinds are the types. Two exception set expressions are considered equivalent if they are convertible as $\LambdaUnion$-terms, which is to say that they reduce to the same normal form.

The type system resembles \SystemFw \cite{Girard1972} in that we have quantification, abstraction and application at the type level. A key difference is that abstraction and application are restricted to the effects ($\ClassExn$) and cannot be used in the types ($\ClassExnTy$) directly.
Quantification on the other hand is resticted to the types, over effects, and not allowed in the effect itself. The types thus remain predicative.

\subsection{\TODO{Conservativeness}}

\TODOX{Atomicity: |e_1 # e_2 -> ExnTyList e_1 e_2| is not useful, because no introspection}

Any program that is typeable in the underlying type system should also have an exception type: the exception type system is a conservative extension of the underlying type system. Like type systems for strictness or control flow analysis, and unlike type systems for information flow security or dimensional analysis, we do not want to reject any program that is well-typed in the underlying type system, but merely provide more insight into its behavior.

If we furthermore want our type system to be modular---allowing type checking and inference to work on individual modules instead of whole programs---we cannot make any assumptions about the exception types of the arguments that are applied to any function, as the function may be called from outside the module with an argument that also comes from outside the module and which we cannot know anything about.\footnote{\citet{HoldermansHage} call such types \emph{fully flexible}.}

For base and compound types that stand in an argument position their effect and any nested annotations must thus be instantiatable to any arbitrary exception set expression. They must thus be exception set variables that have been universally quantified.

\begin{itemize}
    \item \TODO check all examples types against prototype
    \item \TODO properly typeset example types
    \item \TODO Skolemization and expliciy existential quantication over unification variables?
\end{itemize}

\begin{example}[\TODO]\
\begin{code}
    tail :: forall e_1 e_2. ExnArr (ExnList ExnBool e_1) e_2 (ExnList ExnBool e_1) (e_2 # ExnConE) :&: EmptySet
\end{code}

\begin{code}
    &&  :: forall e_1. ExnArr ExnBool e_1 ((forall e_2. ExnArr ExnBool e_2 ExnBool (e_1 # e_2))) EmptySet :&: EmptySet
\end{code}
\LORUMIPSUM
\end{example}

For function types that stand in an argument position (the functional parameters of a higher-order function) the situation is slightly more complicated. For the argument of this function we can inductively assume that this is a universally quantified exception set variable. The result of this function, however, is some exception set expression that depends on the exception set variables that were quantified over in the argument. We cannot simply introduce a new exception set variable here, but must introduce a Skolem function that depends on each of the universally quantified exception set variables.

\begin{example} Consider the higher-order function |apply| that applies its first argument to the second.
% apply : A e2:E. A e3:E=>E.
%           (A e1:E. bool<e1> --<e2>-> bool<e3 e2>) ->
%               A e4:E. bool<e4> -> bool<e2 + e3 e4>
\begin{code}
    apply  ::   forall e_2 : EXN. forall e_3 : EXN => EXN.
                  ExnArrA ((forall e_1 : EXN. ExnArr ExnBool e_1 ExnBool (e_3 e_1))) e_2
                    (ExnArrB ((forall e_4 : EXN. ExnArr ExnBool e_4 ExnBool (e_2 # e_3 e_4))) ExnEmpty)
           :&:  ExnEmpty
    apply  =  LAMBDA f (LAMBDA x (f x))
\end{code}

The first (functional) argument of |apply| has exception type |forall e_1 :: EXN. ExnArr ExnBool e_1 ExnBool (e_3 e_1)| and effect |e_2|. It can be instantiated with any function that accepts an argument annotated with any exception set effect, and produces a result annotated with some exception set effect depending on the exception set effect of the argument; the function closure itself may raise any exception. All functions of underlying type |Bool -> Bool| satisfy these constraints, so they do not really constrain us in any way.

As |e_1| has been quantified over, only the exception set operator~|e_3| and the effect |e_2| are left free. We quantify over them outside the outer function space constructor, allowing them to appear in the annotation |e_2 # e_3 e_4| on the result. The exception set operator |e_3| is now applied to |e_4|, as the term-level application |f x| instantiates the quantified exception set variable |e_1| to |e_4|.

(Note that the exception annotation $e_2$ on the closure---unlike the exception set operator $e_3$ on the result---does not depend on the exception variable $e_1$ annotation the argument. As a closure is already a value, it being exceptional or not can never depend on the argument it is later applied to.)
\end{example}

%format CrashB2B = "\TmCrash{\TyBool\to\TyBool}{\ExnLblE}"
\begin{example}
    Exception types are not invariant under $\eta$-conversion. The term
    \savecolumns
    \begin{code}
        LAMBDA (x :: Bool) (CrashB2B x)  :: forall e : EXN. ExnTyArrT ExnBool e ExnBool ExnConE EmptySet
    \end{code}
    does not have the same exception type as the $\eta$-equivalent term
    \restorecolumns
    \begin{code}
        CrashB2B                         :: forall e : EXN. ExnTyArrT ExnBool e ExnBool EmptySet ExnConE
    \end{code}
    We cannot observe a difference between these terms by applying an argument to them
    \begin{code}
        (LAMBDA (x :: Bool) (CrashB2B x))  True  :: ExnBool :&: ExnConE
        CrashB2B                           True  :: ExnBool :&: ExnConE
    \end{code}
    but we can by forcing the closure
    \begin{code}
        (LAMBDA (x :: Bool) (CrashB2B x))  seq  True  :: ExnBool :&: EmptySet
        CrashB2B                           seq  True  :: ExnBool :&: ExnConE
    \end{code}
\end{example}

\subsection{\TODO Subtyping}

\LORUMIPSUM

%include ../figure/subtyping.lhs2tex

\subsection{\TODO{Exception type completion}}

Give an underlying type $\Ty$ we can compute a the most general exception type $\ExnTy$ that erases to $\Ty$. This is done using the type completion system in Figure~\ref{figure-type-completion}, defining a type completion relation $\JudgeComplete{\KindENV}{\Ty}{\ExnTy}{\Exn}{\KindENV'}$.

A judgment $\JudgeComplete{\KindEnv{i}}{\Ty}{\ExnTy}{\Exn}{\KindEnv{j}}$ is read as: if the kinded exception set variables $\KindEnv{i}$ are in scope, then the underlying type $\Ty$ is completed to the exception type $\ExnTy$ and effect $\Exn$, while introducing the kinded free exception set variables $\KindEnv{j}$.

\begin{example}[\TODO] First-order, multiple arguments:
    \begin{align*}
        &\vdash         && \TyArr{\TyList{\TyBool}}{\TyArr{\TyList{\TyBool}}{\TyList{\TyBool}}} \\
        &:              &&    {\ExnTyForall{\ExnVar_1}{\KindEXN}{\ExnTyForall{\ExnVar_1^\prime}{\KindEXN}{\Throws{\ExnTyList{\ExnBool}{\ExnVar_1}}{\ExnVar_1^\prime}}}} \to \\
        &               && \quad (\ExnTyForall{\ExnVar_2}{\KindEXN}{\ExnTyForall{\ExnVar_2^\prime}{\KindEXN}{\Throws{\ExnTyList{\ExnBool}{\ExnVar_2}}{\ExnVar_2^\prime}}} \to \\
        &               && \quad\quad \Throws{\Throws{\ExnTyList{\ExnBool}{\ExnVar_3\ \ExnVar_1\ \ExnVar_1^\prime\ \ExnVar_2\ \ExnVar_2^\prime}}{\ExnVar_3^\prime\ \ExnVar_1\ \ExnVar_1^\prime\ \ExnVar_2\ \ExnVar_2^\prime})}{\ExnVar_4} \\
        &\&             && \ExnVar_5 \\
        &\triangleright && \ExnVar_3, \ExnVar_3^\prime :: \KindEXN\!\KindArr\!\KindEXN\!\KindArr\!\KindEXN\!\KindArr\!\KindEXN\!\KindArr\!\KindEXN, \ExnVar_4, \ExnVar_5 :: \KindEXN
    \end{align*}
    
    Higher-order:
    \begin{align*}
        &\vdash         && \TyArr{(\TyArr{\TyList{\TyBool}}{\TyList{\TyBool}})}{\TyList{\TyBool}} \\
        &:              && \ExnTyForall{\ExnVar_2,\ExnVar_2^\prime}{\KindEXN\!\KindArr\!\KindEXN\!\KindArr\!\KindEXN}{} \\
        &               && \quad \Throws{(\ExnTyForall{\ExnVar_1,\ExnVar_1^\prime}{\KindEXN}{\Throws{\ExnTyList{\ExnBool}{\ExnVar_1}}{\ExnVar_1^\prime} \to \\
        &               && \quad\quad\quad\quad\quad\quad\quad\quad\quad \Throws{\ExnTyList{\ExnBool}{\ExnVar_2\ \ExnVar_1\ \ExnVar_1^\prime}}{\ExnVar_2^\prime\ \ExnVar_1\ \ExnVar_1^\prime}})}{\ExnVar_3} \to \\
        &               && \quad\quad \Throws{\ExnTyList{\ExnBool}{\ExnVar_4\ \ExnVar_2\ \ExnVar_2^\prime\ \ExnVar_3}}{\ExnVar_4^\prime\ \ExnVar_2\ \ExnVar_2^\prime\ \ExnVar_3} \\
        &\&             && \ExnVar_5\\
        &\triangleright && \ExnVar_4, \ExnVar_4^\prime :: (\KindEXN\!\KindArr\!\KindEXN\!\KindArr\!\KindEXN)\!\KindArr \\
        &               && \quad\quad\quad\quad\quad (\KindEXN\!\KindArr\!\KindEXN\!\KindArr\!\KindEXN)\!\KindArr\!\KindEXN\!\KindArr\!\KindEXN, \\
        &               && \ExnVar_5 :: \KindEXN
    \end{align*}
\end{example}

\subsection{\TODO Least exception types}

Given an effect kind $\overline{\kappa_i\Rightarrow}\KindEXN$, denote by $\emptyset_{\overline{\kappa_i\Rightarrow}\KindEXN}$ the effect $\lambda \overline{e_i :: \kappa_i}. \emptyset$.

Besides completing an underlying type $\Ty$ to a most general exception type, we also want to compute a least exception type~$\bot_\Ty$. This can be accomplished by first completing the type $\Ty$ to the most general exception type, and then substituting $\emptyset_{\kappa_j}$ for all newly introduced exception set variables $\KindEnv{j}$.

\begin{example}[\TODO] First-order, multiple arguments:
    \begin{align*}
        &\bot_{\TyList{\TyBool}\to\TyList{\TyBool}\to\TyList{\TyBool}} \\
        &= \ExnTyForall{\ExnVar_1,\ExnVar_1^\prime}{\KindEXN}{\Throws{\ExnTyList{\ExnBool}{\ExnVar_1}}{\ExnVar_1^\prime}\to} \\
        &\quad\quad\quad\quad\ExnTyForall{\ExnVar_2,\ExnVar_2^\prime}{\KindEXN}{\Throws{\ExnTyList{\ExnBool}{\ExnVar_2}}{\ExnVar_2^\prime}\to \Throws{\ExnTyList{\ExnBool}{\ExnEmpty}}{\ExnEmpty}}
    \end{align*}
    
    Higher-order:
    \begin{align*}
        &\bot_{(\TyList{\TyBool}\to\TyList{\TyBool})\to\TyList{\TyBool}} \\
        &= \ExnTyForall{\ExnVar_2,\ExnVar_2^\prime}{\KindEXN\KindArr\KindEXN}{\ExnTyForall{\ExnVar_3,\ExnVar_3^\prime}{\KindEXN}} \\
        & \Throws{(\ExnTyForall{\ExnVar_1,\ExnVar_1^\prime}{\KindEXN}{\Throws{\ExnTyList{\ExnBool}{\ExnVar_1}}{\ExnVar_1^\prime}\to\Throws{\ExnTyList{\ExnBool}{\ExnEmpty}}{\ExnEmpty}})}{\ExnEmpty} \to \Throws{\ExnTyList{\ExnBool}{\ExnEmpty}}{\ExnEmpty}
    \end{align*}
\end{example}

\subsection{\TODO Declarative exception type system}

In Figure~\ref{figure-declarative-type-system} we give a declarative system for deriving exception typing judgments $\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$.

These judgments work on an explicitly type language and for this purpose we extend the terms of the source language with two new constructs: term-level effect abstraction and effect application.

\begin{figure}[h]
\paragraph{Terms}
\begin{alignat}{2}
\!  \Tm \in \ClassTm &\ ::=\   &&\ ...                            \notag       \\
                     &\quad||  &&\ \TmAbs{\TmVar}{\ExnTy\ \&\ \Exn}{\Tm} \tag{term abstraction} \\
                     &\quad||  &&\ \TmFixExn{\TmVar}{\ExnTy}{\Exn}{\Tm} \tag{fixpoint} \\
                     &\quad||  &&\ ...                            \notag       \\
                     &\quad||  &&\ \TmAnnAbs{\ExnVar}{\Kind}{\Tm} \tag{effect abstraction}  \\
                     &\quad||  &&\ \TmAnnApp{\Tm}{\Exn}           \tag{effect application}
\end{alignat}
\caption{Source language: extended syntax}\label{figure-source-language-syntax-extended}
\end{figure}

\subsection{\TODO Type elaboration system}

As the source language is not explicitly typed we also give a type elaboration system that given an implicitly typed term in the source language produces and explicitly typed term (Figure~\ref{type-elaboration-system}).

\begin{itemize}

    \item \TODOX{Exception type erasure relation}
    
    \item \TODOX{Least upper bounds (declaratively, as subtypes)}

\end{itemize}

\subsection{\TODO Type normalization}

\LORUMIPSUM

\subsection{Type simplification}

In their fully flexible form the location of the quantifiers is uniquely determined, so we can omit them from the type without introducing ambiguity. For example, the exception type of the |map| function from the introduction can be presented to the programmer as:
\begin{code}
(ThrowsArr (Throws alpha e_1) (Throws beta (e_2 e_1)) (e_3)) -> Throws ([Throws alpha e_4]) e_5 -> Throws ([Throws beta (e_2 e_4 # e_3)]) e_5
\end{code}

%include ../figure/declarative-exception-type-system.lhs2tex
%include ../figure/type-elaboration-system.lhs2tex
