\section{Exception types}\label{section-exception-types}

\subsection{Exception types}

The syntax of well-formed exception types are given in Figure~\ref{fig-exception-type-syntax} and Figure~\ref{fig-exception-type-well-formed}. An exception type~$\ExnTy$ is formed out of base types (booleans), compound types (lists), function types and quantification over exception variables.\footnote{To avoid complicating the presentation we do \emph{not} allow quantification over type variables, i.e. polymorpism in the underlying type system.}

For a list with exception type $\ExnTyList{\ExnTy}{\Exn}$ and effect $\ExnAlt$, the type $\ExnTy$ of the elements in the list is \emph{annotated} with an exception set expression $\Exn$ of kind~$\KindEXN$. This expression gives a set of exceptions which may be raised when an element of the list is forced. The effect $\ExnAlt$ gives a set of exceptions that may be raised when a constructor forming the spine of the list is forced.

For a function with exception type $\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}$ and effect~$\ExnAlt$, the argument of type $\ExnTy_1$ is annotated with an exception set expression $\Exn_1$ that gives set of exceptions that may be raised if the argument is forced by the function. The result of type $\ExnTy_2$ is annotated with an exception set expression $\Exn_2$ that gives the set of exceptions that may be raised when the result of the function is forced. The effect $\ExnAlt$ gives the set of exceptions that may be raised if the function closure is forced.

\begin{figure}[h]
    \begin{alignat}{2}
        \Kind \in \ClassKind &\ ::=\ &&\KindEXN \tag{exception set} \\
                             &\quad||  &&\Kind_1 \KindArr \Kind_2 \tag{exception operator}\\
        \notag\\
        \Exn, \ExnAlt \in \ClassExn  &\ ::=\ &&\ExnVar \tag{exception variables} \\
                            &\quad||  &&\ExnAbs{\ExnVar}{\Kind}{\Exn} \tag{exception abstraction}\\
                            &\quad||    &&\ExnApp{\Exn_1}{\Exn_2} \tag{exception application}\\
                            &\quad||    &&\ExnEmpty \tag{empty exception set} \\
                            &\quad||    &&\ExnCon{\ExnLbl} \tag{singleton exception} \\
                            &\quad||    &&\ExnUnion{\Exn_1}{\Exn_2} \tag{exception set union} \\
    \notag\\
        \ExnTy \in \ClassExnTy &\ ::=\ &&\ExnForall{\ExnVar :: \Kind}\ExnTy \tag{exception quantification} \\
                     &\quad||  &&\ExnBool \tag{boolean type} \\
                     &\quad||  &&\ExnInt  \tag{integer type} \\
                     &\quad||  &&\ExnTyList{\ExnTy}{\Exn} \tag{list type} \\
                     &\quad||  &&\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2} \tag{function type}
    \end{alignat}
    \caption{Exception types: syntax}
    \label{fig-exception-type-syntax}
\end{figure}

\begin{example} The identity function
    \begin{code}
    id  ::  forall e. ExnArr ExnBool e ExnBool e :&: EmptySet
    id  =   LAMBDA x x
    \end{code}
    propagates any exceptional value passed to it as an argument to the result unchanged. As the identity function is constructed by a literal $\lambda$-abstraction, no exception will be raised when the resulting closure is forced, hence the empty effect.
\end{example}

%format bottom_E_fun = "\lightning^\mathbf{E}_{\TyBool \to \TyBool}"
\begin{example} The exceptional function value
    \begin{code}
    bottom_E_fun ::  forall e. ExnArr ExnBool e ExnBool EmptySet :&: e_E
    \end{code}
    raises an exception when its closure is forced, for example as happens when an argument is applied to it. As this function can never produce a result, it certainly cannot produce an exceptional value, so the result type is annotated with an empty exception set.
\end{example}

\begin{figure}[ht]
    \begin{gather*}
        \Rule{W-Univ}
             {\JudgeExnTyWff{d}{\KiEnv,\ExnVar :: \Kind}{\ExnTy}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}}
        \HOR
        \Rule{W-Bool}
             {}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyBool}}
        \VER
        \Rule{W-List}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTy} \quad \JudgeKind{\KiEnv}{\Exn}{\KindEXN}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyList{\ExnTy}{\Exn}}}
        \VER
        \Rule{W-Arr}
             {\begin{gathered}\JudgeExnTyWff{d}{\KiEnv}{\ExnTy_1} \quad \JudgeKind{\KiEnv}{\Exn_1}{\KindEXN} \\ \JudgeExnTyWff{d}{\KiEnv}{\ExnTy_2} \quad \JudgeKind{\KiEnv}{\Exn_2}{\KindEXN}\end{gathered}}
             {\JudgeExnTyWff{d}{\KiEnv}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}}
    \end{gather*}
    \caption{Exception types: well-formedness ($\JudgeExnTyWff{d}{\KiEnv}{\ExnTy}$)}
    \label{fig-exception-type-well-formed}
\end{figure}

The exception set expressions $\Exn$ and their kinds $\Kind$ are an instance of the \mbox{$\LambdaUnion$-calculus}, where exception set expressions are terms and kinds are the types. Two exception set expressions are considered equivalent if they are convertible as $\LambdaUnion$-terms, which is to say that they reduce to the same normal form.

The type system resembles \SystemFw \cite{Girard1972} in that we have quantification, abstraction and application at the type level. A key difference is that abstraction and application are restricted to the effects ($\ClassExn$) and cannot be used in the types ($\ClassExnTy$) directly.
Quantification on the other hand is resticted to the types, over effects, and not allowed in the effect itself. The types thus remain predicative.

\subsection{Conservativeness}

\TODOX{Atomicity: |e_1 # e_2 -> ExnTyList e_1 e_2| is not useful, because no introspection}

Any program that is typeable in the underlying type system should also have an exception type: the exception type system is a conservative extension of the underlying type system. Like type systems for strictness or control flow analysis, and unlike type systems for information flow security or dimensional analysis, we do not want to reject any program that is well-typed in the underlying type system, but merely provide more insight in its behavior.

If we furthermore want out type system to be modular---allowing type checking and inference to work on individual modules instead of whole programs---we cannot make any assumptions about the exception types of the arguments that are applied to any function, as the function may be called from outside the module with an argument that also comes from outside the module and which we cannot known anything about.\footnote{\citet{HoldermansHage} call such types \emph{fully flexible}.}

For base and compound types that stand in an argument position their effect and any nested annotations must thus be instantiatable to any arbitrary exception set expression. They must thus be exception set variables that have been universally quantified.

\begin{itemize}
    \item \TODO check all examples types against prototype
    \item \TODO properly typeset example types
    \item \TODO Skolemization and expliciy existential quantication over unification variables?
\end{itemize}

\begin{example}\
\begin{code}
    tail :: forall e_1 e_2. ExnArr (ExnList ExnBool e_1) e_2 (ExnList ExnBool e_1) (e_2 # ExnConE) :&: EmptySet
\end{code}

\begin{code}
    &&  :: forall e_1. ExnArr ExnBool e_1 ((forall e_2. ExnArr ExnBool e_2 ExnBool (e_1 # e_2))) EmptySet :&: EmptySet
\end{code}
\end{example}

For function types that stand in an argument position (the functional parameters of a higher-order function) the situation is slightly more complicated. For the argument of this function we can inductively assume that this will be a universally quantified exception set variable. The result of this function, however, is some exception set expression that depends on the exception set variables that were quantified over in the argument. We cannot simply introduce a new exception set variable here, but must introduce a Skolem function that depends on each of the universally quantified exception set variables.

\begin{example} Consider the higher-order function |apply| that applies its first argument to the second.
% apply : A e2:E. A e3:E=>E.
%           (A e1:E. bool<e1> --<e2>-> bool<e3 e2>) ->
%               A e4:E. bool<e4> -> bool<e2 + e3 e4>
\begin{code}
    apply  ::   forall e_2 : EXN. forall e_3 : EXN => EXN.
                  ExnArrA ((forall e_1 : EXN. ExnArr ExnBool e_1 ExnBool (e_3 e_1))) e_2
                    (ExnArrB ((forall e_4 : EXN. ExnArr ExnBool e_4 ExnBool (e_2 # e_3 e_4))) ExnEmpty)
           :&:  ExnEmpty
    apply  =  LAMBDA f (LAMBDA x (f x))
\end{code}
The first, functional, argument of |apply| has exception type |forall e_1 :: EXN. ExnArr ExnBool e_1 ExnBool (e_3 e_1)| and effect |e_2|. It can be instantiated with any function that accepts an argument annotated with any exception set effect, and produces a result annotated with some exception set effect depending on the exception set effect of the argument; the function closure itself may raise any exception. All functions of underlying type |Bool -> Bool| satisfy these constraints, so they do not really constrain us in any way.

As |e_1| has been quantified over only the exception set operator~|e_3| and the effect |e_2| are left free. We quantify over them outside the outer function space constructor, allowing them to appear in the annotation |e_2 # e_3 e_4| in the result. The exception set operator |e_3| is now applied to |e_4|, as the application |f x| will instantiate the quantified exception set variable |e_1| to |e_4|.
\end{example}

%format CrashB2B = "\TmCrash{\TyBool\to\TyBool}{\ExnLblE}"
\begin{example}
    Exception types are not invariant under $\eta$-conversion. The term
    \savecolumns
    \begin{code}
        LAMBDA (x :: Bool) (CrashB2B x)  :: forall e : EXN. ExnTyArrT ExnBool e ExnBool ExnConE EmptySet
    \end{code}
    does not have the same exception type as the $\eta$-equivalent term
    \restorecolumns
    \begin{code}
        CrashB2B                         :: forall e : EXN. ExnTyArrT ExnBool e ExnBool EmptySet ExnConE
    \end{code}
    We cannot observe a difference between these terms by applying an argument to them
    \begin{code}
        (LAMBDA (x :: Bool) (CrashB2B x))  True  :: ExnBool :&: ExnConE
        CrashB2B                           True  :: ExnBool :&: ExnConE
    \end{code}
    but we can by forcing the closure
    \begin{code}
        (LAMBDA (x :: Bool) (CrashB2B x))  seq  True  :: ExnBool :&: EmptySet
        CrashB2B                           seq  True  :: ExnBool :&: ExnConE
    \end{code}
\end{example}

\subsection{Least exception types}

\TODO

\subsection{Exception type completion}

During exception type inference we will want to compute the least constraint exception type that erases to a given underlying type.

\begin{figure*}[h]
    \begin{gather*}
        \Rule{C-Bool}
             {}
             {\JudgeComplete{\KindEnv{i}}
                            {\TyBool}
                            {\ExnTyBool}
                            {\ExnVar\ \overline{\ExnVar_i}}
                            {\ExnVar :: \overline{\Kind_i\KindArr}\KindEXN}
             }
        \HOR
        \Rule{C-List}
             {\JudgeComplete{\KindEnv{i}}
                            {\Ty}
                            {\ExnTy}
                            {\Exn}
                            {\KindEnv{j}}
             }
             {\JudgeComplete{\KindEnv{i}}
                            {\TyList{\Ty}}
                            {\ExnTyList{\ExnTy}{\Exn}}
                            {\ExnVar\ \overline{\ExnVar_i}}
                            {\ExnVar :: \overline{\Kind_i\KindArr}%
                                \KindEXN, \KindEnv{j}}
             }
        \VER
        \Rule{C-Arr}
             {\JudgeComplete{}
                            {\Ty_1}
                            {\ExnTy_1}
                            {\Exn_1}
                            {\KindEnv{j}}
              \quad
              \JudgeComplete{\KindEnv{i},\KindEnv{j}}
                            {\Ty_2}
                            {\ExnTy_2}
                            {\Exn_2}
                            {\KindEnv{j}}
             }
             {\JudgeComplete{\KindEnv{i}}
                            {\TyArr{\Ty_1}{\Ty_2}}
                            {\ExnForall{\overline{\ExnVar_j :: \Kind_j}}\left(\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}\right)}
                            {\ExnVar\ \overline{\ExnVar_i}}
                            {\ExnVar :: \overline{\Kind_j\KindArr}%
                                \KindEXN, \KindEnv{k}}
             }
    \end{gather*}
    \caption{Type completion ($\JudgeComplete{\KindENV}{\Ty}{\ExnTy}{\Exn}{\KindENV'}$)}
\end{figure*}

\subsection{Subtyping}

\begin{itemize}
    \item Is \CiteRule{S-Refl} an admissable/derivable rule, or should we drop \CiteRule{S-Bool} and \CiteRule{S-Int}?
\end{itemize}

\begin{figure}[h]
    \begin{gather*}
        \Rule{S-Refl}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy}}
        \quad
        \Rule{S-Trans}
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_2}
              \quad
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_3}
             }
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_3}}
        \\[1.5ex]
        \Rule{S-Bool}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnBool}{\ExnBool}}
        \quad
        \Rule{S-Int}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnInt}{\ExnInt}}
        \\[1.5ex]
        \Rule{S-Arr}
             {\begin{gathered}
              \JudgeSubTy{\KiEnv}{\ExnTy_1^\prime}{\ExnTy_1}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn_1^\prime}{\Exn_1}
                \\
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_2^\prime}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn_2}{\Exn_2^\prime}
              \end{gathered}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}
                         {\ExnTyArr{\ExnTy_1^\prime}{\Exn_1^\prime}{\ExnTy_2^\prime}{\Exn_2^\prime}}
             }
        \\[1.5ex]
        \Rule{S-List}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy^\prime}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn}{\Exn^\prime}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyList{\ExnTy}{\Exn}}
                         {\ExnTyList{\ExnTy^\prime}{\Exn^\prime}}
             }
        \VER
        \Rule{S-Forall}
             {\JudgeSubTy{\KiEnv, \ExnVar : \Kind}{\ExnTy_1}{\ExnTy_2}}
             {\JudgeSubTy{\KiEnv}
                         {\ExnForall{\ExnVar : \Kind}{\ExnTy_1}}
                         {\ExnForall{\ExnVar : \Kind}{\ExnTy_2}}
             }
    \end{gather*}
\caption{Subtyping}
\end{figure}

\begin{itemize}

    \item Possibly useful lemma: $\ExnTy_1 = \ExnTy_2 \iff \ExnTy_1 \leq \ExnTy_2 \land \ExnTy_2 \leq \ExnTy_1$.

\end{itemize}

\subsection{Declarative exception type system}

\begin{figure*}[h!]
    \begin{gather*}
        \Rule{T-Var}
             {}
             {\JudgeExnTy{\TyEnv, \TmVar : \ExnTy\ \&\ \Exn}
                         {\KiEnv}
                         {\TmVar}
                         {\ExnTy}
                         {\Exn}
             }
        \HOR
        \Rule{T-Con}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCon{\Ty}}
                         {\BottomTy{\Ty}}
                         {\ExnEmpty}
             }
        \HOR
        \Rule{T-Crash}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCrash{\Ty}{\ExnLbl}}
                         {\BottomTy{\Ty}}
                         {\ExnCon{\ExnLbl}}
             }
        \VER
        \Rule{T-Abs}
             {\JudgeExnTy{\TyEnv, \TmVar : \ExnTy_1\ \&\ \Exn_1}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy_2}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAbsExn{\TmVar}{\ExnTy_1}{\Exn_1}{\Tm}}
                         {\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}
                         {\ExnEmpty}
             }
        \HOR
        \Rule{T-AnnAbs}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv, \ExnVar : \Kind}
                         {\Tm}
                         {\ExnTy}
                         {\Exn}
              \quad
              \ExnVar \notin \fv{\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAnnAbs{\ExnVar}{\Kind}{\Tm}}
                         {\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}
                         {\Exn}
             }
        \VER
        \Rule{T-App}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTyArr{\ExnTy_2}{\Exn_2}{\ExnTy}{\Exn}}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy_2}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmApp{\Tm_1}{\Tm_2}}
                         {\ExnTy}
                         {\Exn}
             }
        \HOR
        \Rule{T-AnnApp}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}
                         {\Exn}
              \quad
              \JudgeExn{\KiEnv}
                       {\Exn_2}
                       {\Kind}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAnnApp{\Tm_1}{\Exn_2}}
                         {\Subst{\Exn_2}{\ExnVar}{\ExnTy}}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Fix}
             {\begin{gathered}
              \JudgeSubExn{\KiEnv}{\Exn^\prime}{\Exn}
              \quad
              \JudgeSubExn{\KiEnv}{\Exn^{\prime\prime}}{\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTyArr{\ExnTy}{\Exn^\prime}{\ExnTy}{\Exn^\prime}}
                         {\Exn^{\prime\prime}}
              \end{gathered}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmFix{\Tm}}
                         {\ExnTy}
                         {\Exn}
             }
        \VER
        \Rule{T-Op}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnInt}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnInt}
                         {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmOp{\Tm_1}{\Tm_2}}
                         {\ExnBool}
                         {\Exn}
             }
        \HOR
        \Rule{T-Seq}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTy_1}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy_2}
                         {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmSeq{\Tm_1}{\Tm_2}}
                         {\ExnTy_2}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-If}
             {\begin{gathered}
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnBool}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_3}
                         {\ExnTy}
                         {\Exn}
              \end{gathered}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                         {\ExnTy}
                         {\Exn}
             }             
        \\[1.5ex]
        \Rule{T-Nil}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmNil{\Ty}}
                         {\ExnTyList{\BottomTy{\Ty}}{\ExnEmpty}}
                         {\ExnEmpty}
             }
        \HOR
        \Rule{T-Cons}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTy}
                         {\Exn_1}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTyList{\ExnTy}{\Exn_1}}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCons{\Tm_1}{\Tm_2}}
                         {\ExnTyList{\ExnTy}{\Exn_1}}
                         {\Exn_2}
             }
        \\[1.5ex]
        \Rule{T-Case}
             {\begin{gathered}
                  \JudgeExnTy{\TyEnv}
                             {\KiEnv}
                             {\Tm_1}
                             {\ExnTyList{\ExnTy_1}{\Exn_1}}
                             {\Exn^\prime}
                  \quad
                  \JudgeExnTy{\TyEnv}
                             {\KiEnv}
                             {\Tm_2}
                             {\ExnTy}
                             {\Exn}
                  \quad
                  \JudgeExnTy{\TyEnv, \TmVar_1 : \ExnTy_1\ \&\ \Exn_1, \TmVar_2 : \ExnTyList{\ExnTy_1}{\Exn_1}\ \&\ \Exn^\prime}
                             {\KiEnv}
                             {\Tm_3}
                             {\ExnTy}
                             {\Exn}
                    \quad
                    \JudgeSubExn{\KiEnv}{\Exn^\prime}{\Exn}
              \end{gathered}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                         {\ExnTy}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Sub}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy^\prime}
                         {\Exn^\prime}
              \quad
              \JudgeSubTy{\KiEnv}
                         {\ExnTy^\prime}
                         {\ExnTy}
              \quad
              \JudgeSubExn{\KiEnv}
                          {\Exn^\prime}
                          {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy}
                         {\Exn}
             }
    \end{gather*}
    \caption{Declarative type system ($\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$)}    
\end{figure*}

\begin{itemize}

    \item In T-Abs and T-AnnAbs, should the term-level term-abstraction also have an explicit effect annotation?

    \item In T-AnnAbs, might need a side condition stating that $\ExnVar$ is not free in $\KiEnv$.

    \item In T-App, note the double occurence of $\Exn$ when typing $\Tm_1$. Is subeffecting sufficient here? Also note that we do \emph{not} expect an exception variable in the left-hand side annotation of the function space constructor.
    
    \item In T-AnnApp, note the substitution. We will need a substitution lemma for annotations.
    
    \item In T-Fix, the might be some universal quantifiers in our way. Do annotation applications in $\Tm$ take care of this, already? Perhaps we do need to change $\TmFix{\Tm}$ into a binding construct to resolve this? Also, there is some implicit subeffecting going on between the annotations and effect.
    
    \item In T-Case, note the use of explicit subeffecting. Can this be done using implicit subeffecting?
    
    \item For T-Sub, should we introduce a term-level coercion, as in Dussart--Henglein--Mossin? We now do shape-conformant subtyping, is subeffecting sufficient?
    
    \item Do we need additional kinding judgements in some of the rules? Can we merge the kinding judgement with the subtyping and/or -effecting judgement? Kind-preserving substitutions.
    
\end{itemize}

\subsection{Type elaboration system}

\begin{itemize}

    \item \TODOX{Type erasure relation}

    \item In \CiteRule{T-App} and {T-Fix}, note that there are substitutions in the premises of the rules. Are these inductive? (Probably, as these premises are not ``recursive'' ones.)

\end{itemize}

\begin{figure*}[h]
    \begin{gather*}
        \Rule{T-Var}
             {}
             {\JudgeElab{\TyEnv, \TmVar : \ExnTy\ \&\ \Exn}
                        {\KiEnv}
                        {\TmVar}
                        {\TmVar}
                        {\ExnTy}
                        {\Exn}
             }
        \HOR
        \Rule{T-Con}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCon{\Ty}}
                        {\TmCon{\Ty}}
                        {\BottomTy{\Ty}}
                        {\ExnEmpty}
             }
        \quad
        \Rule{T-Crash}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCrash{\Ty}{\ExnLbl}}
                        {\TmCrash{\Ty}{\ExnLbl}}
                        {\BottomTy{\Ty}}
                        {\ExnCon{\ExnLbl}}
             }
        \\[1.5ex]
        \Rule{T-Abs}
             {\begin{gathered}
                \JudgeTyElab{\KiEnv, \overline{\ExnVar_i : \Kind_i}}
                            {\ExnTy_1}
                            {\Ty_1}
                \quad
                \JudgeKind{\KiEnv, \overline{\ExnVar_i : \Kind_i}}
                          {\Exn_1}
                          {\KindEXN}
                \quad
                \JudgeElab{\TyEnv, x : \ExnTy_1\ \&\ \Exn_1}
                          {\KiEnv, \overline{\ExnVar_i : \Kind_i}}
                          {\Tm}
                          {\Tm^\prime}
                          {\ExnTy_2}
                          {\Exn_2}
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmAbs{\TmVar}{\Ty_1}{\Tm}}
                        {\TmAnnAbsS{\ExnVar_i}{\Kind_i}{\TmAbsExn{\TmVar}{\ExnTy_1}{\Exn_1}{\Tm^\prime}}}
                        {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}}
                        {\ExnEmpty}
             }
        \\[1.5ex]
        \Rule{\TODO{T-App}}
             {\begin{gathered}
                \JudgeSubTy{\KiEnv}
                           {\ExnTy_2}
                           {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                \quad
                \JudgeSubExn{\KiEnv}
                            {\Exn_2}
                            {\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}
                \quad
                \overline{
                    \JudgeKind{\KiEnv}
                              {\Exn_i}
                              {\Kind_i}
                }
                \\
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm_1}
                          {\Tm_1^\prime}
                          {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy}{\Exn}}}
                          {\Exn^\prime}
                \quad
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm_2}
                          {\Tm_2^\prime}
                          {\ExnTy_2}
                          {\Exn_2}
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmApp{\Tm_1}{\Tm_2}}
                        {\TmApp{\TmAnnApp{\Tm_1^\prime}{\overline{\Exn_i}}}{\Tm_2^\prime}}
                        {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                        {\ExnUnion{\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}{\Exn^\prime}}
             }
        \\[1.5ex]
        \Rule{T-Fix}
             {\begin{gathered}
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm}
                          {\Tm^\prime}
                          {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy}{\Exn}{\ExnTy^\prime}{\Exn^\prime}}}
                          {\Exn^{\prime\prime}}
                \quad
                \JudgeSubTy{\KiEnv}
                           {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy^\prime}}
                           {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                \quad
                \JudgeSubExn{\KiEnv}
                            {\SubstS{\Exn_i}{\ExnVar_i}{\Exn^\prime}}
                            {\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}
                \quad
                \overline{
                    \JudgeKind{\KiEnv}
                              {\Exn_i}
                              {\Kind_i}
                }
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmFix{\Tm}}
                        {\TmAnnApp{\TmFix{\Tm^\prime}}{\overline{\Exn_i}}}
                        {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                        {\ExnUnion{\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}{\Exn^{\prime\prime}}}
             }
        \\[1.5ex]
        \Rule{T-Op}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnInt}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnInt}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmOp{\Tm_1}{\Tm_2}}
                        {\TmOp{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnBool}
                        {\ExnUnion{\Exn_1}{\Exn_2}}
             }
        \HOR
        \Rule{T-Seq}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnTy_1}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTy_2}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmSeq{\Tm_1}{\Tm_2}}
                        {\TmSeq{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnTy_2}
                        {\ExnUnion{\Exn_1}{\Exn_2}}
             }
        \\[1.5ex]
        \Rule{T-If}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnBool}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTy_2}
                        {\Exn_2}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_3}
                        {\Tm_3^\prime}
                        {\ExnTy_3}
                        {\Exn_3}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                        {\TmIf{\Tm_1^\prime}{\Tm_2^\prime}{\Tm_3^\prime}}
                        {\TyJoin{\ExnTy_2}{\ExnTy_3}}
                        {\ExnUnion{\Exn_1}{\ExnUnion{\Exn_2}{\Exn_3}}}
             }             
        \\[1.5ex]
        \Rule{T-Nil}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmNil{\Ty}}
                        {\TmNil{\Ty}}
                        {\ExnTyList{\BottomTy{\Ty}}{\ExnEmpty}}
                        {\ExnEmpty}
             }
        \HOR
        \Rule{T-Cons}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnTy_1}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTyList{\ExnTy_1^\prime}{\Exn_1^\prime}}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCons{\Tm_1}{\Tm_2}}
                        {\TmCons{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnTyList{\TyJoin{\ExnTy_1}{\ExnTy_1^\prime}}{\ExnUnion{\Exn_1}{\Exn_1^\prime}}}
                        {\Exn_2}
             }
        \\[1.5ex]
        \Rule{T-Case}
             {\begin{gathered}
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_1}
                            {\Tm_1^\prime}
                            {\ExnTyList{\ExnTy_1}{\Exn_1}}
                            {\Exn_1^\prime}
                  \quad
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_2}
                            {\Tm_2^\prime}
                            {\ExnTy_2}
                            {\Exn_2}
                  \quad
                  \JudgeElab{\TyEnv, \TmVar_1 : \ExnTy_1\ \&\ \Exn_1, \TmVar_2 : \ExnTyList{\ExnTy_1}{\Exn_1}\ \&\ \Exn_1^\prime}
                            {\KiEnv}
                            {\Tm_3}
                            {\Tm_3^\prime}
                            {\ExnTy_3}
                            {\Exn_3}
              \end{gathered}
             }
             {\begin{multlined}
                  \JudgeElab{\TyEnv}
                             {\KiEnv}                 
                             {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                             {\TmCase{\Tm_1^\prime}{\Tm_2^\prime}{\TmVar_1}{\TmVar_2}{\Tm_3^\prime}}
                             {\TyJoin{\ExnTy_2}{\ExnTy_3}}
                             {\ExnUnion{\Exn_1^\prime}{\ExnUnion{\Exn_2}{\Exn_3}}}
              \end{multlined}
             }
    \end{gather*}
    \caption{Syntax-directed type elaboration system ($\JudgeElab{\TyEnv}{\KiEnv}{\Tm}{\Tm^\prime}{\ExnTy}{\Exn}$)}    
\end{figure*}

\begin{itemize}

 \item For T-Fix: how would a binding fixpoint construct work?

\end{itemize}
