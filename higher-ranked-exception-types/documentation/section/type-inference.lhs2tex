\section{Type inference}\label{section-type-inference-algorithm}

%format reconstruct                 = "\mathcal{R}"
%format complete                    = "\mathcal{C}"
%format instantiate                 = "\mathcal{I}"
%format match                       = "\mathcal{M}"

%format Product (a) (b)             = a "\times " b
%format ClassEnv                    = "\ClassEnv"
%format ClassTy                     = "\ClassTy"
%format env                         = "\TyEnv"
%format kenv                        = "\KiEnv"

%format Var                         = "\TmVar"
%format env_x                       = "\TyEnv_x"

%format (Con (t) (c))               = c "_" t
%format ty                          = "\Ty"
%format Result (a) (b)              = "\langle" a "; " b "\rangle"
%format bottomTy                    = "\BottomTy{\Ty}"
%format ExnEmpty                    = "\ExnEmpty"

%format Crash                       = "\TmCrash{\Ty}{\ExnLbl}"
%format ExnCon                      = "\ExnCon{\ExnLbl}"

%format Abs                         = "\TmAbs{\TmVar}{\Ty}{\Tm}"
%format (Tuple  (x) (y))            = "\langle" x ";" y "\rangle"
%format (Triple (x) (y) (z))        = "\langle" x ";" y ";" z "\rangle"
%format ExnTy                       = "\ExnTy"
%format ExnTy'                      = "\ExnTy^\prime"
%format ExnTy''                     = "\ExnTy^{\prime\prime}"
%format ExnTy_0                     = "\ExnTy_0"
%format ExnTy_1                     = "\ExnTy_1"
%format ExnTy_2                     = "\ExnTy_2"
%format ExnTy_2'                    = "\ExnTy_2^\prime"
%format ExnTy_3                     = "\ExnTy_3"
%format ExnVar'                     = "\ExnVar^{\prime}"
%format ExnVar_1                    = "\ExnVar_1"
%format ExnVar_2'                   = "\ExnVar_2^\prime"
%format Exn                         = "\Exn"
%format Exn'                        = "\Exn^\prime"
%format Exn''                       = "\Exn^{\prime\prime}"
%format Exn_0                       = "\Exn_0"
%format Exn_1                       = "\Exn_1"
%format Exn_1'                      = "\Exn_1^\prime"
%format Exn_2                       = "\Exn_2"
%format Exn_2'                      = "\Exn_2^\prime"
%format Exn_3                       = "\Exn_3"
%format kenv'                       = "\overline{\ExnVar_i : \Kind_i}"
%format EmptyEnv                    = "\emptyset"
%format (extendTyEnv env x (t) e)   = env ", " x " : " t "\ \&\ " e
%format Tm                          = "\Tm"
%format tm                          = "\Tm"
%format tm_1
%format tm_2
%format tm_3
%format ExnTyBool                   = "\ExnBool"
%format ExnTyInt                    = "\ExnInt"
%format ExnTyArr (a) (b) (c) (d)    = "\ExnTyArr{" a "}{" b "}{" c "}{" d "}"
%format ExnForall (a) (b)           = "\ExnForall{" a "}{" b "}"

%format App                         = "\TmApp{\Tm_1}{\Tm_2}"
%format subst                       = "\theta"
%format Subst (x) (y)               = "\left[" x "\mapsto " y "\right]"
%format ExnUnion (a) (b)            = "\ExnUnion{" a "}{" b "}"
%format applySubst (x)              = "\theta " x
%format (simplify (kenv) (x))       = "\llfloor " x "\rrfloor_{" kenv "}"

%format Fix                         = "\TmFix{\Tm}"
%format Exn_i                       = "\Exn_i"
%format Exn_i1                      = "\Exn_{i+1}"
%format Exn_im                      = "\Exn_{i-1}"
%format Exn_w                       = "\Exn_\omega"
%format Exn_w'                      = "\Exn_\omega^\prime"
%format ExnTy_i                     = "\ExnTy_i"
%format ExnTy_i1                    = "\ExnTy_{i+1}"
%format ExnTy_im                    = "\ExnTy_{i-1}"
%format ExnTy_w                     = "\ExnTy_\omega"
%format ExnTy_w'                    = "\ExnTy_\omega^\prime"
%format bottomTyU                   = "\BottomTy{\lfloor \ExnTy^\prime \rfloor}"
%format until                       = "\mathbf{until}"
%format return                      = "\mathbf{return}"

%format BinOp                       = "\TmOp{\Tm_1}{\Tm_2}"
%format Seq                         = "\TmSeq{\Tm_1}{\Tm_2}"

%format If                          = "\TmIf{\Tm_1}{\Tm_2}{\Tm_3}"
%format ExnTyJoin a b               = "\TyJoin{" a "}{" b "}"

%format Nil                         = "\TmNil{\Ty}"
%format ExnTyList a (b)             = "\ExnTyList{" a "}{" b "}"

%format Cons                        = "\TmCons{\Tm_1}{\Tm_2}"
%format Case                        = "\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}"
%format Var_1
%format Var_2
\begin{figure}[h!]
\begin{code}
    reconstruct :: Product ClassTyEnv (Product ClassKiEnv ClassTm) -> Product ClassExnTy ClassExn

    reconstruct env kenv Var         =  env_x

    reconstruct env kenv (Con ty c)  =  Result bottomTy ExnEmpty

    reconstruct env kenv Crash       =  Result bottomTy ExnCon

    reconstruct env kenv (Abs)       =
        let     Triple ExnTy_1 ExnVar_1 kenv'  =  complete EmptyEnv ty
                                             
                Tuple ExnTy_2 Exn_2            =  reconstruct ((extendTyEnv env Var ExnTy_1 ExnVar_1)) (kenv,kenv') Tm
        in      Result (ExnForall kenv' (ExnTyArr ExnTy_1 ExnVar_1 ExnTy_2 Exn_2)) ExnEmpty

    reconstruct env kenv (App)       =
        let     Tuple ExnTy_1 Exn_1                                    = reconstruct env kenv tm_1
                Tuple ExnTy_2 Exn_2                                    = reconstruct env kenv tm_2
                Tuple (ExnTyArr ExnTy_2' ExnVar_2' ExnTy' Exn') kenv'  = instantiate ExnTy_1
                subst                                                  = Subst ExnVar_2' Exn_2 . match EmptyEnv ExnTy_2 ExnTy_2'
        in      Tuple (simplify kenv (applySubst ExnTy')) (simplify kenv (ExnUnion (applySubst Exn') (Exn_1)))

    reconstruct env kenv (Fix) =
        let     Tuple ExnTy Exn                                      = reconstruct env kenv tm
                Tuple (ExnTyArr ExnTy' ExnVar' ExnTy'' Exn'') kenv'  = instantiate ExnTy
        in      Triple ExnTy_0 Exn_0 i  <- Triple bottomTyU ExnEmpty 0
                do  subst                     <- Subst ExnVar' Exn_i . match EmptyEnv ExnTy_i ExnTy'
                    Triple ExnTy_i1 Exn_i1 i  <- Triple  (simplify kenv (applySubst ExnTy'')) (simplify kenv (applySubst Exn'')) (i+1)
                until (Tuple ExnTy_i Exn_i) == Tuple ExnTy_im Exn_im
                return (Tuple ExnTy_i (simplify kenv (ExnUnion Exn Exn_i)))

    reconstruct env kenv (BinOp) =
        let     Tuple ExnTyInt Exn_1  = reconstruct env kenv tm_1
                Tuple ExnTyInt Exn_2  = reconstruct env kenv tm_2
        in      Tuple ExnTyBool (simplify kenv (ExnUnion Exn_1 Exn_2))

    reconstruct env kenv (Seq) =      
        let     Tuple ExnTy_1 Exn_1  = reconstruct env kenv tm_1
                Tuple ExnTy_2 Exn_2  = reconstruct env kenv tm_2
        in      Tuple ExnTy_2 (simplify kenv (ExnUnion Exn_1 Exn_2))

    reconstruct env kenv (If) =
        let     Tuple ExnTyBool Exn_1  = reconstruct env kenv tm_1
                Tuple ExnTy_2 Exn_2    = reconstruct env kenv tm_2
                Tuple ExnTy_3 Exn_3    = reconstruct env kenv tm_3
        in      Tuple (simplify kenv (ExnTyJoin ExnTy_2 ExnTy_3)) (simplify kenv (ExnUnion Exn_1 (ExnUnion Exn_2 Exn_3)))

    reconstruct env kenv Nil         =  Result (ExnTyList bottomTy ExnEmpty) ExnEmpty

    reconstruct env kenv (Cons) =  
        let     Tuple ExnTy_1 Exn_1                     = reconstruct env kenv tm_1
                Tuple (ExnTyList ExnTy_2 Exn_2') Exn_2  = reconstruct env kenv tm_2
        in      Tuple (simplify kenv (ExnTyList (ExnTyJoin ExnTy_1 ExnTy_2) (ExnUnion Exn_1 Exn_2'))) Exn_2

    reconstruct env kenv (Case) =     
        let     Tuple (ExnTyList ExnTy_1 Exn_1') Exn_1   = reconstruct env kenv tm_1
                Tuple ExnTy_2 Exn_2                    = reconstruct ((extendTyEnv (extendTyEnv env Var_1 ExnTy_1 Exn_1') Var_2 (ExnTyList ExnTy_1 Exn_1') Exn_1)) kenv tm_2
                Tuple ExnTy_3 Exn_3                    = reconstruct env kenv tm_3
        in      Tuple (simplify kenv (ExnTyJoin ExnTy_2 ExnTy_3)) (simplify kenv (ExnUnion Exn_1 (ExnUnion Exn_2 Exn_3)))
\end{code}
\caption{Type inference algorithm}
\end{figure}

\begin{itemize}

    \item In R-App and R-Fix: check that the fresh variables generated by |instantiate| are subsituted away by the substitution |subst| created by |match|. Also, we don't need those variables in the algorithm if we don't generate the elaborated term.

    \item In R-Fix we could get rid of the auxillary underlying type function if the fixpoint construct was replaced with a binding variant with an explicit type annotation.
    
    \item For R-Fix, make sure the way we handle fixpoints of exceptional value in a manner that is sound w.r.t. to the operational semantics we are going to give to this.

    \item Note that we do not construct the elaborated term, as it is not useful other than for metatheoretic purposes.
    
    \item Lemma: The algorithm maintains the invariant that exception types and exceptions are in normal form. 

\end{itemize}

\subsection{Polymorphic abstraction}

The cases for abstraction and application are handled similarly to corresponding cases in \citet{HoldermansHage}.

In the case of abstractions, we first complete the type of the bound variable to an exception type using the auxiliary procedure |complete :: Product ClassKiEnv ClassTy -> Product ClassExnTy (Product ClassExn ClassKiEnv)|. This procedure is a functional interpretation of the type completion relation $\JudgeComplete{\KindENV}{\Ty}{\ExnTy}{\Exn}{\KindENV'}$, where the first two arguments $\KindENV$ and $\Ty$ are taken to be the domain and the last three arguments $\ExnTy$, $\Exn$ and $\KindENV'$ are taken to be the range. Next we infer the exception type of the body of the abstraction under the assumption that the bound variable has the just complete exception type. Finally we quantify over all free variables introduced by the completion procedure.

In the case applications, we instantiate ($\mathcal{I}$) all quantified variables of the exception type of $t_1$ with fresh exception variables. Next we use the auxiliary procedure $\mathcal{M}$ to find a matching substitution between the exception types of the formal and the actual parameters.

%format kienv         = "\KindENV"
%format matchList1    = "\ExnTyList{\ExnTy_1}{\ExnVar}"
%format matchList2    = "\ExnTyList{\ExnTy_2}{\Exn}"
%format matchArr1     = "(\ExnTyArr{\ExnTy_1}{\ExnVar}{\ExnTy_2}{\ExnPat})"
%format matchArr2     = "(\ExnTyArr{\ExnTy_1}{\ExnVar}{\ExnTy_2'}{\Exn})"
%format matchForall1  = "(\ExnTyForall{\ExnVar}{\Kind}{\ExnTy_1})"
%format matchForall2  = "(\ExnTyForall{\ExnVar}{\Kind}{\ExnTy_2})"
\begin{figure}[ht]
    \begin{code}
        match  ::  Product ClassKiEnv (Product ClassExnTy ClassExnTy) -> ClassSubst
        match  kienv  ExnTyBool     ExnTyBool     = EmptyEnv
        match  kienv  matchList1    matchList2    = Subst e Exn . match kienv ExnTy_1 ExnTy_2
        match  kienv  matchForall1  matchForall2  = match (kienv, e : ki) ExnTy_1 ExnTy_2
        match  kienv  matchArr1      matchArr2
                =  noot
    \end{code}
    \caption{Exception type matching \cite{HoldermansHage}}
\end{figure}

The interesting case of exception type matching is the case for function types, where we perform pattern unification of the exception annotations. The produced substitution $\theta$ covers all variables freshly introduced by the instantiation procedure $\mathcal{I}$. Finally, we apply the substitution $\theta$ to result exception type and effect of $t_1$.

\subsection{Polymorphic recursion}

\begin{itemize}

    \item \TODO You \emph{don't} get polymorphic recursion ``for free''!

\end{itemize}

\begin{example}[Dussart, Henglein, Mossin]
    Consider the term
    \begin{code}
        dhm  ::  Bool -> Bool -> Bool
        dhm  =   FIX f (Bool -> Bool -> Bool)
                    (LAMBDA (x :: Bool) (LAMBDA (y :: Bool) (if x then True else f y x)))
    \end{code}

    Algorithm $\mathcal{R}$ will infer the exception type (and elaborated term)

%    \begin{code}
%        dhm  ::  forall e_1:EXN. ExnTyArrS ExnTyBool e_1 (forall e_2:EXN. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1 # e_2) ExnEmpty) ExnEmpty
%        dhm  =   FIX (f) (forall e_1:EXN. ExnTyArrS ExnTyBool e_1 (forall e_2:EXN. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1 # e_2) ExnEmpty) ExnEmpty)
%                    (LLAMBDA (e_1 : EXN) (LAMBDA (x :: ExnTyBool :&: e_1) (LLAMBDA (e_2 : EXN) (PLAMBDA (y :: ExnTyBool :&: e_2))))
%                        if x then True else f (Angled e_2) y (Angled e_1) x
%    \end{code}    

    \begin{code}
        dhm  ::  forall e_1. ExnTyArrS ExnTyBool e_1 (forall e_2. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1 # e_2) ExnEmpty) ExnEmpty
        dhm  =   FIX (f) (forall e_1. ExnTyArrS ExnTyBool e_1 (forall e_2. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1 # e_2) ExnEmpty) ExnEmpty)
                    (LLAMBDA (e_1 : EXN) (LAMBDA (x :: ExnTyBool :&: e_1) (LLAMBDA (e_2 : EXN) (PLAMBDA (y :: ExnTyBool :&: e_2))))
                        if x then True else f (Angled e_2) y (Angled e_1) x
    \end{code}
    
    First let's think about why the elaborated term is type-correct. 
    
    \begin{align*}
        x &: \ExnBool\ \&\ e_1 \\
        \TmTrue &: \ExnBool\ \&\ \emptyset \\
        f \langle e_2\rangle\ y\ \langle e_1\rangle\ x &: \ExnBool\ \&\ e_2 \cup e_1
    \end{align*}
    
    \[ \TmIf{x}{\TmTrue}{f \langle e_2\rangle\ y\ \langle e_1\rangle\ x} : \ExnBool \sqcup \ExnBool\ \&\ e_1 \cup \emptyset \cup e_2 \cup e_1 \]
    
    By commutativity and idempotence of the union operator and the empty set begin the unit with respect to it, this reduces to:
    \[ \TmIf{x}{\TmTrue}{f \langle e_2\rangle\ y\ \langle e_1\rangle\ x} : \ExnBool\ \&\ e_1 \cup e_2 \]

    Of course, checking type-correctness is easier than type-inference. To infer the type of the fixed-point |f| we have to ``guess'' a type for it. How do we guess this type? We first try the least exception type $\bot_{\TyBool\to\TyBool\to\TyBool}$:
    \begin{code}
        forall e_1. ExnTyArrS ExnTyBool e_1 (forall e_2. ExnTyArrT ExnTyBool e_2 ExnTyBool (ExnEmpty) ExnEmpty) ExnEmpty
    \end{code}
    If we continue inferring the type with this guess, then we end up with the larger type (larger than the guess):
    \begin{code}
        forall e_1. ExnTyArrS ExnTyBool e_1 (forall e_2. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1) ExnEmpty) ExnEmpty
    \end{code}
    We try inferring the type again, but now start with this type as our guess instead of the least type. We end up with a yet larger type:
    \begin{code}
        forall e_1. ExnTyArrS ExnTyBool e_1 (forall e_2. ExnTyArrT ExnTyBool e_2 ExnTyBool (e_1 # e_2) ExnEmpty) ExnEmpty
    \end{code}
    Finally, if we take this type as our guess, we will get back the exact same type and conclude we have reached a fixed point.
\end{example}

\begin{example}[Glynn, Stuckey, Sulzman]
\end{example}


\subsection{Complexity}

There are three aspects that affect the run-time complexity of the algorithm: the complexity of the underlying type system, reduction of the effects, and the fixpoint-iteration in the inference step of the $\mathbf{fix}$-construct.

We have a simply typed underlying type system, but if we would extend this to full Hindley--Milner, then it is possible for types to become exponentially larger than terms \cite{Mairson:1989:DMT:96709.96748,Kfoury:1990:MTD:101856.101870}. The effects are $\LambdaUnion$-terms, which contains the simply type $\lambda$-calculus as a special case. Reduction of terms in the simply typed $\lambda$-calculus is not elementary recursive \cite{stat79b}. It is also easy to find an artificial family of terms that requires at least a linear number of iterations to converge on a fixpoint. For these reasons we do not believe the algorithm to have an attractive theoretical bound on time-complexity.

Anecdotal evidence suggests that the practical time-complexity is acceptable, however. Hindley--Milner has almost linear complexity in non-pathological cases. Types do not grow larger than the terms. The same seems to hold for the effects. Reduction of effects takes a small number of steps, as does the convergence of the fixpoint-iteration.
