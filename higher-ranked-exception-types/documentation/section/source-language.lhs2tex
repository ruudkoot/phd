%include ../figure/underlying-type-system.lhs2tex
%include ../figure/operational-semantics.lhs2tex
%include ../figure/type-completion.lhs2tex

\section{Source language}\label{section-source-language}

Our analysis is applicable to a simple non-strict functional language that supports Boolean, integer and list data types. In this section we'll briefly state its syntax and semantics.

\begin{figure}[ht]
\paragraph{Terms}
\begin{alignat}{2}
\!  \Tm \in \ClassTm &\ ::=\   &&\ \TmVar                   \tag{term variable}     \\
                     &\quad||  &&\ \TmCon{\Ty}              \tag{term constant}     \\
                     &\quad||  &&\ \TmAbs{\TmVar}{\Ty}{\Tm} \tag{term abstraction}  \\
                     &\quad||  &&\ \TmApp{\Tm_1}{\Tm_2}     \tag{term application}  \\
                     &\quad||  &&\ \TmOp{\Tm_1}{\Tm_2}      \tag{operator}          \\
                     &\quad||  &&\ \TmIf{\Tm_1}{\Tm_2}{\Tm_3}\tag{conditional}      \\
                     &\quad||  &&\ \TmCrash{\Ty}{\ExnLbl}   \tag{exception constant}\\
                     &\quad||  &&\ \TmSeq{\Tm_1}{\Tm_2}     \tag{forcing}           \\
                     &\quad||  &&\ \TmFIX{\TmVar}{\Ty}{\Tm} \tag{fixpoint}          \\
                     &\quad||  &&\ \TmNil{\Ty}              \tag{nil constructor}   \\
                     &\quad||  &&\ \TmCons{\Tm_1}{\Tm_2}    \tag{cons constructor}  \\
                     &\quad||  &&\ \TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}
                                                            \tag{list eliminator}
\end{alignat}


\begin{alignat}{2}
\Val \in \ClassVal &\ ::=\  &&\ \TmCon{\Ty}\ ||\ \TmAbs{\TmVar}{\Ty}{\Tm}\ ||\ \TmFIX{\TmVar}{\Ty}{\Tm}\ ||\ \TmNil{\Ty}\ ||\ \TmCons{\Tm_1}{\Tm_2} \notag
\end{alignat}
\begin{alignat}{2}
\ExnVal \in \ClassExnVal &\ ::=\  &&\ \TmCrash{\Ty}{\ExnLbl}\ ||\ \Val \notag
\end{alignat}
\caption{Source language: syntax}
\end{figure}

Missing from the language is a construct to ``catch'' exceptional values. While this may be surprising to programmers familiar with strict languages, it is a common design decision to omit such a construct from the pure fragment of non-strict languages. The omission of such a construct allows for the introduction of a certain amount of non-determinism in the operational semantics of the language---giving more freedom to an optimizing compiler---without breaking referential transparency.

The values of the source language are stratified into non-exceptional values $\Val$ and possibly exceptional values $\ExnVal$.

\subsection{Underlying type system}

The type system of the source language is given for reference in Figure~\ref{figure-underlying-type-system}. This is the \emph{underlying type system} with respect to the type-and-effect system we will present in Section~\ref{section-exception-types} and we will assume that any term we will type in the type-and-effect system is already well-typed in the underlying type system.

\subsection{Operational semantics}

The operational semantics of the source language is given in Figure~\ref{figure-operational-semantics}. Note that there is a small amount of non-determinism in the order of reduction, for example in the derivation rules \CiteRule{E-OpExn$_1$} and \CiteRule{E-OpExn$_2$}.

We do not go as far as having an imprecise exception semantics \cite{PeytonJones:1999:SIE:301618.301637}. For example, if the guard of a conditional evaluates to an exceptional value (\CiteRule{E-IfExn}), we do not continue evaluation of the two branches in exception finding mode.

The reduction rules \CiteRule{E-AnnApp}, \CiteRule{E-AnnAbsApp} are for constructs that will only be introduced in the language in Section~\ref{section-exception-types}. The same holds for the additional annotations on the $\lambda$-abstraction and $\mathbf{fix}$-operator.
