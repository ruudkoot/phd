\section{\ThesisPaper{Motivation}{Introduction}}

An often heard selling point of non-strict functional languages is that they provide strong and expressive type systems that make side-effects explicit. This supposedly makes software more reliable by lessening the mental burden of programmers. Many object-oriented programmers are quite surprised, then, that when they make the transition to a functional language, that they lose a feature their type system formerly did provide: tracking of uncaught exceptions.

There is a good excuse why this feature is missing from the type systems of contemporary non-strict functional languages: in a strict first-order language it is sufficient to annotate each function with a single set of uncaught exceptions the function may throw, in a non-strict higher-order language the situation becomes significantly more complicated. Let us first consider the two aspects ``higher-order'' and ``non-strict'' in isolation:

\begin{description}

    \item [Higher-order functions] The set of exceptions that may be raised by a higher-order function are not given by a fixed set of exceptions, but depends on the set of exceptions that may be raised by the function that is passed as its functional argument. Higher-order functions will thus end up being \emph{exception polymorphic}.
    
    \TODO{concrete example?}
    
    \item [Non-strict evaluation] In non-strictly evaluated languages, exception are not a form of control flow, but a kind of value. Typically the set of values of each type are extended with an \emph{exceptional value} $\bot$ (more commonly denoted $\bot$, but we shall not do so for reasons of ambiguity), or family of exceptional values $\bot^\ell$. This means we do not only need to give all functions an exception-annotated function type, but every expression and exception-annotated type.
    
    \TODO{concrete example?}
\end{description}

Take as an example the |map| function:
\begin{code}
map  ::  forall alpha beta. (alpha -> beta) -> [alpha] -> [beta]
map  =   LAMBDA f (LAMBDA xs (case xs of
                           []      -|> []
                           (y:ys)  -|> f y : map f ys))
\end{code}


\subsection{Overview}

\subsection{Contributions}

\begin{itemize}

    \item A \emph{type system} than precisely tracks the uncaught exceptions using higher-ranked types.
    
    \item An \emph{inference algorithm} that automatically infers such higher-ranked exception types.

\end{itemize}

\paragraph{\TODO}

\begin{itemize}

    \item \TODO Untracked exceptions can break information flow security.

\end{itemize}
