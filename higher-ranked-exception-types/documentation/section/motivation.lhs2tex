\section{\ThesisPaper{Motivation}{Introduction}}

An often heard selling point of non-strict functional languages is that they provide strong and expressive type systems that make side-effects explicit. This supposedly makes software more reliable by lessening the mental burden of programmers. Many object-oriented programmers are quite surprised, then, that when they make the transition to a functional language, that they lose a feature their type system formerly did provide: tracking of uncaught exceptions.

There is a good excuse why this feature is missing from the type systems of contemporary non-strict functional languages: in a strict first-order language it is sufficient to annotate each function with a single set of uncaught exceptions the function may throw, in a non-strict higher-order language the situation becomes significantly more complicated. Let us first consider the two aspects ``higher-order'' and ``non-strict'' in isolation:

\begin{description}

    \item [Higher-order functions] The set of exceptions that may be raised by a higher-order function are not given by a fixed set of exceptions, but depends on the set of exceptions that may be raised by the function that is passed as its functional argument. Higher-order functions will thus end up being \emph{exception polymorphic}.
    
    \item [Non-strict evaluation] In non-strictly evaluated languages, exceptions are not a form of control flow, but a kind of value. Typically the set of values of each type are extended with an \emph{exceptional value} $\lightning$ (more commonly denoted $\bot$, but we shall not do so for reasons of ambiguity), or family of exceptional values $\lightning^\ell$. This means we do not only need to give all functions an exception-annotated function type, but every expression an exception-annotated type.
\end{description}

Now let us consider these two aspects in combination. Take as an example the |map| function:
\begin{code}
map  ::  forall alpha beta. (alpha -> beta) -> [alpha] -> [beta]
map  =   LAMBDA f (LAMBDA xs (case xs of
                           []      -|> []
                           (y:ys)  -|> f y : map f ys))
\end{code}

For each type $\tau$, we denote its exception-annotated type by~$\tau\langle\Exn\rangle$. For function types we will write $\tau_1\langle\Exn_1\rangle \xrightarrow{\Exn} \tau_2\langle\Exn_2\rangle$ instead of $\left(\tau_1\langle\Exn_1\rangle \rightarrow \tau_2\langle\Exn_2\rangle\right)\langle\Exn\rangle$. If $\Exn$ is the empty exception set, then we will omit it completely.

The fully exception-polymorphic and exception-annotated type, or \emph{exception type}, of |map| is\ThesisPaper{\TODO{cramped formatting}}{}
\begin{code}
forall alpha beta e_2 e_3. (forall e_1. ThrowsArr (Throws alpha e_1) (Throws beta (e_2 e_1)) (e_3))
                                           -> (forall e_4 e_5. Throws ([Throws alpha e_4]) e_5 -> Throws ([Throws beta (e_2 e_4 # e_3)]) e_5)
\end{code}

The exception type of the first argument |forall e_1. ThrowsArr (Throws alpha e_1) (Throws beta (e_2 e_1)) (e_3)| states that it can be instantiated with a function that accepts any exceptional value as its argument (as the exception set |e_1| is universally quantified) and returns a possibly exceptional value. In case the return value is exceptional, then it will be one from the exception set |e_2 e_1|. Here |e_2| is an \emph{exception operator}---a function that takes a number of exception sets and exception operators, and transforms it into another exception set, for example by adding a number of new elements to it, or discarding it and returning the empty set. Furthermore, the function itself may be an exceptional value from the exception set |e_3|.

The exception type of the second argument |Throws ([Throws alpha e_4]) e_5| states it should be a list. Any of the elements in the lists may be exception values from the exception set |e_4|. Any of the constructors that form the spine of the list must be exceptional values from the exception set |e_5|.

The result of |map| will be a list with the exception type |Throws ([Throws beta (e_2 e_4 # e_3)]) e_5|. Any constructors in the spine of this list may be exceptional values from the exception set |e_5|, the same exception set as where exceptional values in the spine of the input list could come from. By looking at the definition of |map| we can see why this is the case: |map| will only produce non-exceptional constructors, but the pattern-match on the input list will propagate any exceptional values encountered there. The elements of the list are produced by the function application |f y|. Recall that |f| has the exception type |forall e_1. ThrowsArr (Throws alpha e_1) (Throws beta (e_2 e_1)) (e_3)|. Now one of two things can happen:
    \begin{enumerate}

        \item If |f| is an exceptional function value, then it must be one from the exception set |e_3|. Applying an argument to an exceptional value will cause the exceptional value to be propagated.
        
        \item Otherwise |f| is a non-exceptional value. The argument |y| has exception type |Throws alpha e_4|---it is an element from the input list---and so can only be applied to |f| if we instantiate |e_1| to |e_4| first. If |f y| will produce an exceptional value it will thus be one from the exception set |e_2 e_4|.
        
    \end{enumerate}
To account for both cases we need to take the union of the two exception sets, giving us a value with the exception type \mbox{|Throws beta (e_2 e_4 # e_3)|}.

The get a better feeling of how these exception type and exception operators behave let us see what happens when we apply two different functions to |map|: the identity function |id| and the constant exceptional values |const bottom_E|. These two functions can be given the exception types:
    \begin{code}
                    id              :: forall e_1. ThrowsArr (Throws alpha e_1) (Throws alpha e_1) noexn
                    const bottom_E  :: forall e_1. ThrowsArr (Throws alpha e_1) (Throws beta e_E) noexn
    \end{code}
The term |id| simply propagates its input, so it will also propagate any exceptional values. The term |const bottom_E| discards it input and will always return the exceptional value |bottom_E|. This behavior is also reflected in their exception types.

If we apply |map| to |id| we need to unify the exception type of the formal parameter |forall e_1. ThrowsArr (Throws alpha e_1) (Throws beta (e_2 e_1)) (e_3)| with the exception type of the actual parameter |forall e_1. ThrowsArr (Throws alpha e_1) (Throws alpha e_1) noexn|. This can be accomplished by instantiating |e_3| to |noexn| and |e_2| to |LAMBDA x x|, as \mbox{|(LAMBDA x x) e_1 ---> e_1|}. This gives us the resulting exception type
%\begin{center}
\begin{code}
map id                :: forall alpha e_4 e_5. ThrowsArr (Throws ([Throws alpha e_4]) e_5) (Throws ([Throws alpha (e_4)]) e_5) noexn
\end{code}
%\end{center}
I.e., mapping the identity function over a list will propagate all existing exceptional values in the list and add no new ones.

If we apply |map| to |const bottom_E| we need to unify the exception type of the formal parameter with |forall e_1. ThrowsArr (Throws alpha e_1) (Throws beta e_E) noexn|, which can be accomplished by instantiating |e_3| to |noexn| and |e_2| to |LAMBDA x e_E|, as |(LAMBDA x e_E) e_1 ~> e_E|. This gives us the resulting exception type
%\begin{center}
\begin{code}
map (const bottom_E)  :: forall alpha beta e_4 e_5. ThrowsArr (Throws ([Throws alpha e_4]) e_5) (Throws ([Throws beta (e_E)]) e_5) noexn
\end{code}
%\end{center}
I.e., mapping the constant exceptional value over a list will discard all existing exceptional values from the list and only output non-exceptional values or the exceptional value |bottom_E| as elements of the lists.


\subsection{Overview}

In Section~\ref{section-lambda-union} we will introduce the $\LambdaUnion$-calculus, a simply typed \mbox{$\lambda$-calculus} embellished with an associative, commutative, idempotent and unit (\ACIone) structure. The $\LambdaUnion$-calculus will form language of effects in our type-and-effect system.
Section~\ref{section-source-language} describes the language to which our analysis applies.
In Section~\ref{section-exception-types} we introduce the language of exception types and two type-and-effect systems for deriving exception types for a given term in the source language that is well-typed in the underlying type system: a declarative type system and a syntax-directed elaboration system that also produces an explicitly typed term.
A type inference algorithm for this type-and-effect system is presented in Section~\ref{section-type-inference-algorithm}.
% Finally, we present related work in this area and discuss some direction for future research in Sections~\ref{section-related-work} and~\ref{section-future-research}.

\subsection{Contributions}

% \TODO Elaborate

\begin{itemize}

    \item A \emph{type-and-effect system} that precisely tracks the uncaught exceptions using higher-ranked types.
    
    \item An \emph{inference algorithm} that automatically infers such higher-ranked exception types.

\end{itemize}
