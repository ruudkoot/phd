\section{The $\LambdaUnion$-calculus}

The $\LambdaUnion$-calculus is simply typed $\lambda$-calculus extended with a set-union operator and singleton-set and empty-set constants at the term level.

\paragraph{Types}

\begin{align}
    \LuTy \in \ClassLuTy &&::= \quad &\LuBase                     \tag{base type} \\
                         &&||  \quad &\LuArr{\LuTy_1}{\LuTy_2}    \tag{function type}
\end{align}

\paragraph{Terms}

\begin{align}
    \LuTm \in \ClassLuTm &&::= \quad &\LuVar, \LuVarY, ... \tag{variable} \\
                         &&||  \quad &\LuAbs{\LuVar}{\LuTy}{\LuTm} \tag{abstraction} \\
                         &&||  \quad &\LuApp{\LuTm_1}{\LuTm_2} \tag{application} \\
                         &&||  \quad &\LuEmpty \tag{empty} \\
                         &&||  \quad &\LuCon \tag{singleton} \\
                         &&||  \quad &\LuUnion{\LuTm_1}{\LuTm_2} \tag{union}
\end{align}

\paragraph{Environments}

\begin{align*}
    \LuEnv \in \ClassLuEnv ::= \quad \EmptyEnv \quad || \quad \LuEnv, \LuVar : \LuTy
\end{align*}

\subsection{Typing relation}

The typing relation of the $\LambdaUnion$-calculus is an extension of the simply types $\lambda$-calculus' typing relation.

\begin{gather*}
    \Rule{T-Var}
         {}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy]{\LuVar}{\LuTy}}
    \quad
    \Rule{T-Abs}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy_1]{\LuTm}{\LuTy_2}}
         {\JudgeLuTy{\LuAbs{\LuVar}{\LuTy_1}{\LuTm}}{\LuArr{\LuTy_1}{\LuTy_2}}}
    \\\\
    \Rule{T-App}
         {\JudgeLuTy{\LuTm_1}{\LuArr{\LuTy_1}{\LuTy_2}} \quad \JudgeLuTy{\LuTm_2}{\LuTy_1}}
         {\JudgeLuTy{\LuApp{\LuTm_1}{\LuTm_2}}{\LuTy_2}}
    \\\\
    \Rule{T-Empty}
         {}
         {\JudgeLuTy{\LuEmpty}{\LuBase}}
    \quad
    \Rule{T-Con}
         {}
         {\JudgeLuTy{\LuCon}{\LuBase}}
    \\\\
    \Rule{T-Union}
         {\JudgeLuTy{\LuTm_1}{\LuTy} \quad \JudgeLuTy{\LuTm_2}{\LuTy}}
         {\JudgeLuTy{\LuUnion{\LuTm_1}{\LuTm_2}}{\LuTy}}
\end{gather*}

The empty-set and singleton-set constants are of base type and we cab inly take the set-union of two terms if they have the same type.

\subsection{Semantics}

\TODO

\subsection{Normalization}
\TODOX{Do we \emph{need} to distribute unions over applications? Is a performace optimization? Do we lose any precision? If not, because terms can't inspect their arguments?}

To reduce $\LambdaUnion$-terms to a normal form we combine the $\beta$-reduction rule of the simply typed $\lambda$-calculus with rewrite rules that deal with the associativity, commutativity, idempotence and identity (ACI1) properties of set-union operator.

If a term $t$ is $\eta$-long it can be written in the form
\begin{align*}
    t = \lambda x_1 \cdots x_n. \{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}
\end{align*}
where $f_i$ can be a free or bound variable, a singleton-set constant, or another $\eta$-long term; and $q_i$ is equal to the arity of $f_i$ (for all $1 \leq i \leq p$). The notation $\{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}$ is a shorthand for $f_1(t_{11}, ..., t_{1q_1}) \cup \cdots \cup f_p(t_{p1}, ..., t_{pq_p}) \}$, where we forget the associativity of the set-union operator and any empty-set constants. Note that despite the suggestive notation, this is not a true set, as there may still be duplicate elements $f_i(t_{i1}, ..., t_{iq_i})$.

A normal form $v$ of a term $t$ can be written as
\begin{align*}
    v = \lambda x_1 \cdots x_n. \{ k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p}) \}
\end{align*}
where $k_i$ can be a free or bound variable, or a singleton-set constant, but not a term as this would form a $\beta$-redex.\footnote{Technically, terms that bind at least one variable would form a $\beta$-redex. Terms that do not bind any variables do not occur either as they merely form a subsequence of $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$ in this notation.} For each $k_i, k_j$ with $i < j$ we must also have that $k_i < k_j$ for some total order on $\ClassVar \cup \ClassCon$. Not only does this imply that each term $k_i(v_{i1}, ..., v_{iq_i})$ occurs only once in $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$, but also the stronger condition that $k_i \neq k_j$ for all $i\neq j$.

%format reduce  (t)    = "\llfloor " t "\rrfloor "
%format reduce' (t)    = "\lfloor " t "\rfloor "
%format setRewrite (t) = "\Lbag " t "\Rbag "
%format ClassNf        = "\mathbf{Nf}"
%format x_1n           = " x_1 \cdots x_n"
%format y_1q           = " y_1 \cdots y_q"
%format atom           = "f_i(t_{i1}, ..., t_{iq_i})"
%format atomReduce     = "f_i(\llfloor t_{i1} \rrfloor, ..., \llfloor t_{iq_i} \rrfloor)"
%format atomStuck      = "k(v_{1}, ..., v_{q})"
%format unionize       = "\bigcup"
\begin{figure}
\begin{code}
-- normalization of terms
reduce : ClassTm -> ClassNf
reduce (LAMBDA x_1n T) =
    LAMBDA x_1n (setRewrite ({ reduce' atomReduce | atom `elem` T }))

-- $\beta$-reduction
reduce' (atomStuck)
    = atomStuck
reduce' ((LAMBDA y_1q T)(v_1, ..., v_q))
    = SUBST x y z
    
-- set-rewriting
setRewrite ({ ..., k_i(...), ..., k_j(...), ...})
    | k_j < k_i = setRewrite ({ ..., k_i(...), ..., k_j(...), ...})
setRewrite ({ ..., k(...), k(...), ...})
    = setRewrite ({ ..., k(...), ...})
setRewrite T
    = T
\end{code}
\caption{Normalization algorithm for $\LambdaUnion$-terms.}
\end{figure}
