\section{The $\LambdaUnion$-calculus}

\begin{itemize}
    \item \TODOX{If we don't distribute unions over applications, can we ever get them deep inside terms?}
    \item \TODOX{If we don't \emph{and} the outermost lambdas are not there because is always of kind star, can we get non-trivial terms? I.e. something other than $e_1(e_{11},...,e_{1n_1}) \cup \cdots \cup e_k(e_{k1},...,e_{kn_k}$ (note: $e$ and not $t$ as arugments).}
\end{itemize}

The $\LambdaUnion$-calculus is simply typed $\lambda$-calculus extended with a set-union operator and singleton-set and empty-set constants at the term level.

\begin{figure}[h]
\paragraph{Types}
\begin{alignat}{2}
    \LuTy \in \ClassLuTy &\ ::=\   &&\ \LuBase                     \tag{base type} \\
                         &\quad||  &&\ \LuArr{\LuTy_1}{\LuTy_2}    \tag{function type}
\end{alignat}

\paragraph{Terms}
\begin{alignat}{2}
    \LuTm \in \ClassLuTm &\ ::=\    &&\LuVar, \LuVarY, ... \tag{variable} \\
                         &\quad||   &&\LuAbs{\LuVar}{\LuTy}{\LuTm} \tag{abstraction} \\
                         &\quad||   &&\LuApp{\LuTm_1}{\LuTm_2} \tag{application} \\
                         &\quad||   &&\LuEmpty \tag{empty} \\
                         &\quad||   &&\LuCon \tag{singleton} \\
                         &\quad||   &&\LuUnion{\LuTm_1}{\LuTm_2} \tag{union}
\end{alignat}

\paragraph{Environments}
\begin{align*}
    \LuEnv \in \ClassLuEnv\ ::=\ \EmptyEnv \quad || \quad \LuEnv, \LuVar : \LuTy
\end{align*}
\caption{$\LambdaUnion$-calculus: syntax}
\end{figure}

\subsection{Typing relation}

The typing relation of the $\LambdaUnion$-calculus is an extension of the simply types $\lambda$-calculus' typing relation.

\begin{figure}[h]
\begin{gather*}
    \Rule{T-Var}
         {}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy]{\LuVar}{\LuTy}}
    \quad
    \Rule{T-Abs}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy_1]{\LuTm}{\LuTy_2}}
         {\JudgeLuTy{\LuAbs{\LuVar}{\LuTy_1}{\LuTm}}{\LuArr{\LuTy_1}{\LuTy_2}}}
    \VER
    \Rule{T-App}
         {\JudgeLuTy{\LuTm_1}{\LuArr{\LuTy_1}{\LuTy_2}} \quad \JudgeLuTy{\LuTm_2}{\LuTy_1}}
         {\JudgeLuTy{\LuApp{\LuTm_1}{\LuTm_2}}{\LuTy_2}}
    \VER
    \Rule{T-Empty}
         {}
         {\JudgeLuTy{\LuEmpty}{\LuBase}}
    \quad
    \Rule{T-Con}
         {}
         {\JudgeLuTy{\LuCon}{\LuBase}}
    \VER
    \Rule{T-Union}
         {\JudgeLuTy{\LuTm_1}{\LuTy} \quad \JudgeLuTy{\LuTm_2}{\LuTy}}
         {\JudgeLuTy{\LuUnion{\LuTm_1}{\LuTm_2}}{\LuTy}}
\end{gather*}
\caption{$\LambdaUnion$-calculus: type system}
\end{figure}

The empty-set and singleton-set constants are of base type and we cab inly take the set-union of two terms if they have the same type.

\subsection{Semantics}

\begin{itemize}
    \item \TODOX{$\mathcal{P}(V_{\tau_1} \to V_{\tau_2}) \simeq V_{\tau_1} \to \mathcal{P}(V_{\tau_2})$?} Cardinallity suggests not: $2^{(\beta^\alpha)} \neq (2^\beta)^\alpha$.
\end{itemize}

In the $\LambdaUnion$-calculus terms are interpreted as sets and types as powersets.

\begin{figure}[h]
    \paragraph{Types and values}
    \begin{align*}
        V_\LuBase &= \mathcal{P}(\ClassCon) \\
        V_{\tau_1 \to \tau_2} &= \mathcal{P}(V_{\tau_1} \to V_{\tau_2})
    \end{align*}
    \paragraph{Environments}
    \begin{align*}
        \rho &: \ClassVar \to \bigcup \left\{V_\tau \mid \tau\ \mathrm{type}\right\}
    \end{align*}
    \paragraph{Terms}
    \begin{align*}
        \llbracket \LuVar \rrbracket_\rho &= \rho(x) \\
        \llbracket \LuAbs{\LuVar}{\LuTy}{\LuTm} \rrbracket_\rho &= \left\{ \lambda v \in V_\tau. \llbracket t \rrbracket_{\rho[\LuVar \mapsto v]} \right\} \\
        \llbracket \LuApp{\LuTm_1}{\LuTm_2} \rrbracket_\rho &= \bigcup \left\{ \varphi(\llbracket \LuTm_2 \rrbracket_\rho) \mid \varphi \in \llbracket \LuTm_1 \rrbracket_\rho \right\}\\
        \llbracket \LuEmpty \rrbracket_\rho &= \LuEmpty \\
        \llbracket \LuCon \rrbracket_\rho &= \LuCon \\
        \llbracket \LuUnion{\LuTm_1}{\LuTm_2} \rrbracket_\rho &= \llbracket \LuTm_1 \rrbracket_\rho \cup \llbracket \LuTm_2 \rrbracket_\rho
    \end{align*}
    \caption{$\LambdaUnion$-calculus: denotational semantics}
\end{figure}

\begin{lemma}
    The terms $\LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)}$ and $\LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}}$ are extensionally equal.
\end{lemma}
\begin{proof}
    We prove that \[\llbracket \LuApp{\left(\LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)}\right)}{\LuTm_3} \rrbracket_\rho = \llbracket \LuApp{\left(\LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}}\right)}{\LuTm_3} \rrbracket_\rho \] for all $\rho$ and $\LuTm_3$.
    \begin{align*}
        & \llbracket \LuApp{\left(\LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)}\right)}{\LuTm_3} \rrbracket_\rho \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \llbracket \LuUnion{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_1}\right)}{\left(\LuAbs{\LuVar}{\LuTy}{\LuTm_2}\right)} \rrbracket_\rho \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \llbracket \LuAbs{\LuVar}{\LuTy}{\LuTm_1} \rrbracket_\rho \cup \llbracket \LuAbs{\LuVar}{\LuTy}{\LuTm_2} \rrbracket_\rho \right\} \\
        %&= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \left\{ \lambda v \in V_\tau. \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto v\right]}, \lambda v \in V_\tau. \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto v\right]}\right\} \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \left\{ \lambda v \in V_\tau. \llbracket \LuTm_i \rrbracket_{\rho\left[\LuVar \mapsto v\right]} \mid i \in \left\{1,2\right\} \right\} \right\} \\
        &= \bigcup \left\{ \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]}, \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \right\} \\
        &= \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \cup \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \\
        &= \bigcup \left\{ \llbracket \LuTm_1 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \cup \llbracket \LuTm_2 \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \right\} \\
        &= \bigcup \left\{ \llbracket \LuUnion{\LuTm_1}{\LuTm_2} \rrbracket_{\rho\left[\LuVar \mapsto \llbracket \LuTm_3 \rrbracket_\rho\right]} \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \left\{ \lambda v \in V_\tau. \llbracket \LuUnion{\LuTm_1}{\LuTm_2} \rrbracket_{\rho\left[\LuVar \mapsto v\right]} \right\} \right\} \\
        &= \bigcup \left\{ \varphi(\llbracket \LuTm_3 \rrbracket_\rho) \mid \varphi \in \llbracket \LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}} \rrbracket_\rho \right\} \\
        &= \llbracket \LuApp{\left(\LuAbs{\LuVar}{\LuTy}{\LuUnion{\LuTm_1}{\LuTm_2}}\right)}{\LuTm_3} \rrbracket_\rho
    \end{align*}
\end{proof}

\subsection{Normalization}
\begin{itemize}
    \item \TODOX{We can make union only work on base types (as we not longer \emph{need} to distribute unions over applications)? Then the denotation of the function space would be simpler and might generalize to other structures..}
\end{itemize}

To reduce $\LambdaUnion$-terms to a normal form we combine the $\beta$-reduction rule of the simply typed $\lambda$-calculus with rewrite rules that deal with the associativity, commutativity, idempotence and identity (\ACIone) properties of set-union operator.

If a term $t$ is $\eta$-long it can be written in the form
\begin{align*}
    t = \lambda x_1 \cdots x_n. \{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}
\end{align*}
where $f_i$ can be a free or bound variable, a singleton-set constant, or another $\eta$-long term; and $q_i$ is equal to the arity of $f_i$ (for all $1 \leq i \leq p$). The notation $\{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}$ is a shorthand for $f_1(t_{11}, ..., t_{1q_1}) \cup \cdots \cup f_p(t_{p1}, ..., t_{pq_p}) \}$, where we forget the associativity of the set-union operator and any empty-set constants. Note that despite the suggestive notation, this is not a true set, as there may still be duplicate elements $f_i(t_{i1}, ..., t_{iq_i})$.

A normal form $v$ of a term $t$ can be written as
\begin{align*}
    v = \lambda x_1 \cdots x_n. \{ k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p}) \}
\end{align*}
where $k_i$ can be a free or bound variable, or a singleton-set constant, but not a term as this would form a $\beta$-redex.\footnote{Technically, terms that bind at least one variable would form a $\beta$-redex. Terms that do not bind any variables do not occur either as they merely form a subsequence of $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$ in this notation.} For each $k_i, k_j$ with $i < j$ we must also have that $k_i < k_j$ for some total order on $\ClassVar \cup \ClassCon$. Not only does this imply that each ter      m $k_i(v_{i1}, ..., v_{iq_i})$ occurs only once in $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$, but also the stronger condition that $k_i \neq k_j$ for all $i\neq j$.

%format reduce  (t)    = "\llfloor " t "\rrfloor "
%format reduce' (t)    = "\lfloor " t "\rfloor "
%format setRewrite (t) = "\Lbag " t "\Rbag "
%format ClassNf        = "\mathbf{Nf}"
%format x_1n           = " x_1 \cdots x_n"
%format y_1q           = " y_1 \cdots y_q"
%format atom           = "f_i(t_{i1}, ..., t_{iq_i})"
%format atomReduce     = "f_i(\llfloor t_{i1} \rrfloor, ..., \llfloor t_{iq_i} \rrfloor)"
%format atomStuck      = "k(v_{1}, ..., v_{q})"
%format unionize       = "\bigcup"
\begin{figure}[h]
\begin{code}
-- normalization of terms
reduce : ClassTm -> ClassNf
reduce (LAMBDA x_1n T) =
    LAMBDA x_1n (setRewrite ({ reduce' atomReduce | atom `elem` T }))

-- $\beta$-reduction
reduce' (atomStuck)
    = atomStuck
reduce' ((LAMBDA y_1q T)(v_1, ..., v_q))
    = SUBST x y z
    
-- set-rewriting
setRewrite ({ ..., k_i(...), ..., k_j(...), ...})
    | k_j < k_i = setRewrite ({ ..., k_i(...), ..., k_j(...), ...})
setRewrite ({ ..., k(...), k(...), ...})
    = setRewrite ({ ..., k(...), ...})
setRewrite T
    = T
\end{code}
\caption{Normalization algorithm for $\LambdaUnion$-terms.}
\end{figure}

\subsection{Pattern unification}

\TODOX{add context/quantifiers for free/bound vars}

\begin{definition}
A $\LambdaUnion$-term $\pi$ is called a \emph{pattern} if it is of the form $f(e_1, ..., e_n)$ where $f$ is a free variable and $e_1, ..., e_n$ are distinct bound variables.
\end{definition}

Note that this definition is a special case of what is normally called a \emph{pattern} in higher-order unification theory \cite{Miller1991,Dowek:2001:HUM:778522.778525}.

If $f(e_1, ..., e_n)$ is a $\LambdaUnion$-pattern and $t$ a $\LambdaUnion$-term, then the equation
\[ f : \overline{\LuTy_i \Rightarrow } \LuTy \vdash \forall e_1 : \LuTy_1, ..., e_n : \LuTy_n. f(e_1, ..., e_n) = t \]
can be uniquely solved by the unifier \[ \theta = \left[f \mapsto \lambda e_1 : \LuTy_1, ..., e_n : \LuTy_n. t \right]. \]
