\section{The $\LambdaUnion$-calculus}

The $\LambdaUnion$-calculus is simply typed $\lambda$-calculus extended with a set-union operator and singleton-set and empty-set constants at the term level.

\paragraph{Types}

\begin{align}
    \LuTy \in \ClassLuTy &&::= \quad &\LuBase                     \tag{base type} \\
                         &&||  \quad &\LuArr{\LuTy_1}{\LuTy_2}    \tag{function type}
\end{align}

\paragraph{Terms}

\begin{align}
    \LuTm \in \ClassLuTm &&::= \quad &\LuVar, \LuVarY, ... \tag{variable} \\
                         &&||  \quad &\LuAbs{\LuVar}{\LuTy}{\LuTm} \tag{abstraction} \\
                         &&||  \quad &\LuApp{\LuTm_1}{\LuTm_2} \tag{application} \\
                         &&||  \quad &\LuEmpty \tag{empty} \\
                         &&||  \quad &\LuCon \tag{singleton} \\
                         &&||  \quad &\LuUnion{\LuTm_1}{\LuTm_2} \tag{union}
\end{align}

\paragraph{Environments}

\begin{align*}
    \LuEnv \in \ClassLuEnv ::= \quad \EmptyEnv \quad || \quad \LuEnv, \LuVar : \LuTy
\end{align*}

\subsection{Typing relation}

The typing relation of the $\LambdaUnion$-calculus is an extension of the simply types $\lambda$-calculus' typing relation.

\begin{gather*}
    \Rule{T-Var}
         {}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy]{\LuVar}{\LuTy}}
    \quad
    \Rule{T-Abs}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy_1]{\LuTm}{\LuTy_2}}
         {\JudgeLuTy{\LuAbs{\LuVar}{\LuTy_1}{\LuTm}}{\LuArr{\LuTy_1}{\LuTy_2}}}
    \\\\
    \Rule{T-App}
         {\JudgeLuTy{\LuTm_1}{\LuArr{\LuTy_1}{\LuTy_2}} \quad \JudgeLuTy{\LuTm_2}{\LuTy_1}}
         {\JudgeLuTy{\LuApp{\LuTm_1}{\LuTm_2}}{\LuTy_2}}
    \\\\
    \Rule{T-Empty}
         {}
         {\JudgeLuTy{\LuEmpty}{\LuBase}}
    \quad
    \Rule{T-Con}
         {}
         {\JudgeLuTy{\LuCon}{\LuBase}}
    \\\\
    \Rule{T-Union}
         {\JudgeLuTy{\LuTm_1}{\LuTy} \quad \JudgeLuTy{\LuTm_2}{\LuTy}}
         {\JudgeLuTy{\LuUnion{\LuTm_1}{\LuTm_2}}{\LuTy}}
\end{gather*}

The empty-set and singleton-set constants are of base type and we cab inly take the set-union of two terms if they have the same type.

\subsection{Semantics}

\TODO

\subsection{Normalization}
\TODOX{Do we \emph{need} to distribute unions over applications? Is a performace optimization? Do we lose any precision? If not, because terms can't inspect their arguments?}

To reduce $\LambdaUnion$-terms to a normal form we combine the $\beta$-reduction rule of the simply typed $\lambda$-calculus with rewrite rules that deal with the associativity, commutativity, idempotence and identity (ACI1) properties of set-union operator.

If a term $t$ is $\eta$-long it can be written in the form
\begin{align*}
    t = \lambda x_1 \cdots x_n. \{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}
\end{align*}
where $f_i$ can be a free or bound variable, a singleton-set constant, or another $\eta$-long term; and $q_i$ is equal to the arity of $f_i$ (for all $1 \leq i \leq p$). The notation $\{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}$ is a shorthand for $f_1(t_{11}, ..., t_{1q_1}) \cup \cdots \cup f_p(t_{p1}, ..., t_{pq_p}) \}$, where we forget the associativity of the set-union operator and any empty-set constants. Note that despite the suggestive notation, this is not a true set, as there may still be duplicate elements $f_i(t_{i1}, ..., t_{iq_i})$.

A normal form $v$ of a term $t$ can be written as
\begin{align*}
    v = \lambda x_1 \cdots x_n. \{ k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p}) \}
\end{align*}
where $k_i$ can be a free or bound variable, or a singleton-set constant, but not a term as this would form a $\beta$-redex.\footnote{Technically, terms that bind at least one variable would form a $\beta$-redex. Terms that do not bind any variables do not occur either as they merely form a subsequence of $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$ in this notation.}
