\section{The $\LambdaUnion$-calculus}\label{section-lambda-union}

%\subsection{Syntax}

The $\LambdaUnion$-calculus is a simply typed $\lambda$-calculus extended with a set-union operator and singleton-set and empty-set constants at the term level. We let $\LuVar \in \ClassVar$ range over an infinite set of variables and $c \in \ClassCon$ over a non-empty set of constants.

\begin{figure}[h]
\paragraph{Types}
\begin{alignat}{2}
    \LuTy \in \ClassLuTy &\ ::=\   &&\ \LuBase                     \tag{base type} \\
                         &\quad||  &&\ \LuArr{\LuTy_1}{\LuTy_2}    \tag{function type}
\end{alignat}

\paragraph{Terms}
\begin{alignat}{2}
    \LuTm \in \ClassLuTm &\ ::=\    &&\LuVar \tag{variable} \\
                         &\quad||   &&\LuAbs{\LuVar}{\LuTy}{\LuTm} \tag{abstraction} \\
                         &\quad||   &&\LuApp{\LuTm_1}{\LuTm_2} \tag{application} \\
                         &\quad||   &&\LuEmpty \tag{empty} \\
                         &\quad||   &&\LuCon \tag{singleton} \\
                         &\quad||   &&\LuUnion{\LuTm_1}{\LuTm_2} \tag{union}
\end{alignat}

\paragraph{Environments}
\begin{align*}
    \LuEnv \in \ClassLuEnv\ ::=\ \EmptyEnv \ || \ \LuEnv, \LuVar : \LuTy
\end{align*}
\caption{$\LambdaUnion$-calculus: syntax}
\end{figure}

%\subsection{Typing relation}

The typing relation of the $\LambdaUnion$-calculus is an extension of the simply typed $\lambda$-calculus' typing relation.

\begin{figure}[h]
\begin{gather*}
    \Rule{T-Var}
         {}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy]{\LuVar}{\LuTy}}
    \quad
    \Rule{T-Abs}
         {\JudgeLuTy[\LuEnv, \LuVar : \LuTy_1]{\LuTm}{\LuTy_2}}
         {\JudgeLuTy{\LuAbs{\LuVar}{\LuTy_1}{\LuTm}}{\LuArr{\LuTy_1}{\LuTy_2}}}
    \VER
    \Rule{T-App}
         {\JudgeLuTy{\LuTm_1}{\LuArr{\LuTy_1}{\LuTy_2}} \quad \JudgeLuTy{\LuTm_2}{\LuTy_1}}
         {\JudgeLuTy{\LuApp{\LuTm_1}{\LuTm_2}}{\LuTy_2}}
    \VER
    \Rule{T-Empty}
         {}
         {\JudgeLuTy{\LuEmpty}{\LuBase}}
    \quad
    \Rule{T-Con}
         {}
         {\JudgeLuTy{\LuCon}{\LuBase}}
    \VER
    \Rule{T-Union}
         {\JudgeLuTy{\LuTm_1}{\LuTy} \quad \JudgeLuTy{\LuTm_2}{\LuTy}}
         {\JudgeLuTy{\LuUnion{\LuTm_1}{\LuTm_2}}{\LuTy}}
\end{gather*}
\caption{$\LambdaUnion$-calculus: type system}
\end{figure}

The empty-set and singleton-set constants are of base type and we can only take the set-union of two terms if they have the same type.

\subsection{Semantics}

In the $\LambdaUnion$-calculus, terms are interpreted as sets and types as powersets.

\begin{figure}[h]
    \paragraph{Types and values}
    \begin{align*}
        V_\LuBase &= \mathcal{P}(\ClassCon) \\
        V_{\tau_1 \to \tau_2} &= \mathcal{P}(V_{\tau_1} \to V_{\tau_2})
    \end{align*}
    \paragraph{Environments}
    \begin{align*}
        \rho &: \ClassVar \to \bigcup \left\{V_\tau \mid \tau\ \mathrm{type}\right\}
    \end{align*}
    \paragraph{Terms}
    \begin{align*}
        \llbracket \LuVar \rrbracket_\rho &= \rho(x) \\
        \llbracket \LuAbs{\LuVar}{\LuTy}{\LuTm} \rrbracket_\rho &= \left\{ \lambda v \in V_\tau. \llbracket t \rrbracket_{\rho[\LuVar \mapsto v]} \right\} \\
        \llbracket \LuApp{\LuTm_1}{\LuTm_2} \rrbracket_\rho &= \bigcup \left\{ \varphi(\llbracket \LuTm_2 \rrbracket_\rho) \mid \varphi \in \llbracket \LuTm_1 \rrbracket_\rho \right\}\\
        \llbracket \LuEmpty \rrbracket_\rho &= \LuEmpty \\
        \llbracket \LuCon \rrbracket_\rho &= \LuCon \\
        \llbracket \LuUnion{\LuTm_1}{\LuTm_2} \rrbracket_\rho &= \llbracket \LuTm_1 \rrbracket_\rho \cup \llbracket \LuTm_2 \rrbracket_\rho
    \end{align*}
    \caption{$\LambdaUnion$-calculus: denotational semantics}
\end{figure}

\subsection{Subsumption and equivalence}

The set-structure of the $\LambdaUnion$-calculus induces a partial order on the terms.

%\begin{definition}
%We say that a term environment $\rho$ is \emph{compatible} with a type environment $\Gamma$ if $\mathrm{dom}(\rho) = \mathrm{dom}(\Gamma)$ and for all $x \in \mathrm{dom}(\rho)$ we have that $\Gamma \vdash \rho(x) : \Gamma(x)$.
%\end{definition}

\begin{definition}\label{definition-subsumption}
    Let $\LuTm_1$ and $\LuTm_2$ be terms such that $\JudgeLuTy{\LuTm_1}{\LuTy}$ and $\JudgeLuTy{\LuTm_2}{\LuTy}$.
    We say the term $\LuTm_2$ \emph{subsumes} the term $\LuTm_1$, written $\JudgeLuSub{\LuTm_1}{\LuTm_2}$, if for any context $\LuCtx{}$ such that $\JudgeLuTy[]{\LuCtx{\LuTm_1}}{\LuBase}$ and $\JudgeLuTy[]{\LuCtx{\LuTm_2}}{\LuBase}$ we have that $\LuDen[\emptyset]{\LuCtx{\LuTm_1}} \subseteq \LuDen[\emptyset]{\LuCtx{\LuTm_2}}$.
\end{definition}

\begin{definition}
    Let $\LuTm_1$ and $\LuTm_2$ be terms such that $\JudgeLuTy{\LuTm_1}{\LuTy}$ and $\JudgeLuTy{\LuTm_2}{\LuTy}$.
    We say that the terms $\LuTm_1$ and $\LuTm_2$ are \emph{observationally equivalent}, denoted as $\JudgeLuEqv{\LuTm_1}{\LuTm_2}$, if
    \begin{enumerate}
        \item $\JudgeLuSub{\LuTm_1}{\LuTm_2}$ and $\JudgeLuSub{\LuTm_2}{\LuTm_1}$, or equivalently that
        \item for any context $\LuCtx{}$ such that $\JudgeLuTy[]{\LuCtx{\LuTm_1}}{\LuBase}$ and $\JudgeLuTy[]{\LuCtx{\LuTm_2}}{\LuBase}$ we have that $\LuDen[\emptyset]{\LuCtx{\LuTm_1}} = \LuDen[\emptyset]{\LuCtx{\LuTm_2}}$.
    \end{enumerate}
\end{definition}

%include ../theorem/lu-gamma1.lhs2tex
%include ../theorem/lu-gamma2.lhs2tex
%include ../proof/lu-gamma2-sketch.lhs2tex

\LORUMIPSUM

\LORUMIPSUM

\LORUMIPSUM

\subsection{\TODO{Normalization}}
\begin{itemize}
    \item \TODOX{Ordering of terms}
    \item \TODOX{We can make union only work on base types (as we not longer \emph{need} to distribute unions over applications)?}
\end{itemize}

To reduce $\LambdaUnion$-terms to a normal form we combine the $\beta$-reduction rule of the simply typed $\lambda$-calculus with rewrite rules that deal with the associativity, commutativity, idempotence and identity (\ACIone) properties of set-union operator.

If a term $t$ is $\eta$-long it can be written in the form
\begin{align*}
    t = \lambda x_1 \cdots x_n. \{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}
\end{align*}
where $f_i$ can be a free or bound variable, a singleton-set constant, or another $\eta$-long term; and $q_i$ is equal to the arity of $f_i$ (for all $1 \leq i \leq p$). The notation $\{ f_1(t_{11}, ..., t_{1q_1}), ..., f_p(t_{p1}, ..., t_{pq_p}) \}$ is a shorthand for $f_1(t_{11}, ..., t_{1q_1}) \cup \cdots \cup f_p(t_{p1}, ..., t_{pq_p}) \}$, where we forget the associativity of the set-union operator and any empty-set constants.
%Note that despite the suggestive notation, this is not a true set, as there may still be duplicate elements $f_i(t_{i1}, ..., t_{iq_i})$.

A normal form $v$ of a term $t$ can be written as
\begin{align*}
    v = \lambda x_1 \cdots x_n. \{ k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p}) \}
\end{align*}
where $k_i$ can be a free or bound variable, or a singleton-set constant, but not a term as this would form a $\beta$-redex.\footnote{Technically, terms that bind at least one variable would form a $\beta$-redex. Terms that do not bind any variables do not occur either as they merely form a subsequence of $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$ in this notation.}
%For each $k_i, k_j$ with $i < j$ we must also have that $k_i < k_j$ for some total order on $\ClassVar \cup \ClassCon$.
%Not only does this imply that each term $k_i(v_{i1}, ..., v_{iq_i})$ occurs only once in $k_1(v_{11}, ..., v_{1q_1}), ..., k_p(v_{p1}, ..., v_{pq_p})$, but also the stronger condition that $k_i \neq k_j$ for all $i\neq j$.

\begin{figure}[h]
    \begin{gather*}
        \Rule{R-Beta}
             {
             }
             {(\lambda x.t_1)\ t_2 \longrightarrow t_1\left[t_2 / x\right]
             }
        \VER
        \Rule{R-Gamma$_1$}
             {
             }
             {\{t_1, ..., t_n\}\ t \longrightarrow \{t_1\ t, ..., t_n\ t\}
             }
        \VER
        \Rule{R-Gamma$_2$}
             {
             }
             {\{\lambda x.t_1, ..., \lambda x.t_n\} \longrightarrow \lambda x.\{t_1, ..., t_n\}
             }
    \end{gather*}
\caption{$\LambdaUnion$-calculus: reduction}
\end{figure}

\subsection{Pattern unification}

\begin{definition}\label{definition-pattern}
A $\LambdaUnion$-term is called a \emph{pattern} if it is of the form $f(e_1, ..., e_n)$ where $f$ is a free variable and $e_1, ..., e_n$ are distinct bound variables.
\end{definition}

Note that this definition is a special case of what is usually called a \emph{pattern} in higher-order unification theory \cite{Miller1991,Dowek:2001:HUM:778522.778525}.

If $f(e_1, ..., e_n)$ is a pattern and $t$ a term, then the equation
\[ f : \LuTy_1 \to \cdots \to \LuTy_n \to \LuTy \vdash \forall e_1 : \LuTy_1, ..., e_n : \LuTy_n. f(e_1, ..., e_n) = t \]
can be uniquely solved by the unifier \[ \theta = \left[f \mapsto \lambda e_1 : \LuTy_1, ..., e_n : \LuTy_n. t \right]. \]
