\section{Type system}

\subsection{Terms}

\begin{align}
    \Tm \in \ClassTm &&::=  \quad &\TmVar                   \tag{term variable}     \\
                     &&||   \quad &\TmCon{\Ty}              \tag{term constant}     \\
                     &&||   \quad &\TmAbs{\TmVar}{\Ty}{\Tm} \tag{term abstraction}  \\
                     &&||   \quad &\TmApp{\Tm_1}{\Tm_2}     \tag{term application}  \\
                     &&||   \quad &\TmOp{\Tm_1}{\Tm_2}      \tag{operator}          \\
                     &&||   \quad &\TmIf{\Tm_1}{\Tm_2}{\Tm_3}\tag{conditional}      \\
                     &&||   \quad &\TmCrash{\Ty}{\ExnLbl}   \tag{exception constant}\\
                     &&||   \quad &\TmSeq{\Tm_1}{\Tm_2}     \tag{forcing}           \\
                     &&||   \quad &\TmFix{\Tm}              \tag{anonymous fixpoint}\\
                     &&||   \quad &\TmNil{\Ty}              \tag{nil constructor}   \\
                     &&||   \quad &\TmCons{\Tm_1}{\Tm_2}    \tag{cons constructor}  \\
                     &&||   \quad &\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}
                                                            \tag{list eliminator}
\end{align}

\subsection{Underlying type system}

\begin{figure}[h]
    \begin{gather*}
        \Rule{T-Var}
             {}
             {\JudgeTy{\TyEnv, \TmVar : \Ty}
                      {\TmVar}
                      {\Ty}
             }
        \quad
        \Rule{T-Con}
             {}
             {\JudgeTy{\TyEnv}
                      {\TmCon{\Ty}}
                      {\Ty}
             }
        \quad
        \Rule{T-Crash}
             {}
             {\JudgeTy{\TyEnv}
                      {\TmCrash{\Ty}{\ExnLbl}}
                      {\Ty}
             }
        \\[1.5ex]
        \Rule{T-Abs}
             {\JudgeTy{\TyEnv, \TmVar : \Ty_1}
                      {\Tm}
                      {\Ty_2}
             }
             {\JudgeTy{\TyEnv}
                      {\TmAbs{\TmVar}{\Ty_1}{\Tm}}
                      {\TyArr{\Ty_1}{\Ty_2}}
             }
        \quad
        \Rule{T-App}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\TyArr{\Ty_2}{\Ty}}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\Ty_2}
             }
             {\JudgeTy{\TyEnv}
                      {\TmApp{\Tm_1}{\Tm_2}}
                      {\Ty}
             }
        \\[1.5ex]
        \Rule{T-Fix}
             {\JudgeTy{\TyEnv}
                      {\Tm}
                      {\TyArr{\Ty}{\Ty}}
             }
             {\JudgeTy{\TyEnv}
                      {\TmFix{\Tm}}
                      {\Ty}
             }
        \\[1.5ex]
        \Rule{T-Op}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\TyInt}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\TyInt}
             }
             {\JudgeTy{\TyEnv}
                      {\TmOp{\Tm_1}{\Tm_2}}
                      {\TyBool}
             }
        \quad
        \Rule{T-Seq}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\Ty_1}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\Ty_2}
             }
             {\JudgeTy{\TyEnv}
                      {\TmSeq{\Tm_1}{\Tm_2}}
                      {\Ty_2}
             }
        \\[1.5ex]
        \Rule{T-If}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\TyBool}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\Ty}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_3}
                      {\Ty}
             }
             {\JudgeTy{\TyEnv}
                      {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                      {\Ty}
             }             
        \\[1.5ex]
        \Rule{T-Nil}
             {}
             {\JudgeTy{\TyEnv}
                      {\TmNil{\Ty}}
                      {\TyList{\Ty}}
             }
        \quad
        \Rule{T-Cons}
             {\JudgeTy{\TyEnv}
                      {\Tm_1}
                      {\Ty}
              \quad
              \JudgeTy{\TyEnv}
                      {\Tm_2}
                      {\TyList{\Ty}}
             }
             {\JudgeTy{\TyEnv}
                      {\TmCons{\Tm_1}{\Tm_2}}
                      {\TyList{\Ty}}
             }
        \\[1.5ex]
        \Rule{T-Case}
             {%\begin{gathered}
                  \JudgeTy{\TyEnv}
                          {\Tm_1}
                          {\TyList{\Ty_1}}
                  \quad
                  \JudgeTy{\TyEnv}
                          {\Tm_2}
                          {\Ty}
                  \quad
                  \JudgeTy{\TyEnv, \TmVar_1 : \Ty_1, \TmVar_2 : \TyList{\Ty_1}}
                          {\Tm_3}
                          {\Ty}
              %\end{gathered}
             }
             {\JudgeTy{\TyEnv}
                      {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                      {\Ty}
             }
    \end{gather*}
    \caption{Underlying type system ($\JudgeTy{\TyEnv}{\Tm}{\Ty}$)}    
\end{figure}

\subsection{Declarative exception type system}

\begin{figure}[h]
    \begin{gather*}
        \Rule{T-Var}
             {}
             {\JudgeExnTy{\TyEnv, \TmVar : \ExnTy\ \&\ \Exn}
                         {\KiEnv}
                         {\TmVar}
                         {\ExnTy}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Con}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCon{\Ty}}
                         {\BottomTy{\Ty}}
                         {\ExnEmpty}
             }
        \quad
        \Rule{T-Crash}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCrash{\Ty}{\ExnLbl}}
                         {\BottomTy{\Ty}}
                         {\ExnCon{\ExnLbl}}
             }
        \\[1.5ex]
        \Rule{T-Abs}
             {\JudgeExnTy{\TyEnv, \TmVar : \ExnTy_1\ \&\ \Exn_1}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy_2}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAbsExn{\TmVar}{\ExnTy_1}{\Exn_1}{\Tm}}
                         {\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}
                         {\ExnEmpty}
             }
        \\[1.5ex]
        \Rule{T-AnnAbs}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv, \ExnVar : \Kind}
                         {\Tm}
                         {\ExnTy}
                         {\Exn}
              \quad
              \ExnVar \notin \fv{\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAnnAbs{\ExnVar}{\Kind}{\Tm}}
                         {\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-App}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTyArr{\ExnTy_2}{\Exn_2}{\ExnTy}{\Exn}}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy_2}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmApp{\Tm_1}{\Tm_2}}
                         {\ExnTy}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-AnnApp}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTyForall{\ExnVar}{\Kind}{\ExnTy}}
                         {\Exn}
              \quad
              \JudgeExn{\KiEnv}
                       {\Exn_2}
                       {\Kind}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmAnnApp{\Tm_1}{\Exn_2}}
                         {\Subst{\Exn_2}{\ExnVar}{\ExnTy}}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Fix}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTyArr{\ExnTy}{\Exn^\prime}{\ExnTy}{\Exn^\prime}}
                         {\Exn^{\prime\prime}}
              \quad
              \JudgeSubExn{\KiEnv}{\Exn^\prime}{\Exn}
              \quad
              \JudgeSubExn{\KiEnv}{\Exn^{\prime\prime}}{\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmFix{\Tm}}
                         {\ExnTy}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Op}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnInt}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnInt}
                         {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmOp{\Tm_1}{\Tm_2}}
                         {\ExnBool}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Seq}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTy_1}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy_2}
                         {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmSeq{\Tm_1}{\Tm_2}}
                         {\ExnTy_2}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-If}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnBool}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTy}
                         {\Exn}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_3}
                         {\ExnTy}
                         {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                         {\ExnTy}
                         {\Exn}
             }             
        \\[1.5ex]
        \Rule{T-Nil}
             {}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmNil{\Ty}}
                         {\ExnTyList{\BottomTy{\Ty}}{\ExnEmpty}}
                         {\ExnEmpty}
             }
        \\[1.5ex]
        \Rule{T-Cons}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_1}
                         {\ExnTy}
                         {\Exn_1}
              \quad
              \JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm_2}
                         {\ExnTyList{\ExnTy}{\Exn_1}}
                         {\Exn_2}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCons{\Tm_1}{\Tm_2}}
                         {\ExnTyList{\ExnTy}{\Exn_1}}
                         {\Exn_2}
             }
        \\[1.5ex]
        \Rule{T-Case}
             {\begin{gathered}
                  \JudgeExnTy{\TyEnv}
                             {\KiEnv}
                             {\Tm_1}
                             {\ExnTyList{\ExnTy_1}{\Exn_1}}
                             {\Exn^\prime}
                  \quad
                  \JudgeSubExn{\KiEnv}{\Exn^\prime}{\Exn}
                  \quad
                  \JudgeExnTy{\TyEnv}
                             {\KiEnv}
                             {\Tm_2}
                             {\ExnTy}
                             {\Exn}
                  \\
                  \JudgeExnTy{\TyEnv, \TmVar_1 : \ExnTy_1\ \&\ \Exn_1, \TmVar_2 : \ExnTyList{\ExnTy_1}{\Exn_1}\ \&\ \Exn^\prime}
                             {\KiEnv}
                             {\Tm_3}
                             {\ExnTy}
                             {\Exn}
              \end{gathered}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                         {\ExnTy}
                         {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Sub}
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy^\prime}
                         {\Exn^\prime}
              \quad
              \JudgeSubTy{\KiEnv}
                         {\ExnTy^\prime}
                         {\ExnTy}
              \quad
              \JudgeSubExn{\KiEnv}
                          {\Exn^\prime}
                          {\Exn}
             }
             {\JudgeExnTy{\TyEnv}
                         {\KiEnv}
                         {\Tm}
                         {\ExnTy}
                         {\Exn}
             }
    \end{gather*}
    \caption{Declarative type system ($\JudgeExnTy{\TyEnv}{\KiEnv}{\Tm}{\ExnTy}{\Exn}$)}    
\end{figure}

\begin{itemize}

    \item In T-Abs and T-AnnAbs, should the term-level term-abstraction also have an explicit effect annotation?

    \item In T-AnnAbs, might need a side condition stating that $\ExnVar$ is not free in $\KiEnv$.

    \item In T-App, note the double occurence of $\Exn$ when typing $\Tm_1$. Is subeffecting sufficient here? Also note that we do \emph{not} expect an exception variable in the left-hand side annotation of the function space constructor.
    
    \item In T-AnnApp, note the substitution. We will need a substitution lemma for annotations.
    
    \item In T-Fix, the might be some universal quantifiers in our way. Do annotation applications in $\Tm$ take care of this, already? Perhaps we do need to change $\TmFix{\Tm}$ into a binding construct to resolve this? Also, there is some implicit subeffecting going on between the annotations and effect.
    
    \item In T-Case, note the use of explicit subeffecting. Can this be done using implicit subeffecting?
    
    \item For T-Sub, should we introduce a term-level coercion, as in Dussart--Henglein--Mossin? We now do shape-conformant subtyping, is subeffecting sufficient?
    
    \item Do we need additional kinding judgements in some of the rules? Can we merge the kinding judgement with the subtyping and/or -effecting judgement? Kind-preserving substitutions.
    
\end{itemize}

\subsection{Type elaboration system}

\begin{figure}[h]
    \begin{gather*}
        \Rule{T-Var}
             {}
             {\JudgeElab{\TyEnv, \TmVar : \ExnTy\ \&\ \Exn}
                        {\KiEnv}
                        {\TmVar}
                        {\TmVar}
                        {\ExnTy}
                        {\Exn}
             }
        \\[1.5ex]
        \Rule{T-Con}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCon{\Ty}}
                        {\TmCon{\Ty}}
                        {\Ty}
                        {\ExnEmpty}
             }
        \quad
        \Rule{T-Crash}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCrash{\Ty}{\ExnLbl}}
                        {\TmCrash{\Ty}{\ExnLbl}}
                        {\BottomTy{\Ty}}
                        {\ExnCon{\ExnLbl}}
             }
        \\[1.5ex]
        \Rule{T-Abs}
             {\begin{gathered}
                \JudgeTyElab{\KiEnv, \overline{\ExnVar_i : \Kind_i}}
                            {\ExnTy_1}
                            {\Ty_1}
                \quad
                \JudgeKind{\KiEnv, \overline{\ExnVar_i : \Kind_i}}
                          {\Exn_1}
                          {\KindEXN}
                \\
                \JudgeElab{\TyEnv, x : \ExnTy_1\ \&\ \Exn_1}
                          {\KiEnv, \overline{\ExnVar_i : \Kind_i}}
                          {\Tm}
                          {\Tm^\prime}
                          {\ExnTy_2}
                          {\Exn_2}
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmAbs{\TmVar}{\Ty_1}{\Tm}}
                        {\TmAnnAbsS{\ExnVar_i}{\Kind_i}{\TmAbsExn{\TmVar}{\ExnTy_1}{\Exn_1}{\Tm^\prime}}}
                        {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}}
                        {\ExnEmpty}
             }
        \\[1.5ex]
        \Rule{T-App}
             {\begin{gathered}
                \JudgeSubTy{\KiEnv}
                           {\ExnTy_2}
                           {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                \quad
                \JudgeSubExn{\KiEnv}
                            {\Exn_2}
                            {\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}
                \quad
                \overline{
                    \JudgeKind{\KiEnv}
                              {\Exn_i}
                              {\Kind_i}
                }
                \\
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm_1}
                          {\Tm_1^\prime}
                          {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy}{\Exn}}}
                          {\Exn^\prime}
                \quad
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm_2}
                          {\Tm_2^\prime}
                          {\ExnTy_2}
                          {\Exn_2}
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmApp{\Tm_1}{\Tm_2}}
                        {\TmApp{\TmAnnApp{\Tm_1^\prime}{\overline{\Exn_i}}}{\Tm_2^\prime}}
                        {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                        {\ExnUnion{\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}{\Exn^\prime}}
             }
        \\[1.5ex]
        \Rule{T-Fix}
             {\begin{gathered}
                \JudgeElab{\TyEnv}
                          {\KiEnv}
                          {\Tm}
                          {\Tm^\prime}
                          {\ExnTyForallS{\ExnVar_i}{\Kind_i}{\ExnTyArr{\ExnTy}{\Exn}{\ExnTy^\prime}{\Exn^\prime}}}
                          {\Exn^{\prime\prime}}
                \\
                \JudgeSubTy{\KiEnv}
                           {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy^\prime}}
                           {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                \quad
                \JudgeSubExn{\KiEnv}
                            {\SubstS{\Exn_i}{\ExnVar_i}{\Exn^\prime}}
                            {\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}
                \quad
                \overline{
                    \JudgeKind{\KiEnv}
                              {\Exn_i}
                              {\Kind_i}
                }
              \end{gathered}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmFix{\Tm}}
                        {\TmAnnApp{\TmFix{\Tm^\prime}}{\overline{\Exn_i}}}
                        {\SubstS{\Exn_i}{\ExnVar_i}{\ExnTy}}
                        {\ExnUnion{\SubstS{\Exn_i}{\ExnVar_i}{\Exn}}{\Exn^{\prime\prime}}}
             }
        \\[1.5ex]
        \Rule{T-Op}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnInt}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnInt}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmOp{\Tm_1}{\Tm_2}}
                        {\TmOp{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnBool}
                        {\ExnUnion{\Exn_1}{\Exn_2}}
             }
        \\[1.5ex]
        \Rule{T-Seq}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnTy_1}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTy_2}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmSeq{\Tm_1}{\Tm_2}}
                        {\TmSeq{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnTy_2}
                        {\ExnUnion{\Exn_1}{\Exn_2}}
             }
        \\[1.5ex]
        \Rule{T-If}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnBool}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTy_2}
                        {\Exn_2}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_3}
                        {\Tm_3^\prime}
                        {\ExnTy_3}
                        {\Exn_3}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmIf{\Tm_1}{\Tm_2}{\Tm_3}}
                        {\TmIf{\Tm_1^\prime}{\Tm_2^\prime}{\Tm_3^\prime}}
                        {\TyJoin{\ExnTy_2}{\ExnTy_3}}
                        {\ExnUnion{\Exn_1}{\ExnUnion{\Exn_2}{\Exn_3}}}
             }             
        \\[1.5ex]
        \Rule{T-Nil}
             {}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmNil{\Ty}}
                        {\TmNil{\Ty}}
                        {\BottomTy{\Ty}}
                        {\ExnEmpty}
             }
        \\[1.5ex]
        \Rule{T-Cons}
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_1}
                        {\Tm_1^\prime}
                        {\ExnTy_1}
                        {\Exn_1}
              \quad
              \JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\Tm_2}
                        {\Tm_2^\prime}
                        {\ExnTyList{\ExnTy_1^\prime}{\Exn_1^\prime}}
                        {\Exn_2}
             }
             {\JudgeElab{\TyEnv}
                        {\KiEnv}
                        {\TmCons{\Tm_1}{\Tm_2}}
                        {\TmCons{\Tm_1^\prime}{\Tm_2^\prime}}
                        {\ExnTyList{\TyJoin{\ExnTy_1}{\ExnTy_1^\prime}}{\ExnUnion{\Exn_1}{\Exn_1^\prime}}}
                        {\Exn_2}
             }
        \\[1.5ex]
        \Rule{T-Case}
             {\begin{gathered}
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_1}
                            {\Tm_1^\prime}
                            {\ExnTyList{\Ty_1}{\Exn_1}}
                            {\Exn_1^\prime}
                  \quad
                  \JudgeElab{\TyEnv}
                            {\KiEnv}
                            {\Tm_2}
                            {\Tm_2^\prime}
                            {\ExnTy_2}
                            {\Exn_2}
                  \\
                  \JudgeElab{\TyEnv, \TmVar_1 : \ExnTy_1\ \&\ \Exn_1, \TmVar_2 : \ExnTyList{\Ty_1}{\Exn_1}\ \&\ \Exn_1^\prime}
                            {\KiEnv}
                            {\Tm_3}
                            {\Tm_3^\prime}
                            {\ExnTy_3}
                            {\Exn_3}
              \end{gathered}
             }
             {\begin{multlined}
                  \JudgeElabM{\TyEnv}
                             {\KiEnv}                 
                             {\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}}
                             {\TmCase{\Tm_1^\prime}{\Tm_2^\prime}{\TmVar_1}{\TmVar_2}{\Tm_3^\prime}}
                             {\TyJoin{\ExnTy_2}{\ExnTy_3}}
                             {\ExnUnion{\Exn_1^\prime}{\ExnUnion{\Exn_2}{\Exn_3}}}
              \end{multlined}
             }
    \end{gather*}
    \caption{Syntax-directed type elaboration system ($\JudgeElab{\TyEnv}{\KiEnv}{\Tm}{\Tm^\prime}{\ExnTy}{\Exn}$)}    
\end{figure}

\begin{itemize}

 \item For T-Fix: how would a binding fixpoint construct work?

\end{itemize}

\subsection{Type inference algorithm}

%format reconstruct                 = "\mathcal{R}"
%format complete                    = "\mathcal{C}"
%format instantiate                 = "\mathcal{I}"
%format match                       = "\mathcal{M}"

%format Product (a) (b)             = a "\times " b
%format ClassEnv                    = "\ClassEnv"
%format env                         = "\TyEnv"
%format kenv                        = "\KiEnv"

%format Var                         = "\TmVar"
%format env_x                       = "\TyEnv_x"

%format (Con (t) (c))               = c "_" t
%format ty                          = "\Ty"
%format Result (a) (b)              = "\langle" a "; " b "\rangle"
%format bottomTy                    = "\BottomTy{\Ty}"
%format ExnEmpty                    = "\ExnEmpty"

%format Crash                       = "\TmCrash{\Ty}{\ExnLbl}"
%format ExnCon                      = "\ExnCon{\ExnLbl}"

%format Abs                         = "\TmAbs{\TmVar}{\Ty}{\Tm}"
%format (Tuple  (x) (y))            = "\langle" x ";" y "\rangle"
%format (Triple (x) (y) (z))        = "\langle" x ";" y ";" z "\rangle"
%format ExnTy                       = "\ExnTy"
%format ExnTy'                      = "\ExnTy^\prime"
%format ExnTy''                     = "\ExnTy^{\prime\prime}"
%format ExnTy_0                     = "\ExnTy_0"
%format ExnTy_1                     = "\ExnTy_1"
%format ExnTy_2                     = "\ExnTy_2"
%format ExnTy_2'                    = "\ExnTy_2^\prime"
%format ExnTy_3                     = "\ExnTy_3"
%format ExnVar'                     = "\ExnVar^{\prime}"
%format ExnVar_1                    = "\ExnVar_1"
%format ExnVar_2'                   = "\ExnVar_2^\prime"
%format Exn                         = "\Exn"
%format Exn'                        = "\Exn^\prime"
%format Exn''                       = "\Exn^{\prime\prime}"
%format Exn_0                       = "\Exn_0"
%format Exn_1                       = "\Exn_1"
%format Exn_1'                      = "\Exn_1^\prime"
%format Exn_2                       = "\Exn_2"
%format Exn_2'                      = "\Exn_2^\prime"
%format Exn_3                       = "\Exn_3"
%format kenv'                       = "\overline{\ExnVar_i : \Kind_i}"
%format EmptyEnv                    = "\emptyset"
%format (extendTyEnv env x (t) e)   = env ", " x " : " t "\ \&\ " e
%format Tm                          = "\Tm"
%format tm                          = "\Tm"
%format tm_1
%format tm_2
%format tm_3
%format ExnTyBool                   = "\ExnBool"
%format ExnTyInt                    = "\ExnInt"
%format ExnTyArr (a) (b) (c) (d)    = "\ExnTyArr{" a "}{" b "}{" c "}{" d "}"
%format ExnForall (a) (b)           = "\ExnForall{" a "}{" b "}"

%format App                         = "\TmApp{\Tm_1}{\Tm_2}"
%format subst                       = "\theta"
%format Subst (x) (y)               = "\left[" x "\mapsto " y "\right]"
%format ExnUnion (a) (b)            = "\ExnUnion{" a "}{" b "}"
%format applySubst (x)              = "\theta " x
%format (simplify (kenv) (x))       = "\llfloor " x "\rrfloor_{" kenv "}"

%format Fix                         = "\TmFix{\Tm}"
%format Exn_i                       = "\Exn_i"
%format Exn_i1                      = "\Exn_{i+1}"
%format Exn_im                      = "\Exn_{i-1}"
%format Exn_w                       = "\Exn_\omega"
%format Exn_w'                      = "\Exn_\omega^\prime"
%format ExnTy_i                     = "\ExnTy_i"
%format ExnTy_i1                    = "\ExnTy_{i+1}"
%format ExnTy_im                    = "\ExnTy_{i-1}"
%format ExnTy_w                     = "\ExnTy_\omega"
%format ExnTy_w'                    = "\ExnTy_\omega^\prime"
%format bottomTyU                   = "\BottomTy{\lfloor \ExnTy^\prime \rfloor}"
%format until                       = "\mathbf{until}"
%format return                      = "\mathbf{return}"

%format BinOp                       = "\TmOp{\Tm_1}{\Tm_2}"
%format Seq                         = "\TmSeq{\Tm_1}{\Tm_2}"

%format If                          = "\TmIf{\Tm_1}{\Tm_2}{\Tm_3}"
%format ExnTyJoin a b               = "\TyJoin{" a "}{" b "}"

%format Nil                         = "\TmNil{\Ty}"
%format ExnTyList a (b)             = "\ExnTyList{" a "}{" b "}"

%format Cons                        = "\TmCons{\Tm_1}{\Tm_2}"
%format Case                        = "\TmCase{\Tm_1}{\Tm_2}{\TmVar_1}{\TmVar_2}{\Tm_3}"
%format Var_1
%format Var_2
\begin{figure}[h]
\begin{code}
    reconstruct : Product ClassTyEnv (Product ClassKiEnv ClassTm) -> Product ClassExnTy ClassExn

    reconstruct env kenv Var         =  env_x

    reconstruct env kenv (Con ty c)  =  Result bottomTy ExnEmpty

    reconstruct env kenv Crash       =  Result bottomTy ExnCon

    reconstruct env kenv (Abs)       =  let  Triple ExnTy_1 ExnVar_1 kenv'  =  complete EmptyEnv ty
                                             Tuple ExnTy_2 Exn_2            =  reconstruct ((extendTyEnv env Var ExnTy_1 ExnVar_1)) (kenv,kenv') Tm
                                        in   Result (ExnForall kenv' (ExnTyArr ExnTy_1 ExnVar_1 ExnTy_2 Exn_2)) ExnEmpty

    reconstruct env kenv (App)       =  let  Tuple ExnTy_1 Exn_1                                    = reconstruct env kenv tm_1
                                             Tuple ExnTy_2 Exn_2                                    = reconstruct env kenv tm_2
                                             Tuple (ExnTyArr ExnTy_2' ExnVar_2' ExnTy' Exn') kenv'  = instantiate ExnTy_1
                                             subst                                                  = Subst ExnVar_2' Exn_2 . match EmptyEnv ExnTy_2 ExnTy_2'
                                        in   Tuple (simplify kenv (applySubst ExnTy')) (simplify kenv (ExnUnion (applySubst Exn') (Exn_1)))

    reconstruct env kenv (Fix)       =  let  Tuple ExnTy Exn                                      = reconstruct env kenv tm
                                             Tuple (ExnTyArr ExnTy' ExnVar' ExnTy'' Exn'') kenv'  = instantiate ExnTy
                                        in   Triple ExnTy_0 Exn_0 i  <- Triple bottomTyU ExnEmpty 0
                                             do  subst                     <- Subst ExnVar' Exn_i . match EmptyEnv ExnTy_i ExnTy'
                                                 Triple ExnTy_i1 Exn_i1 i  <- Triple  (simplify kenv (applySubst ExnTy'')) (simplify kenv (applySubst Exn'')) (i+1)
                                             until (Tuple ExnTy_i Exn_i) == Tuple ExnTy_im Exn_im
                                             return (Tuple ExnTy_i (simplify kenv (ExnUnion Exn Exn_i)))

    reconstruct env kenv (BinOp)     =  let  Tuple ExnTyInt Exn_1  = reconstruct env kenv tm_1
                                             Tuple ExnTyInt Exn_2  = reconstruct env kenv tm_2
                                        in   Tuple ExnTyBool (simplify kenv (ExnUnion Exn_1 Exn_2))

    reconstruct env kenv (Seq)       
                                     =  let  Tuple ExnTy_1 Exn_1  = reconstruct env kenv tm_1
                                             Tuple ExnTy_2 Exn_2  = reconstruct env kenv tm_2
                                        in   Tuple ExnTy_2 (simplify kenv (ExnUnion Exn_1 Exn_2))

    reconstruct env kenv (If)        
                                     =  let  Tuple ExnTyBool Exn_1  = reconstruct env kenv tm_1
                                             Tuple ExnTy_2 Exn_2    = reconstruct env kenv tm_2
                                             Tuple ExnTy_3 Exn_3    = reconstruct env kenv tm_3
                                        in   Tuple (simplify kenv (ExnTyJoin ExnTy_2 ExnTy_3)) (simplify kenv (ExnUnion Exn_1 (ExnUnion Exn_2 Exn_3)))

    reconstruct env kenv Nil         =  Result (ExnTyList bottomTy ExnEmpty) ExnEmpty

    reconstruct env kenv (Cons)      =  let  Tuple ExnTy_1 Exn_1                     = reconstruct env kenv tm_1
                                             Tuple (ExnTyList ExnTy_2 Exn_2') Exn_2  = reconstruct env kenv tm_2
                                        in   Tuple (simplify kenv (ExnTyList (ExnTyJoin ExnTy_1 ExnTy_2) (ExnUnion Exn_1 Exn_2'))) Exn_2

    reconstruct env kenv (Case)      
                                     =  let  Tuple (ExnTyList ExnTy_1 Exn_1') Exn_1   = reconstruct env kenv tm_1
                                             Tuple ExnTy_2 Exn_2                    = reconstruct ((extendTyEnv (extendTyEnv env Var_1 ExnTy_1 Exn_1') Var_2 (ExnTyList ExnTy_1 Exn_1') Exn_1)) kenv tm_2
                                             Tuple ExnTy_3 Exn_3                    = reconstruct env kenv tm_3
                                        in   Tuple (simplify kenv (ExnTyJoin ExnTy_2 ExnTy_3)) (simplify kenv (ExnUnion Exn_1 (ExnUnion Exn_2 Exn_3)))
\end{code}
\caption{Type inference algorithm}
\end{figure}

\begin{itemize}

    \item In R-App and R-Fix: check that the fresh variables generated by |instantiate| are subsituted away by the substitution |subst| created by |match|. Also, we don't need those variables in the algorithm if we don't generate the elaborated term.

    \item In R-Fix we could get rid of the auxillary underlying type function if the fixpoint construct was replaced with a binding variant with an explicit type annotation.
    
    \item For R-Fix, make sure the way we handle fixpoints of exceptional value in a manner that is sound w.r.t. to the operational semantics we are going to give to this.

    \item Note that we do not construct the elaborated term, as it is not useful other than for metatheoretic purposes.
    
    \item Lemma: The algorithm maintains the invariant that exception types and exceptions are in normal form.

\end{itemize}

\subsection{Subtyping}

\begin{itemize}
    \item Is \CiteRule{S-Refl} an admissable/derivable rule, or should we drop \CiteRule{S-Bool} and \CiteRule{S-Int}?
\end{itemize}

\begin{figure}
    \begin{gather*}
        \Rule{S-Refl}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy}}
        \quad
        \Rule{S-Trans}
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_2}
              \quad
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_3}
             }
             {\JudgeSubTy{\KiEnv}{\ExnTy_1}{\ExnTy_3}}
        \\[1.5ex]
        \Rule{S-Bool}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnBool}{\ExnBool}}
        \quad
        \Rule{S-Int}
             {}
             {\JudgeSubTy{\KiEnv}{\ExnInt}{\ExnInt}}
        \\[1.5ex]
        \Rule{S-Arr}
             {\JudgeSubTy{\KiEnv}{\ExnTy_1^\prime}{\ExnTy_1}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn_1^\prime}{\Exn_1}
                \quad
              \JudgeSubTy{\KiEnv}{\ExnTy_2}{\ExnTy_2^\prime}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn_2}{\Exn_2^\prime}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyArr{\ExnTy_1}{\Exn_1}{\ExnTy_2}{\Exn_2}}
                         {\ExnTyArr{\ExnTy_1^\prime}{\Exn_1^\prime}{\ExnTy_2^\prime}{\Exn_2^\prime}}
             }
        \\[1.5ex]
        \Rule{S-List}
             {\JudgeSubTy{\KiEnv}{\ExnTy}{\ExnTy^\prime}
                \quad
              \JudgeSubExn{\KiEnv}{\Exn}{\Exn^\prime}
             }
             {\JudgeSubTy{\KiEnv}
                         {\ExnTyList{\ExnTy}{\Exn}}
                         {\ExnTyList{\ExnTy^\prime}{\Exn^\prime}}
             }
        \quad
        \Rule{S-Forall}
             {\JudgeSubTy{\KiEnv, \ExnVar : \Kind}{\ExnTy_1}{\ExnTy_2}}
             {\JudgeSubTy{\KiEnv}
                         {\ExnForall{\ExnVar : \Kind}{\ExnTy_1}}
                         {\ExnForall{\ExnVar : \Kind}{\ExnTy_2}}
             }
    \end{gather*}
\caption{Subtyping}
\end{figure}

\begin{itemize}

    \item Possibly useful lemma: $\ExnTy_1 = \ExnTy_2 \iff \ExnTy_1 \leq \ExnTy_2 \land \ExnTy_2 \leq \ExnTy_1$.

\end{itemize}
