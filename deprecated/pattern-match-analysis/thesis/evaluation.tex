\chapter{Evaluation}\label{chapevaluation}

\section{Examples}

\subsection{Higher-order functions}

Given the program
\begin{code}
main = \b -> \phi ->  if b
                      then  if  phi 42  then  100  else  200
                      else  if  phi 43  then  300  else  400
\end{code}
the analysis will infer the type $\forall \alpha\beta.\ \{\alpha \subseteq \{\FFalse,\TTrue\}, \beta \subseteq \{\FFalse, \TTrue\}\} \Rightarrow (\Bool^{\alpha} \overset{\top}{\to} ((\Int^{\{\mathbf{+}\}} \overset{\top}{\to} \Bool^{\beta}) \overset{\top}{\to} \Int^{\{\mathbf{+}\}}))$.

\subsection{Detecting pattern match failures}

Given the program
\begin{code}
main =  let  f =  \b  -> \phi ->  if b
                                  then  if  phi  [42]  then  100  else  200
                                  else  if  phi  [43]  then  300  else  400
             g =  \x  -> case  x of
                               []     -> True
             h =  \x  -> case  x of
                               (a:as) -> True
        in f True g
\end{code}
the analysis will report that a pattern match failure occurs. Changing |f True g| into |f True h| will make the pattern match failure---and the reporting of it by the analysis---go away.

\subsection{|filter|}
We given the program
\begin{code}
main = let filter = \p -> \ys -> case  ys of
                                       []      ->  []
                                       (x:xs)  ->  let g = p x
                                                   in if g  then x :  filter p xs
                                                            else      filter p xs
       in filter (\x -> x) [True, False]
\end{code}
the analysis will infer the type $\ListOf{\Bool^{\{\FFalse,\TTrue\}}}^\top$.

\section{Limitations}

\subsection{Context-insensitivity}

The analysis is \emph{context-insensitive}. Given the program:

\begin{code}
main =  let f = \b ->  let tail = \xss -> case  xss of
                                                (x:xs) -> xs
                       in tail (if b then [] else [1,2,3])
         in f False
\end{code}
a pattern match failure will be reported. One does not occur practice, as the value $\FFalse$ passed to $b$ will prevent an empty list being returned from the if-then-else expression to |tail|. Section \ref{ctxsens} discusses how to alleviate this limitation.

\subsection{Structurally recursive functions}

Our analysis suffer from another limitation: the inferred type for a number of structurally recursive function such as |map| and |foldr| is not precise enough.

While the inferred type for |tail|
\[ \forall \alpha, (\beta \subseteq \Conss{\gamma}).\ \ListOf{\alpha}^\beta \to \ListOf{\alpha}^\gamma \]
expresses everything we can say about the function---the values of the elements in the list are preserved and the lenght is output list is one element shorten than the input---this is not the case for |map|:
\[ \forall \alpha, \beta, \gamma.\ (\alpha \to \beta) \to \ListOf{\alpha}^\gamma \to \ListOf{\beta}^\top \]
Our constraint solver is not able to infer from the constraints generated by the pattern matching on the input list and subsequent cons of the modified head and tail that |map| preserves the length of the list. I.e., we would have expected the type
\[ \forall \alpha, \beta, \gamma.\ (\alpha \to \beta) \to \ListOf{\alpha}^\gamma \to \ListOf{\beta}^\gamma \]
This will be a severe limitation in practice, as even innocent functions such as |head (map id [1..9])| will result in a pattern match warning.
