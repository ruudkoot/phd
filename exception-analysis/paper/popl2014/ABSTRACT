Most statically typed functional programming languages allow programmers to write partial functions: functions that are not defined on all the elements of the domain they are claimed to work on by their type. Thus in practise, well-typed programs can--and do--still go wrong. A compiler should warn the programmer about the places in the program where such wrongness may occur. 

Contemporary compilers for functional languages employ a local and purely syntactic analysis to detect incomplete case-expressions--those that do not cover all possible patterns of constructors allowed for by the type of the scrutinee, the source of most partiality in a program. As programs often maintain invariants on their data--restricting the potential values of the scrutinee to a subtype of its given or inferred type--many of these incomplete case-expressions are in actuality completely benign. Such an analysis will thus report many false positives, overwhelming the programmer.

We develop and prove the correctness of a constraint-based type system that detects harmful sources of partiality by accurately tracing the flow of both exceptions--the manifestation of partiality gone wrong--and ordinary data through the program, as well as the dependencies between them. The latter is crucial for usable precision, but has been omitted from previously published exception analyses.
